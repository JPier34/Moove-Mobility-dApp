{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     *\n     * NOTE: ERC-2981 allows setting the royalty to 100% of the price. In that case all the price would be sent to the\n     * royalty receiver and 0 tokens to the seller. Contracts dealing with royalty should consider empty transfers.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\nimport {IERC721} from \"./IERC721.sol\";\n\n/// @title ERC-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/token/common/ERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC2981} from \"../../interfaces/IERC2981.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the ERC. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n */\nabstract contract ERC2981 is IERC2981, ERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n    mapping(uint256 tokenId => RoyaltyInfo) private _tokenRoyaltyInfo;\n\n    /**\n     * @dev The default royalty set is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The default royalty receiver is invalid.\n     */\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n\n    /**\n     * @dev The royalty set for a specific `tokenId` is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The royalty receiver for `tokenId` is invalid.\n     */\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC2981\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) public view virtual returns (address receiver, uint256 amount) {\n        RoyaltyInfo storage _royaltyInfo = _tokenRoyaltyInfo[tokenId];\n        address royaltyReceiver = _royaltyInfo.receiver;\n        uint96 royaltyFraction = _royaltyInfo.royaltyFraction;\n\n        if (royaltyReceiver == address(0)) {\n            royaltyReceiver = _defaultRoyaltyInfo.receiver;\n            royaltyFraction = _defaultRoyaltyInfo.royaltyFraction;\n        }\n\n        uint256 royaltyAmount = (salePrice * royaltyFraction) / _feeDenominator();\n\n        return (royaltyReceiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        delete _tokenRoyaltyInfo[tokenId];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"./utils/ERC721Utils.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if:\n     * - `spender` does not have approval from `owner` for `tokenId`.\n     * - `spender` does not have approval to manage all of `owner`'s assets.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/extensions/ERC721Royalty.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {ERC2981} from \"../../common/ERC2981.sol\";\n\n/**\n * @dev Extension of ERC-721 with the ERC-2981 NFT Royalty Standard, a standardized way to retrieve royalty payment\n * information.\n *\n * Royalty information can be specified globally for all token ids via {ERC2981-_setDefaultRoyalty}, and/or individually\n * for specific token ids via {ERC2981-_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the ERC. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n */\nabstract contract ERC721Royalty is ERC2981, ERC721 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC2981) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {Strings} from \"../../../utils/Strings.sol\";\nimport {IERC4906} from \"../../../interfaces/IERC4906.sol\";\nimport {IERC165} from \"../../../interfaces/IERC165.sol\";\n\n/**\n * @dev ERC-721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is IERC4906, ERC721 {\n    using Strings for uint256;\n\n    // Interface ID as defined in ERC-4906. This does not correspond to a traditional interface ID as ERC-4906 only\n    // defines events and does not include any external function.\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n\n    // Optional mapping for token URIs\n    mapping(uint256 tokenId => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC165-supportsInterface}\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via string.concat).\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Emits {IERC4906-MetadataUpdate}.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        _tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC721/utils/ERC721Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../IERC721Receiver.sol\";\nimport {IERC721Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-721 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-721[ERC-721].\n *\n * _Available since v5.1._\n */\nlibrary ERC721Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC721Receiver-onERC721Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC721Receiver-onERC721Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(operator, from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    // Token rejected\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC721Receiver implementer\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IMooveAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IMooveAuction {\r\n    struct Auction {\r\n        uint256 nftId;\r\n        address nftContract;\r\n        AuctionType auctionType;\r\n        uint256 startPrice;\r\n        uint256 reservePrice;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        address highestBidder;\r\n        uint256 highestBid;\r\n        bool ended;\r\n        mapping(address => uint256) bids;\r\n    }\r\n\r\n    enum AuctionType {\r\n        TRADITIONAL,\r\n        ENGLISH,\r\n        DUTCH,\r\n        SEALED_BID\r\n    }\r\n\r\n    function createAuction(\r\n        uint256 nftId,\r\n        address nftContract,\r\n        AuctionType auctionType,\r\n        uint256 startPrice,\r\n        uint256 reservePrice,\r\n        uint256 duration\r\n    ) external;\r\n\r\n    function placeBid(uint256 auctionId) external payable;\r\n\r\n    function endAuction(uint256 auctionId) external;\r\n}\r\n"
    },
    "contracts/interfaces/IMooveCustomization.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\n// ============= ENUMS & STRUCTS =============\r\n\r\nenum CustomizationType {\r\n    AESTHETIC,\r\n    PERFORMANCE,\r\n    SPECIAL,\r\n    LIMITED_EDITION\r\n}\r\n\r\nstruct Customization {\r\n    uint256 id;\r\n    string name;\r\n    string description;\r\n    CustomizationType custType;\r\n    uint256 price;\r\n    string imageURI;\r\n    bool isActive;\r\n    uint32 maxSupply; // Optimized: reduced from uint256\r\n    uint32 currentSupply; // Optimized: reduced from uint256\r\n}\r\n\r\nstruct PerformanceUpgrade {\r\n    uint8 speedBonus;\r\n    uint8 accelerationBonus;\r\n    uint8 handlingBonus;\r\n    uint8 durabilityBonus;\r\n}\r\n\r\nstruct AestheticCustomization {\r\n    string colorCode;\r\n    uint256 skinId;\r\n    uint256[] decalIds;\r\n    string customURI;\r\n}\r\n\r\n/**\r\n * @title IMooveCustomization\r\n * @dev Interface for virtual vehicle NFT customizations\r\n * @notice All customizations are purely virtual and affect only NFT metadata and visual representation\r\n */\r\ninterface IMooveCustomization {\r\n    // ============= EVENTS =============\r\n\r\n    event CustomizationCreated(\r\n        uint256 indexed customizationId,\r\n        string name,\r\n        CustomizationType custType,\r\n        uint256 price\r\n    );\r\n\r\n    event CustomizationApplied(\r\n        uint256 indexed tokenId,\r\n        uint256 indexed customizationId,\r\n        address indexed owner,\r\n        uint256 price\r\n    );\r\n\r\n    event CustomizationRemoved(\r\n        uint256 indexed tokenId,\r\n        uint256 indexed customizationId,\r\n        address indexed owner\r\n    );\r\n\r\n    event CustomizationPriceUpdated(\r\n        uint256 indexed customizationId,\r\n        uint256 oldPrice,\r\n        uint256 newPrice\r\n    );\r\n\r\n    // ============= CUSTOMIZATION MANAGEMENT =============\r\n\r\n    /**\r\n     * @dev Create a new customization option\r\n     * @param name Name of the customization\r\n     * @param description Description of the customization\r\n     * @param custType Type of customization\r\n     * @param price Price in ETH\r\n     * @param imageURI URI for the customization image\r\n     * @param maxSupply Maximum supply of this customization\r\n     * @return customizationId The ID of the newly created customization\r\n     */\r\n    function createCustomization(\r\n        string calldata name, // Optimized: changed from memory to calldata\r\n        string calldata description, // Optimized: changed from memory to calldata\r\n        CustomizationType custType,\r\n        uint256 price,\r\n        string calldata imageURI, // Optimized: changed from memory to calldata\r\n        uint256 maxSupply\r\n    ) external returns (uint256 customizationId);\r\n\r\n    /**\r\n     * @dev Apply customization to NFT\r\n     * @param tokenId Token ID to customize\r\n     * @param customizationId Customization ID to apply\r\n     */\r\n    function applyCustomization(\r\n        uint256 tokenId,\r\n        uint256 customizationId\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Remove a customization from a vehicle NFT\r\n     * @param tokenId Token ID of the vehicle\r\n     * @param customizationId Customization ID to remove\r\n     * @return success Whether the removal was successful\r\n     */\r\n    function removeCustomization(\r\n        uint256 tokenId,\r\n        uint256 customizationId\r\n    ) external returns (bool success);\r\n\r\n    /**\r\n     * @dev Apply performance upgrade to a vehicle NFT\r\n     * @param tokenId Token ID of the vehicle\r\n     * @param upgrade Performance upgrade to apply\r\n     * @return success Whether the upgrade was successful\r\n     */\r\n    function applyPerformanceUpgrade(\r\n        uint256 tokenId,\r\n        PerformanceUpgrade calldata upgrade // Optimized: changed from memory to calldata\r\n    ) external payable returns (bool success);\r\n\r\n    /**\r\n     * @dev Apply aesthetic customization to a vehicle NFT\r\n     * @param tokenId Token ID of the vehicle\r\n     * @param aesthetic Aesthetic customization to apply\r\n     * @return success Whether the customization was successful\r\n     */\r\n    function applyAestheticCustomization(\r\n        uint256 tokenId,\r\n        AestheticCustomization calldata aesthetic // Optimized: changed from memory to calldata\r\n    ) external payable returns (bool success);\r\n\r\n    // ============= QUERY FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Get customization details by ID\r\n     * @param customizationId ID of the customization\r\n     * @return customization Customization details\r\n     */\r\n    function getCustomization(\r\n        uint256 customizationId\r\n    ) external view returns (Customization memory customization);\r\n\r\n    /**\r\n     * @dev Get all active customizations\r\n     * @return customizations Array of active customizations\r\n     */\r\n    function getActiveCustomizations()\r\n        external\r\n        view\r\n        returns (Customization[] memory customizations);\r\n\r\n    /**\r\n     * @dev Get customizations by type\r\n     * @param custType Type of customization to filter by\r\n     * @return customizations Array of customizations of the specified type\r\n     */\r\n    function getCustomizationsByType(\r\n        CustomizationType custType\r\n    ) external view returns (Customization[] memory customizations);\r\n\r\n    /**\r\n     * @dev Get all customizations applied to a vehicle\r\n     * @param tokenId Token ID of the vehicle\r\n     * @return customizationIds Array of applied customization IDs\r\n     */\r\n    function getVehicleCustomizations(\r\n        uint256 tokenId\r\n    ) external view returns (uint256[] memory customizationIds);\r\n\r\n    /**\r\n     * @dev Check if a customization is applied to a vehicle\r\n     * @param tokenId Token ID of the vehicle\r\n     * @param customizationId Customization ID to check\r\n     * @return isApplied Whether the customization is applied\r\n     */\r\n    function isCustomizationApplied(\r\n        uint256 tokenId,\r\n        uint256 customizationId\r\n    ) external view returns (bool isApplied);\r\n\r\n    /**\r\n     * @dev Calculate total cost for multiple customizations\r\n     * @param customizationIds Array of customization IDs\r\n     * @return totalCost Total cost in ETH\r\n     */\r\n    function calculateTotalCost(\r\n        uint256[] memory customizationIds\r\n    ) external view returns (uint256 totalCost);\r\n\r\n    /**\r\n     * @dev Get vehicle performance stats\r\n     * @param tokenId Token ID of the vehicle\r\n     * @return upgrade Current performance upgrade stats\r\n     */\r\n    function getVehiclePerformance(\r\n        uint256 tokenId\r\n    ) external view returns (PerformanceUpgrade memory upgrade);\r\n\r\n    /**\r\n     * @dev Get vehicle aesthetic customizations\r\n     * @param tokenId Token ID of the vehicle\r\n     * @return aesthetic Current aesthetic customization\r\n     */\r\n    function getVehicleAesthetics(\r\n        uint256 tokenId\r\n    ) external view returns (AestheticCustomization memory aesthetic);\r\n\r\n    // ============= ADMIN FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Update customization price\r\n     * @param customizationId ID of the customization\r\n     * @param newPrice New price in ETH\r\n     */\r\n    function updateCustomizationPrice(\r\n        uint256 customizationId,\r\n        uint256 newPrice\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Set customization active status\r\n     * @param customizationId ID of the customization\r\n     * @param isActive Whether the customization should be active\r\n     */\r\n    function setCustomizationActive(\r\n        uint256 customizationId,\r\n        bool isActive\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Update customization image URI\r\n     * @param customizationId ID of the customization\r\n     * @param newImageURI New image URI\r\n     */\r\n    function updateCustomizationImage(\r\n        uint256 customizationId,\r\n        string calldata newImageURI // Optimized: changed from memory to calldata\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw contract balance\r\n     * @param to Recipient address\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function withdraw(\r\n        address payable to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Emergency pause function\r\n     */\r\n    function pause() external;\r\n\r\n    /**\r\n     * @dev Unpause function\r\n     */\r\n    function unpause() external;\r\n}\r\n"
    },
    "contracts/interfaces/IMooveVehicleNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ninterface IMooveVehicleNFT {\r\n    struct VehicleInfo {\r\n        uint256 tokenId;\r\n        VehicleType vehicleType;\r\n        string name;\r\n        string description;\r\n        uint256 dailyRate;\r\n        bool isActive;\r\n        address currentOwner;\r\n    }\r\n\r\n    enum VehicleType {\r\n        BIKE,\r\n        SCOOTER,\r\n        MONOPATTINO\r\n    }\r\n\r\n    function mint(\r\n        address to,\r\n        uint256 tokenId,\r\n        VehicleType vehicleType\r\n    ) external;\r\n\r\n    function setDailyRate(uint256 tokenId, uint256 rate) external;\r\n\r\n    function getVehicleInfo(\r\n        uint256 tokenId\r\n    ) external view returns (VehicleInfo memory);\r\n}\r\n"
    },
    "contracts/libraries/PriceCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nlibrary PriceCalculator {\r\n    function calculateDutchPrice(\r\n        uint256 startPrice,\r\n        uint256 endPrice,\r\n        uint256 startTime,\r\n        uint256 endTime\r\n    ) internal view returns (uint256) {\r\n        if (block.timestamp >= endTime) return endPrice;\r\n        if (block.timestamp <= startTime) return startPrice;\r\n\r\n        uint256 elapsed = block.timestamp - startTime;\r\n        uint256 duration = endTime - startTime;\r\n        uint256 priceReduction = ((startPrice - endPrice) * elapsed) / duration;\r\n\r\n        return startPrice - priceReduction;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/VehicleMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nlibrary VehicleMetadata {\r\n    struct CustomizationData {\r\n        string[] stickers;\r\n        string colorScheme;\r\n        string[] achievements;\r\n        uint256 lastUpdated;\r\n    }\r\n\r\n    function addSticker(\r\n        CustomizationData storage data,\r\n        string memory sticker\r\n    ) internal {\r\n        data.stickers.push(sticker);\r\n        data.lastUpdated = block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/MooveAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title MooveAccessControl\r\n * @dev Centralized access control system for the Moove ecosystem\r\n * @notice Manages roles, permissions, and security features across all Moove contracts\r\n */\r\ncontract MooveAccessControl is AccessControl, Pausable, ReentrancyGuard {\r\n    // ============= ROLE DEFINITIONS =============\r\n\r\n    /// @dev Master admin role - can grant/revoke all other roles\r\n    bytes32 public constant MASTER_ADMIN_ROLE = keccak256(\"MASTER_ADMIN_ROLE\");\r\n\r\n    /// @dev NFT minting permissions\r\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n\r\n    /// @dev Auction and marketplace management\r\n    bytes32 public constant AUCTION_MANAGER_ROLE =\r\n        keccak256(\"AUCTION_MANAGER_ROLE\");\r\n\r\n    /// @dev Vehicle customization management\r\n    bytes32 public constant CUSTOMIZATION_ADMIN_ROLE =\r\n        keccak256(\"CUSTOMIZATION_ADMIN_ROLE\");\r\n\r\n    /// @dev Price and fee management\r\n    bytes32 public constant PRICE_MANAGER_ROLE =\r\n        keccak256(\"PRICE_MANAGER_ROLE\");\r\n\r\n    /// @dev Emergency pause permissions\r\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n\r\n    /// @dev Fund withdrawal permissions\r\n    bytes32 public constant WITHDRAWER_ROLE = keccak256(\"WITHDRAWER_ROLE\");\r\n\r\n    /// @dev Contract upgrade permissions\r\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\r\n\r\n    /// @dev Metadata management permissions\r\n    bytes32 public constant METADATA_MANAGER_ROLE =\r\n        keccak256(\"METADATA_MANAGER_ROLE\");\r\n\r\n    bytes32 public constant TRADER_ROLE = keccak256(\"TRADER_ROLE\");\r\n    bytes32 public constant MARKETPLACE_MANAGER_ROLE =\r\n        keccak256(\"MARKETPLACE_MANAGER_ROLE\");\r\n\r\n    // ============= STATE VARIABLES =============\r\n\r\n    /// @dev Mapping to track authorized contract addresses\r\n    mapping(address => bool) public authorizedContracts;\r\n\r\n    /// @dev Mapping to track emergency contacts\r\n    mapping(address => bool) public emergencyContacts;\r\n\r\n    /// @dev Time lock duration for critical operations (in seconds)\r\n    uint256 public timeLockDuration = 24 hours;\r\n\r\n    /// @dev Mapping to track time-locked operations\r\n    mapping(bytes32 => uint256) public timelockExecutions;\r\n\r\n    /// @dev Mapping to track role members for enumeration (if needed)\r\n    mapping(bytes32 => address[]) private _roleMembers;\r\n    mapping(bytes32 => mapping(address => uint256)) private _roleMemberIndex;\r\n\r\n    /// @dev Global pause state that affects all contracts\r\n    bool public globalPause = false;\r\n\r\n    /// @dev Maximum number of admins allowed\r\n    uint256 public constant MAX_ADMINS = 10;\r\n\r\n    /// @dev Current number of master admins\r\n    uint256 public masterAdminCount = 0;\r\n\r\n    // ============= EVENTS =============\r\n\r\n    /**\r\n     * @dev Emitted when a contract is authorized or deauthorized\r\n     */\r\n    event ContractAuthorizationChanged(\r\n        address indexed contractAddress,\r\n        bool authorized\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when an emergency contact is added or removed\r\n     */\r\n    event EmergencyContactChanged(address indexed contact, bool added);\r\n\r\n    /**\r\n     * @dev Emitted when timelock duration is updated\r\n     */\r\n    event TimeLockDurationUpdated(uint256 oldDuration, uint256 newDuration);\r\n\r\n    /**\r\n     * @dev Emitted when a time-locked operation is scheduled\r\n     */\r\n    event TimeLockOperationScheduled(\r\n        bytes32 indexed operationId,\r\n        uint256 executeAfter\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a time-locked operation is executed\r\n     */\r\n    event TimeLockOperationExecuted(bytes32 indexed operationId);\r\n\r\n    /**\r\n     * @dev Emitted when global pause state changes\r\n     */\r\n    event GlobalPauseStateChanged(bool paused);\r\n\r\n    // ============= MODIFIERS =============\r\n\r\n    /**\r\n     * @dev Modifier to check if caller is an authorized contract\r\n     */\r\n    modifier onlyAuthorizedContract() {\r\n        require(authorizedContracts[msg.sender], \"Not authorized contract\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to check if caller is emergency contact\r\n     */\r\n    modifier onlyEmergencyContact() {\r\n        require(\r\n            emergencyContacts[msg.sender] ||\r\n                hasRole(MASTER_ADMIN_ROLE, msg.sender),\r\n            \"Not emergency contact\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to ensure global pause is not active\r\n     */\r\n    modifier whenNotGloballyPaused() {\r\n        require(!globalPause, \"Globally paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier for time-locked operations\r\n     */\r\n    modifier onlyAfterTimelock(bytes32 operationId) {\r\n        require(\r\n            timelockExecutions[operationId] != 0 &&\r\n                block.timestamp >= timelockExecutions[operationId],\r\n            \"Operation not ready or not scheduled\"\r\n        );\r\n        _;\r\n        delete timelockExecutions[operationId];\r\n    }\r\n\r\n    // ============= CONSTRUCTOR =============\r\n\r\n    /**\r\n     * @dev Constructor sets up initial roles and admin\r\n     * @param initialAdmin Address to be granted master admin role\r\n     */\r\n    constructor(address initialAdmin) {\r\n        require(initialAdmin != address(0), \"Invalid admin address\");\r\n\r\n        // Grant master admin role to initial admin\r\n        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\r\n        _grantRole(MASTER_ADMIN_ROLE, initialAdmin);\r\n\r\n        // Set master admin as role admin for all roles\r\n        _setRoleAdmin(MINTER_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(AUCTION_MANAGER_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(CUSTOMIZATION_ADMIN_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(PRICE_MANAGER_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(PAUSER_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(WITHDRAWER_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(UPGRADER_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(METADATA_MANAGER_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(TRADER_ROLE, MASTER_ADMIN_ROLE);\r\n        _setRoleAdmin(MARKETPLACE_MANAGER_ROLE, MASTER_ADMIN_ROLE);\r\n\r\n        // Add initial admin as emergency contact\r\n        emergencyContacts[initialAdmin] = true;\r\n        masterAdminCount = 1;\r\n\r\n        emit EmergencyContactChanged(initialAdmin, true);\r\n    }\r\n\r\n    // ============= ROLE MANAGEMENT =============\r\n\r\n    /**\r\n     * @dev Grant master admin role with safety checks\r\n     * @param account Address to grant master admin role\r\n     */\r\n    function grantMasterAdmin(\r\n        address account\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        require(account != address(0), \"Invalid address\");\r\n        require(masterAdminCount < MAX_ADMINS, \"Too many admins\");\r\n        require(!hasRole(MASTER_ADMIN_ROLE, account), \"Already master admin\");\r\n\r\n        _grantRole(MASTER_ADMIN_ROLE, account);\r\n        emergencyContacts[account] = true;\r\n        masterAdminCount++;\r\n\r\n        emit EmergencyContactChanged(account, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Revoke master admin role with safety checks\r\n     * @param account Address to revoke master admin role from\r\n     */\r\n    function revokeMasterAdmin(\r\n        address account\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        require(account != msg.sender, \"Cannot revoke own admin\");\r\n        require(masterAdminCount > 1, \"Cannot remove last admin\");\r\n        require(hasRole(MASTER_ADMIN_ROLE, account), \"Not master admin\");\r\n\r\n        _revokeRole(MASTER_ADMIN_ROLE, account);\r\n        emergencyContacts[account] = false;\r\n        masterAdminCount--;\r\n\r\n        emit EmergencyContactChanged(account, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Batch grant roles to multiple addresses\r\n     * @param role The role to grant\r\n     * @param accounts Array of addresses to grant the role to\r\n     */\r\n    function batchGrantRole(\r\n        bytes32 role,\r\n        address[] calldata accounts\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            if (!hasRole(role, accounts[i])) {\r\n                _grantRole(role, accounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Batch revoke roles from multiple addresses\r\n     * @param role The role to revoke\r\n     * @param accounts Array of addresses to revoke the role from\r\n     */\r\n    function batchRevokeRole(\r\n        bytes32 role,\r\n        address[] calldata accounts\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            if (hasRole(role, accounts[i])) {\r\n                _revokeRole(role, accounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============= CONTRACT AUTHORIZATION =============\r\n\r\n    /**\r\n     * @dev Authorize a contract to interact with the system\r\n     * @param contractAddress Address of the contract to authorize\r\n     */\r\n    function authorizeContract(\r\n        address contractAddress\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        require(contractAddress != address(0), \"Invalid contract address\");\r\n        require(contractAddress.code.length > 0, \"Not a contract\");\r\n\r\n        authorizedContracts[contractAddress] = true;\r\n        emit ContractAuthorizationChanged(contractAddress, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Deauthorize a contract\r\n     * @param contractAddress Address of the contract to deauthorize\r\n     */\r\n    function deauthorizeContract(\r\n        address contractAddress\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        authorizedContracts[contractAddress] = false;\r\n        emit ContractAuthorizationChanged(contractAddress, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Batch authorize multiple contracts\r\n     * @param contractAddresses Array of contract addresses to authorize\r\n     */\r\n    function batchAuthorizeContracts(\r\n        address[] calldata contractAddresses\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        for (uint256 i = 0; i < contractAddresses.length; i++) {\r\n            if (\r\n                contractAddresses[i] != address(0) &&\r\n                contractAddresses[i].code.length > 0\r\n            ) {\r\n                authorizedContracts[contractAddresses[i]] = true;\r\n                emit ContractAuthorizationChanged(contractAddresses[i], true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check if user is able to trade\r\n     * @param account Account check\r\n     */\r\n\r\n    function canTrade(\r\n        address account\r\n    ) external view returns (bool hasTraderRole) {\r\n        return\r\n            hasRole(TRADER_ROLE, account) ||\r\n            hasRole(MASTER_ADMIN_ROLE, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if user is able to use Marketplace\r\n     * @param account Account check\r\n     */\r\n\r\n    function canManageMarketplace(\r\n        address account\r\n    ) external view returns (bool hasMarketplaceRole) {\r\n        return\r\n            hasRole(MARKETPLACE_MANAGER_ROLE, account) ||\r\n            hasRole(MASTER_ADMIN_ROLE, account);\r\n    }\r\n\r\n    // ============= EMERGENCY MANAGEMENT =============\r\n\r\n    /**\r\n     * @dev Add emergency contact\r\n     * @param contact Address to add as emergency contact\r\n     */\r\n    function addEmergencyContact(\r\n        address contact\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        require(contact != address(0), \"Invalid contact address\");\r\n\r\n        emergencyContacts[contact] = true;\r\n        emit EmergencyContactChanged(contact, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove emergency contact\r\n     * @param contact Address to remove as emergency contact\r\n     */\r\n    function removeEmergencyContact(\r\n        address contact\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        emergencyContacts[contact] = false;\r\n        emit EmergencyContactChanged(contact, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency pause - can be called by emergency contacts\r\n     */\r\n    function emergencyPause() external onlyEmergencyContact {\r\n        globalPause = true;\r\n        _pause();\r\n        emit GlobalPauseStateChanged(true);\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency unpause - requires master admin\r\n     */\r\n    function emergencyUnpause() external onlyRole(MASTER_ADMIN_ROLE) {\r\n        globalPause = false;\r\n        _unpause();\r\n        emit GlobalPauseStateChanged(false);\r\n    }\r\n\r\n    // ============= TIME LOCK OPERATIONS =============\r\n\r\n    /**\r\n     * @dev Schedule a time-locked operation\r\n     * @param operationId Unique identifier for the operation\r\n     */\r\n    function scheduleTimeLockOperation(\r\n        bytes32 operationId\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        require(\r\n            timelockExecutions[operationId] == 0,\r\n            \"Operation already scheduled\"\r\n        );\r\n\r\n        uint256 executeAfter = block.timestamp + timeLockDuration;\r\n        timelockExecutions[operationId] = executeAfter;\r\n\r\n        emit TimeLockOperationScheduled(operationId, executeAfter);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel a time-locked operation\r\n     * @param operationId Unique identifier for the operation\r\n     */\r\n    function cancelTimeLockOperation(\r\n        bytes32 operationId\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        require(\r\n            timelockExecutions[operationId] != 0,\r\n            \"Operation not scheduled\"\r\n        );\r\n\r\n        delete timelockExecutions[operationId];\r\n    }\r\n\r\n    /**\r\n     * @dev Update timelock duration\r\n     * @param newDuration New duration in seconds\r\n     */\r\n    function updateTimeLockDuration(\r\n        uint256 newDuration\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) {\r\n        require(\r\n            newDuration >= 1 hours && newDuration <= 7 days,\r\n            \"Invalid duration\"\r\n        );\r\n\r\n        uint256 oldDuration = timeLockDuration;\r\n        timeLockDuration = newDuration;\r\n\r\n        emit TimeLockDurationUpdated(oldDuration, newDuration);\r\n    }\r\n\r\n    // ============= QUERY FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Check if an address has minting permissions\r\n     * @param account Address to check\r\n     * @return hasMinterRole True if address can mint\r\n     */\r\n    function canMint(\r\n        address account\r\n    ) external view returns (bool hasMinterRole) {\r\n        return\r\n            hasRole(MINTER_ROLE, account) ||\r\n            hasRole(MASTER_ADMIN_ROLE, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address can manage auctions\r\n     * @param account Address to check\r\n     * @return hasAuctionRole True if address can manage auctions\r\n     */\r\n    function canManageAuctions(\r\n        address account\r\n    ) external view returns (bool hasAuctionRole) {\r\n        return\r\n            hasRole(AUCTION_MANAGER_ROLE, account) ||\r\n            hasRole(MASTER_ADMIN_ROLE, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address can manage customizations\r\n     * @param account Address to check\r\n     * @return hasCustomizationRole True if address can manage customizations\r\n     */\r\n    function canManageCustomizations(\r\n        address account\r\n    ) external view returns (bool hasCustomizationRole) {\r\n        return\r\n            hasRole(CUSTOMIZATION_ADMIN_ROLE, account) ||\r\n            hasRole(MASTER_ADMIN_ROLE, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address can manage prices\r\n     * @param account Address to check\r\n     * @return hasPriceRole True if address can manage prices\r\n     */\r\n    function canManagePrices(\r\n        address account\r\n    ) external view returns (bool hasPriceRole) {\r\n        return\r\n            hasRole(PRICE_MANAGER_ROLE, account) ||\r\n            hasRole(MASTER_ADMIN_ROLE, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address can pause contracts\r\n     * @param account Address to check\r\n     * @return hasPauserRole True if address can pause\r\n     */\r\n    function canPause(\r\n        address account\r\n    ) external view returns (bool hasPauserRole) {\r\n        return\r\n            hasRole(PAUSER_ROLE, account) ||\r\n            hasRole(MASTER_ADMIN_ROLE, account) ||\r\n            emergencyContacts[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address can withdraw funds\r\n     * @param account Address to check\r\n     * @return hasWithdrawRole True if address can withdraw\r\n     */\r\n    function canWithdraw(\r\n        address account\r\n    ) external view returns (bool hasWithdrawRole) {\r\n        return\r\n            hasRole(WITHDRAWER_ROLE, account) ||\r\n            hasRole(MASTER_ADMIN_ROLE, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Get all role members for a specific role\r\n     * @param role The role to query\r\n     * @return members Array of addresses with the role\r\n     */\r\n    function getRoleMembers(\r\n        bytes32 role\r\n    ) external view returns (address[] memory members) {\r\n        return _roleMembers[role];\r\n    }\r\n\r\n    /**\r\n     * @dev Get number of members for a specific role\r\n     * @param role The role to query\r\n     * @return count Number of addresses with the role\r\n     */\r\n    function getRoleMemberCount(\r\n        bytes32 role\r\n    ) external view returns (uint256 count) {\r\n        return _roleMembers[role].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Execute time-locked operation validation\r\n     * @param operationId The operation ID to validate\r\n     */\r\n    function executeTimeLockOperation(\r\n        bytes32 operationId\r\n    ) external onlyRole(MASTER_ADMIN_ROLE) onlyAfterTimelock(operationId) {\r\n        emit TimeLockOperationExecuted(operationId);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if the system is in global pause state\r\n     * @return isPaused True if globally paused\r\n     */\r\n    function isGloballyPaused() external view returns (bool isPaused) {\r\n        return globalPause;\r\n    }\r\n\r\n    // ============= EXTERNAL VALIDATION FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Validate that caller has required role (called by other contracts)\r\n     * @param role The role to check\r\n     * @param account The account to validate\r\n     */\r\n    function validateRole(\r\n        bytes32 role,\r\n        address account\r\n    ) external view onlyAuthorizedContract {\r\n        require(\r\n            hasRole(role, account) || hasRole(MASTER_ADMIN_ROLE, account),\r\n            \"Access denied\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Validate that system is not paused (called by other contracts)\r\n     */\r\n    function validateNotPaused() external view onlyAuthorizedContract {\r\n        require(!globalPause && !paused(), \"System paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Override _grantRole to track role members\r\n     */\r\n    function _grantRole(\r\n        bytes32 role,\r\n        address account\r\n    ) internal override returns (bool) {\r\n        super._grantRole(role, account);\r\n\r\n        // Track role member for enumeration\r\n        if (_roleMemberIndex[role][account] == 0) {\r\n            _roleMembers[role].push(account);\r\n            _roleMemberIndex[role][account] = _roleMembers[role].length;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Override _revokeRole to untrack role members\r\n     */\r\n    function _revokeRole(\r\n        bytes32 role,\r\n        address account\r\n    ) internal override returns (bool) {\r\n        super._revokeRole(role, account);\r\n\r\n        // Remove from role member tracking\r\n        uint256 index = _roleMemberIndex[role][account];\r\n        if (index > 0) {\r\n            uint256 lastIndex = _roleMembers[role].length;\r\n            address lastMember = _roleMembers[role][lastIndex - 1];\r\n\r\n            // Move last member to the position of the removed member\r\n            _roleMembers[role][index - 1] = lastMember;\r\n            _roleMemberIndex[role][lastMember] = index;\r\n\r\n            // Remove last element\r\n            _roleMembers[role].pop();\r\n            delete _roleMemberIndex[role][account];\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/MooveAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"./MooveAccessControl.sol\";\n\n/**\n * @title MooveAuction\n * @dev Advanced auction system with 4 different auction types for Moove Sticker NFTs\n * @notice Supports English, Dutch, Sealed Bid, and Reserve auctions\n */\ncontract MooveAuction is ReentrancyGuard, Pausable {\n    // ============= STATE VARIABLES =============\n\n    /// @dev Reference to access control contract\n    MooveAccessControl public immutable accessControl;\n\n    /// @dev Counter for auction IDs\n    uint256 private _auctionIdCounter;\n\n    /// @dev Mapping from auction ID to auction details\n    mapping(uint256 => Auction) public auctions;\n\n    /// @dev Mapping from auction ID to bids\n    mapping(uint256 => Bid[]) public auctionBids;\n\n    /// @dev Mapping from auction ID to sealed bids (for sealed bid auctions)\n    mapping(uint256 => mapping(address => bytes32)) public sealedBids;\n\n    /// @dev Mapping from auction ID to bidder reveal status\n    mapping(uint256 => mapping(address => bool)) public hasRevealed;\n\n    /// @dev Mapping from user to their active auctions\n    mapping(address => uint256[]) public userAuctions;\n\n    /// @dev Mapping from user to their active bids\n    mapping(address => uint256[]) public userBids;\n\n    /// @dev Platform fee percentage (250 = 2.5%)\n    uint256 public platformFeePercentage = 250;\n\n    /// @dev Minimum bid increment percentage (500 = 5%)\n    uint256 public minimumBidIncrement = 500;\n\n    /// @dev Maximum auction duration (30 days)\n    uint256 public constant MAX_AUCTION_DURATION = 30 days;\n\n    /// @dev Minimum auction duration (1 hour)\n    uint256 public constant MIN_AUCTION_DURATION = 1 hours;\n\n    /// @dev Maximum number of bids per auction to prevent DoS\n    uint256 public constant MAX_BIDS_PER_AUCTION = 1000;\n\n    /// @dev Minimum time between bids to prevent spam (5 minutes)\n    uint256 public constant MIN_BID_INTERVAL = 5 minutes;\n\n    /// @dev Mapping to track last bid time per user per auction\n    mapping(uint256 => mapping(address => uint256)) public lastBidTime;\n\n    // ============= STRUCTS =============\n\n    struct Auction {\n        uint256 auctionId;\n        address nftContract;\n        uint256 tokenId;\n        address seller;\n        AuctionType auctionType;\n        uint256 startingPrice;\n        uint256 reservePrice;\n        uint256 buyNowPrice;\n        uint256 currentPrice;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 bidIncrement;\n        address highestBidder;\n        uint256 highestBid;\n        AuctionStatus status;\n        bool allowPartialFulfillment;\n        uint256 minBidders;\n        uint256 totalBidders;\n        bool isSettled; // New field to prevent double settlement\n    }\n\n    struct Bid {\n        address bidder;\n        uint256 amount;\n        uint256 timestamp;\n        bool isWinning;\n        bool isRefunded;\n    }\n\n    struct SealedBidReveal {\n        uint256 amount;\n        uint256 nonce;\n    }\n\n    enum AuctionType {\n        ENGLISH, // Traditional ascending bid auction\n        DUTCH, // Descending price auction\n        SEALED_BID, // Sealed bid auction with reveal phase\n        RESERVE // Reserve auction with hidden minimum\n    }\n\n    enum AuctionStatus {\n        PENDING, // Created but not started\n        ACTIVE, // Currently accepting bids\n        REVEAL, // Sealed bid reveal phase\n        ENDED, // Finished, awaiting settlement\n        SETTLED, // Completed and settled\n        CANCELLED // Cancelled by seller or admin\n    }\n\n    // ============= EVENTS =============\n\n    event AuctionCreated(\n        uint256 indexed auctionId,\n        address indexed seller,\n        address indexed nftContract,\n        uint256 tokenId,\n        AuctionType auctionType,\n        uint256 startingPrice,\n        uint256 duration\n    );\n\n    event BidPlaced(\n        uint256 indexed auctionId,\n        address indexed bidder,\n        uint256 amount,\n        bool isHighestBid\n    );\n\n    event SealedBidSubmitted(\n        uint256 indexed auctionId,\n        address indexed bidder,\n        bytes32 bidHash\n    );\n\n    event SealedBidRevealed(\n        uint256 indexed auctionId,\n        address indexed bidder,\n        uint256 amount\n    );\n\n    event AuctionSettled(\n        uint256 indexed auctionId,\n        address indexed winner,\n        uint256 finalPrice,\n        uint256 platformFee,\n        uint256 royaltyFee\n    );\n\n    event AuctionCancelled(uint256 indexed auctionId, string reason);\n\n    event AuctionEnded(uint256 indexed auctionId);\n\n    event BidRefunded(\n        uint256 indexed auctionId,\n        address indexed bidder,\n        uint256 amount\n    );\n\n    event DutchPriceUpdate(uint256 indexed auctionId, uint256 newPrice);\n\n    event ReserveReached(uint256 indexed auctionId, uint256 reservePrice);\n\n    // ============= MODIFIERS =============\n\n    modifier onlyAccessControlRole(bytes32 role) {\n        accessControl.validateRole(role, msg.sender);\n        _;\n    }\n\n    modifier validAuction(uint256 auctionId) {\n        require(auctionId < _auctionIdCounter, \"Auction does not exist\");\n        _;\n    }\n\n    modifier onlyAuctionSeller(uint256 auctionId) {\n        require(auctions[auctionId].seller == msg.sender, \"Not auction seller\");\n        _;\n    }\n\n    modifier auctionActive(uint256 auctionId) {\n        require(\n            auctions[auctionId].status == AuctionStatus.ACTIVE,\n            \"Auction not active\"\n        );\n        require(\n            block.timestamp <= auctions[auctionId].endTime,\n            \"Auction ended\"\n        );\n        _;\n    }\n\n    modifier auctionEnded(uint256 auctionId) {\n        require(\n            auctions[auctionId].status == AuctionStatus.ENDED ||\n                block.timestamp > auctions[auctionId].endTime,\n            \"Auction still active\"\n        );\n        _;\n    }\n\n    modifier notSettled(uint256 auctionId) {\n        require(!auctions[auctionId].isSettled, \"Auction already settled\");\n        _;\n    }\n\n    modifier bidInterval(uint256 auctionId) {\n        require(\n            block.timestamp >= lastBidTime[auctionId][msg.sender] + MIN_BID_INTERVAL,\n            \"Bid too soon\"\n        );\n        _;\n    }\n\n    // ============= CONSTRUCTOR =============\n\n    constructor(address _accessControl) {\n        require(_accessControl != address(0), \"Invalid access control address\");\n        accessControl = MooveAccessControl(_accessControl);\n    }\n\n    // ============= AUCTION CREATION =============\n\n    /**\n     * @dev Create a new auction\n     * @param nftContract Address of the NFT contract\n     * @param tokenId Token ID to auction\n     * @param auctionType Type of auction\n     * @param startingPrice Starting price for the auction\n     * @param reservePrice Reserve price (minimum acceptable price)\n     * @param buyNowPrice Buy now price (0 if not applicable)\n     * @param duration Duration of the auction in seconds\n     * @param bidIncrement Minimum bid increment (0 for default)\n     */\n    function createAuction(\n        address nftContract,\n        uint256 tokenId,\n        AuctionType auctionType,\n        uint256 startingPrice,\n        uint256 reservePrice,\n        uint256 buyNowPrice,\n        uint256 duration,\n        uint256 bidIncrement\n    ) external nonReentrant whenNotPaused returns (uint256 auctionId) {\n        require(nftContract != address(0), \"Invalid NFT contract\");\n        require(startingPrice > 0, \"Starting price must be greater than 0\");\n        require(\n            duration >= MIN_AUCTION_DURATION &&\n                duration <= MAX_AUCTION_DURATION,\n            \"Invalid duration\"\n        );\n\n        // Verify NFT ownership and approval\n        IERC721 nft = IERC721(nftContract);\n        require(nft.ownerOf(tokenId) == msg.sender, \"Not NFT owner\");\n        require(\n            nft.isApprovedForAll(msg.sender, address(this)) ||\n                nft.getApproved(tokenId) == address(this),\n            \"NFT not approved\"\n        );\n\n        // Validate auction parameters based on type\n        _validateAuctionParameters(\n            auctionType,\n            startingPrice,\n            reservePrice,\n            buyNowPrice\n        );\n\n        auctionId = _auctionIdCounter++;\n        uint256 startTime = block.timestamp;\n        uint256 endTime = startTime + duration;\n\n        // Set bid increment\n        if (bidIncrement == 0) {\n            bidIncrement = (startingPrice * minimumBidIncrement) / 10000;\n            if (bidIncrement == 0) bidIncrement = 0.001 ether;\n        }\n\n        // Create auction\n        auctions[auctionId] = Auction({\n            auctionId: auctionId,\n            nftContract: nftContract,\n            tokenId: tokenId,\n            seller: msg.sender,\n            auctionType: auctionType,\n            startingPrice: startingPrice,\n            reservePrice: reservePrice,\n            buyNowPrice: buyNowPrice,\n            currentPrice: auctionType == AuctionType.DUTCH ? startingPrice : 0,\n            startTime: startTime,\n            endTime: endTime,\n            bidIncrement: bidIncrement,\n            highestBidder: address(0),\n            highestBid: 0,\n            status: AuctionStatus.ACTIVE,\n            allowPartialFulfillment: false,\n            minBidders: auctionType == AuctionType.SEALED_BID ? 2 : 1,\n            totalBidders: 0,\n            isSettled: false\n        });\n\n        // Add to user's auctions\n        userAuctions[msg.sender].push(auctionId);\n\n        // Transfer NFT to contract (escrow)\n        nft.transferFrom(msg.sender, address(this), tokenId);\n\n        emit AuctionCreated(\n            auctionId,\n            msg.sender,\n            nftContract,\n            tokenId,\n            auctionType,\n            startingPrice,\n            duration\n        );\n    }\n\n    // ============= BIDDING FUNCTIONS =============\n\n    /**\n     * @dev Place a bid on an English or Reserve auction\n     */\n    function placeBid(uint256 auctionId) external payable nonReentrant {\n        Auction storage auction = auctions[auctionId];\n        require(\n            auction.auctionType == AuctionType.ENGLISH ||\n                auction.auctionType == AuctionType.RESERVE,\n            \"Invalid auction type for this bid method\"\n        );\n        require(msg.sender != auction.seller, \"Seller cannot bid\");\n        require(auction.status == AuctionStatus.ACTIVE, \"Auction not active\");\n        require(block.timestamp < auction.endTime, \"Auction ended\");\n        require(msg.value > 0, \"Bid amount must be greater than 0\");\n\n        // Check minimum bid increment\n        uint256 minBid = auction.highestBid + auction.bidIncrement;\n        if (auction.highestBid == 0) {\n            minBid = auction.startingPrice;\n        }\n        require(msg.value >= minBid, \"Bid too low\");\n\n        // Check bid interval\n        require(\n            block.timestamp >= lastBidTime[auctionId][msg.sender] + MIN_BID_INTERVAL,\n            \"Bid too soon\"\n        );\n\n        // Update state first to prevent reentrancy\n        address previousBidder = auction.highestBidder;\n        uint256 previousBid = auction.highestBid;\n\n        // Update auction state\n        auction.highestBidder = msg.sender;\n        auction.highestBid = msg.value;\n        auction.totalBidders++;\n        lastBidTime[auctionId][msg.sender] = block.timestamp;\n\n        // Add bid to array\n        auctionBids[auctionId].push(\n            Bid({\n                bidder: msg.sender,\n                amount: msg.value,\n                timestamp: block.timestamp,\n                isWinning: true,\n                isRefunded: false\n            })\n        );\n\n        // Update previous bids to not winning\n        for (uint256 i = 0; i < auctionBids[auctionId].length - 1; i++) {\n            auctionBids[auctionId][i].isWinning = false;\n        }\n\n        // Add to user bids if not already there\n        if (!_hasUserBid(auctionId, msg.sender)) {\n            userBids[msg.sender].push(auctionId);\n        }\n\n        // Refund previous bidder\n        if (previousBidder != address(0)) {\n            _refundBid(auctionId, previousBidder, previousBid);\n        }\n\n        // Check if reserve price is met\n        if (auction.reservePrice > 0 && msg.value >= auction.reservePrice) {\n            emit ReserveReached(auctionId, auction.reservePrice);\n        }\n\n        emit BidPlaced(auctionId, msg.sender, msg.value, true);\n    }\n\n    /**\n     * @dev Purchase at current price for Dutch auction\n     */\n    function buyNowDutch(\n        uint256 auctionId\n    )\n        external\n        payable\n        validAuction(auctionId)\n        auctionActive(auctionId)\n        notSettled(auctionId)\n        nonReentrant\n    {\n        Auction storage auction = auctions[auctionId];\n        require(\n            auction.auctionType == AuctionType.DUTCH,\n            \"Not a Dutch auction\"\n        );\n        require(msg.sender != auction.seller, \"Seller cannot buy\");\n\n        uint256 currentPrice = _getDutchPrice(auctionId);\n        require(msg.value >= currentPrice, \"Insufficient payment\");\n\n        _executeBuyNow(auctionId, msg.sender, currentPrice);\n\n        // Refund excess payment\n        if (msg.value > currentPrice) {\n            payable(msg.sender).transfer(msg.value - currentPrice);\n        }\n    }\n\n    /**\n     * @dev Submit sealed bid (commitment phase)\n     */\n    function submitSealedBid(\n        uint256 auctionId,\n        bytes32 bidHash\n    )\n        external\n        payable\n        validAuction(auctionId)\n        auctionActive(auctionId)\n        notSettled(auctionId)\n        bidInterval(auctionId)\n        nonReentrant\n    {\n        Auction storage auction = auctions[auctionId];\n        require(\n            auction.auctionType == AuctionType.SEALED_BID,\n            \"Not a sealed bid auction\"\n        );\n        require(msg.sender != auction.seller, \"Seller cannot bid\");\n        require(msg.value >= auction.startingPrice, \"Bid below minimum\");\n        require(\n            sealedBids[auctionId][msg.sender] == bytes32(0),\n            \"Bid already submitted\"\n        );\n\n        // Prevent DoS by limiting number of bidders\n        require(\n            auction.totalBidders < MAX_BIDS_PER_AUCTION,\n            \"Too many bidders\"\n        );\n\n        // Update last bid time\n        lastBidTime[auctionId][msg.sender] = block.timestamp;\n\n        // Store sealed bid hash and escrow payment\n        sealedBids[auctionId][msg.sender] = bidHash;\n\n        // Track bidder\n        if (!_hasUserBid(auctionId, msg.sender)) {\n            auction.totalBidders++;\n            userBids[msg.sender].push(auctionId);\n        }\n\n        // Add to bid history (amount hidden)\n        auctionBids[auctionId].push(\n            Bid({\n                bidder: msg.sender,\n                amount: msg.value, // Escrowed amount, not actual bid\n                timestamp: block.timestamp,\n                isWinning: false,\n                isRefunded: false\n            })\n        );\n\n        emit SealedBidSubmitted(auctionId, msg.sender, bidHash);\n    }\n\n    /**\n     * @dev Reveal sealed bid\n     */\n    function revealSealedBid(\n        uint256 auctionId,\n        uint256 bidAmount,\n        uint256 nonce\n    ) external validAuction(auctionId) notSettled(auctionId) nonReentrant {\n        Auction storage auction = auctions[auctionId];\n        require(\n            auction.auctionType == AuctionType.SEALED_BID,\n            \"Not a sealed bid auction\"\n        );\n        require(auction.status == AuctionStatus.REVEAL, \"Not in reveal phase\");\n        require(!hasRevealed[auctionId][msg.sender], \"Already revealed\");\n        require(\n            sealedBids[auctionId][msg.sender] != bytes32(0),\n            \"No sealed bid submitted\"\n        );\n\n        // Verify bid hash\n        bytes32 bidHash = keccak256(\n            abi.encodePacked(bidAmount, nonce, msg.sender)\n        );\n        require(\n            sealedBids[auctionId][msg.sender] == bidHash,\n            \"Invalid bid reveal\"\n        );\n\n        hasRevealed[auctionId][msg.sender] = true;\n\n        // Find and update the bid in history\n        for (uint256 i = 0; i < auctionBids[auctionId].length; i++) {\n            if (auctionBids[auctionId][i].bidder == msg.sender) {\n                // Check if user escrowed enough\n                require(\n                    auctionBids[auctionId][i].amount >= bidAmount,\n                    \"Insufficient escrow\"\n                );\n\n                // Update with actual bid amount\n                auctionBids[auctionId][i].amount = bidAmount;\n                break;\n            }\n        }\n\n        // Check if this is the new highest bid\n        if (bidAmount > auction.highestBid) {\n            auction.highestBidder = msg.sender;\n            auction.highestBid = bidAmount;\n        }\n\n        emit SealedBidRevealed(auctionId, msg.sender, bidAmount);\n    }\n\n    // ============= AUCTION SETTLEMENT =============\n\n    /**\n     * @dev End auction when time expires (can be called by anyone)\n     */\n    function endAuction(uint256 auctionId) external validAuction(auctionId) {\n        Auction storage auction = auctions[auctionId];\n        require(\n            auction.status == AuctionStatus.ACTIVE,\n            \"Auction not active\"\n        );\n        require(\n            block.timestamp >= auction.endTime,\n            \"Auction not ended yet\"\n        );\n\n        auction.status = AuctionStatus.ENDED;\n        emit AuctionEnded(auctionId);\n    }\n\n    /**\n     * @dev Settle auction and transfer NFT to winner\n     */\n    function settleAuction(uint256 auctionId) external nonReentrant {\n        Auction storage auction = auctions[auctionId];\n        require(auction.status == AuctionStatus.ENDED, \"Auction not ready for settlement\");\n        require(auction.status == AuctionStatus.REVEAL, \"Reveal phase not started\");\n        require(block.timestamp > auction.endTime + 86400, \"Reveal phase not ended\");\n\n        address winner = auction.highestBidder;\n        uint256 winningBid = auction.highestBid;\n\n        require(winner != address(0), \"No winner found\");\n\n        // Update state first to prevent reentrancy\n        auction.status = AuctionStatus.SETTLED;\n\n        // Calculate fees\n        (\n            uint256 platformFee,\n            uint256 royaltyFee,\n            address royaltyRecipient\n        ) = _calculateFees(auction.nftContract, auction.tokenId, winningBid);\n\n        uint256 sellerProceeds = winningBid - platformFee - royaltyFee;\n\n        // Transfer NFT to winner\n        IERC721(auction.nftContract).transferFrom(\n            address(this),\n            winner,\n            auction.tokenId\n        );\n\n        // Transfer proceeds to seller\n        (bool sellerSuccess, ) = payable(auction.seller).call{value: sellerProceeds}(\"\");\n        require(sellerSuccess, \"Seller transfer failed\");\n\n        // Transfer royalty fee\n        if (royaltyFee > 0 && royaltyRecipient != address(0)) {\n            (bool royaltySuccess, ) = payable(royaltyRecipient).call{value: royaltyFee}(\"\");\n            require(royaltySuccess, \"Royalty transfer failed\");\n        }\n\n        // Refund losing bidders\n        _refundLosingBidders(auctionId);\n\n        emit AuctionSettled(\n            auctionId,\n            winner,\n            winningBid,\n            platformFee,\n            royaltyFee\n        );\n    }\n\n    /**\n     * @dev Start reveal phase for sealed bid auctions\n     */\n    function startRevealPhase(\n        uint256 auctionId\n    ) external validAuction(auctionId) {\n        Auction storage auction = auctions[auctionId];\n        require(\n            auction.auctionType == AuctionType.SEALED_BID,\n            \"Not a sealed bid auction\"\n        );\n        require(auction.status == AuctionStatus.ACTIVE, \"Auction not active\");\n        require(block.timestamp > auction.endTime, \"Auction still active\");\n\n        auction.status = AuctionStatus.REVEAL;\n        // Reveal phase lasts 24 hours\n        auction.endTime = block.timestamp + 24 hours;\n    }\n\n    // ============= AUCTION MANAGEMENT =============\n\n    /**\n     * @dev Cancel auction (seller or admin only)\n     */\n    function cancelAuction(\n        uint256 auctionId,\n        string memory reason\n    ) external validAuction(auctionId) notSettled(auctionId) nonReentrant {\n        Auction storage auction = auctions[auctionId];\n\n        require(\n            msg.sender == auction.seller ||\n                accessControl.hasRole(\n                    accessControl.MASTER_ADMIN_ROLE(),\n                    msg.sender\n                ),\n            \"Not authorized to cancel\"\n        );\n\n        require(\n            auction.status == AuctionStatus.PENDING ||\n                auction.status == AuctionStatus.ACTIVE,\n            \"Cannot cancel auction in current state\"\n        );\n\n        _cancelAuctionAndRefund(auctionId, reason);\n    }\n\n    /**\n     * @dev Emergency cancel by admin\n     */\n    function emergencyCancel(\n        uint256 auctionId,\n        string memory reason\n    ) external onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE()) {\n        _cancelAuctionAndRefund(auctionId, reason);\n    }\n\n    /**\n     * @dev Extend auction duration (admin only, emergency situations)\n     */\n    function extendAuction(\n        uint256 auctionId,\n        uint256 additionalTime\n    )\n        external\n        validAuction(auctionId)\n        onlyAccessControlRole(accessControl.AUCTION_MANAGER_ROLE())\n    {\n        Auction storage auction = auctions[auctionId];\n        require(auction.status == AuctionStatus.ACTIVE, \"Auction not active\");\n        require(additionalTime <= 24 hours, \"Extension too long\");\n\n        auction.endTime += additionalTime;\n    }\n\n    // ============= VIEW FUNCTIONS =============\n\n    /**\n     * @dev Get auction details\n     */\n    function getAuction(\n        uint256 auctionId\n    ) external view validAuction(auctionId) returns (Auction memory) {\n        return auctions[auctionId];\n    }\n\n    /**\n     * @dev Get auction bids\n     */\n    function getAuctionBids(\n        uint256 auctionId\n    ) external view validAuction(auctionId) returns (Bid[] memory) {\n        return auctionBids[auctionId];\n    }\n\n    /**\n     * @dev Get current price for Dutch auction\n     */\n    function getDutchPrice(\n        uint256 auctionId\n    ) external view validAuction(auctionId) returns (uint256) {\n        return _getDutchPrice(auctionId);\n    }\n\n    /**\n     * @dev Get user's auctions\n     */\n    function getUserAuctions(\n        address user\n    ) external view returns (uint256[] memory) {\n        return userAuctions[user];\n    }\n\n    /**\n     * @dev Get user's bids\n     */\n    function getUserBids(\n        address user\n    ) external view returns (uint256[] memory) {\n        return userBids[user];\n    }\n\n    /**\n     * @dev Get active auctions\n     */\n    function getActiveAuctions()\n        external\n        view\n        returns (uint256[] memory activeAuctions)\n    {\n        // Count active auctions\n        uint256 count = 0;\n        for (uint256 i = 0; i < _auctionIdCounter; i++) {\n            if (\n                auctions[i].status == AuctionStatus.ACTIVE &&\n                block.timestamp <= auctions[i].endTime\n            ) {\n                count++;\n            }\n        }\n\n        // Fill array\n        activeAuctions = new uint256[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _auctionIdCounter; i++) {\n            if (\n                auctions[i].status == AuctionStatus.ACTIVE &&\n                block.timestamp <= auctions[i].endTime\n            ) {\n                activeAuctions[index++] = i;\n            }\n        }\n    }\n\n    /**\n     * @dev Get auctions by type\n     */\n    function getAuctionsByType(\n        AuctionType auctionType\n    ) external view returns (uint256[] memory matchingAuctions) {\n        // Count matching auctions\n        uint256 count = 0;\n        for (uint256 i = 0; i < _auctionIdCounter; i++) {\n            if (auctions[i].auctionType == auctionType) {\n                count++;\n            }\n        }\n\n        // Fill array\n        matchingAuctions = new uint256[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _auctionIdCounter; i++) {\n            if (auctions[i].auctionType == auctionType) {\n                matchingAuctions[index++] = i;\n            }\n        }\n    }\n\n    /**\n     * @dev Get ending soon auctions (within next 24 hours)\n     */\n    function getEndingSoonAuctions()\n        external\n        view\n        returns (uint256[] memory endingSoon)\n    {\n        uint256 count = 0;\n        uint256 deadline = block.timestamp + 24 hours;\n\n        // Count ending soon auctions\n        for (uint256 i = 0; i < _auctionIdCounter; i++) {\n            if (\n                auctions[i].status == AuctionStatus.ACTIVE &&\n                auctions[i].endTime <= deadline &&\n                auctions[i].endTime > block.timestamp\n            ) {\n                count++;\n            }\n        }\n\n        // Fill array\n        endingSoon = new uint256[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _auctionIdCounter; i++) {\n            if (\n                auctions[i].status == AuctionStatus.ACTIVE &&\n                auctions[i].endTime <= deadline &&\n                auctions[i].endTime > block.timestamp\n            ) {\n                endingSoon[index++] = i;\n            }\n        }\n    }\n\n    /**\n     * @dev Check if user has bid on auction\n     */\n    function hasUserBid(\n        uint256 auctionId,\n        address user\n    ) external view validAuction(auctionId) returns (bool) {\n        return _hasUserBid(auctionId, user);\n    }\n\n    /**\n     * @dev Get total number of auctions\n     */\n    function totalAuctions() external view returns (uint256) {\n        return _auctionIdCounter;\n    }\n\n    // ============= INTERNAL FUNCTIONS =============\n\n    /**\n     * @dev Validate auction parameters based on type\n     */\n    function _validateAuctionParameters(\n        AuctionType auctionType,\n        uint256 startingPrice,\n        uint256 reservePrice,\n        uint256 buyNowPrice\n    ) internal pure {\n        if (auctionType == AuctionType.RESERVE) {\n            require(\n                reservePrice >= startingPrice,\n                \"Reserve price must be >= starting price\"\n            );\n        }\n\n        if (buyNowPrice > 0) {\n            require(\n                buyNowPrice > startingPrice,\n                \"Buy now price must be > starting price\"\n            );\n            if (reservePrice > 0) {\n                require(\n                    buyNowPrice >= reservePrice,\n                    \"Buy now price must be >= reserve price\"\n                );\n            }\n        }\n\n        if (auctionType == AuctionType.DUTCH) {\n            require(\n                reservePrice > 0 && reservePrice < startingPrice,\n                \"Dutch auction needs valid reserve < starting price\"\n            );\n        }\n    }\n\n    /**\n     * @dev Get current Dutch auction price\n     */\n    function _getDutchPrice(uint256 auctionId) internal view returns (uint256) {\n        Auction storage auction = auctions[auctionId];\n        require(\n            auction.auctionType == AuctionType.DUTCH,\n            \"Not a Dutch auction\"\n        );\n\n        if (block.timestamp >= auction.endTime) {\n            return auction.reservePrice;\n        }\n\n        uint256 timeElapsed = block.timestamp - auction.startTime;\n        uint256 totalDuration = auction.endTime - auction.startTime;\n\n        if (timeElapsed >= totalDuration) {\n            return auction.reservePrice;\n        }\n\n        uint256 priceDecrease = ((auction.startingPrice - auction.reservePrice) * timeElapsed) / totalDuration;\n        return auction.startingPrice - priceDecrease;\n    }\n\n    /**\n     * @dev Execute buy now purchase\n     */\n    function _executeBuyNow(\n        uint256 auctionId,\n        address buyer,\n        uint256 price\n    ) internal {\n        Auction storage auction = auctions[auctionId];\n\n        auction.highestBidder = buyer;\n        auction.highestBid = price;\n        auction.status = AuctionStatus.ENDED;\n        auction.totalBidders = 1;\n\n        // Add to user bids if not already present\n        if (!_hasUserBid(auctionId, buyer)) {\n            userBids[buyer].push(auctionId);\n        }\n\n        // Add bid to history\n        auctionBids[auctionId].push(\n            Bid({\n                bidder: buyer,\n                amount: price,\n                timestamp: block.timestamp,\n                isWinning: true,\n                isRefunded: false\n            })\n        );\n\n        emit BidPlaced(auctionId, buyer, price, true);\n    }\n\n    /**\n     * @dev Cancel auction and refund all bidders\n     */\n    function _cancelAuctionAndRefund(\n        uint256 auctionId,\n        string memory reason\n    ) internal {\n        Auction storage auction = auctions[auctionId];\n\n        // Update state first to prevent reentrancy\n        auction.status = AuctionStatus.CANCELLED;\n\n        // Return NFT to seller\n        IERC721(auction.nftContract).transferFrom(\n            address(this),\n            auction.seller,\n            auction.tokenId\n        );\n\n        // Refund all bidders\n        _refundAllBidders(auctionId);\n\n        emit AuctionCancelled(auctionId, reason);\n    }\n\n    /**\n     * @dev Refund a specific bid\n     */\n    function _refundBid(\n        uint256 auctionId,\n        address bidder,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            // Use call instead of transfer for better gas efficiency and to prevent reentrancy\n            (bool success, ) = payable(bidder).call{value: amount}(\"\");\n            require(success, \"Transfer failed\");\n            emit BidRefunded(auctionId, bidder, amount);\n        }\n    }\n\n    /**\n     * @dev Refund all bidders except winner\n     */\n    function _refundLosingBidders(uint256 auctionId) internal {\n        Bid[] storage bids = auctionBids[auctionId];\n        address winner = auctions[auctionId].highestBidder;\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (bids[i].bidder != winner && !bids[i].isRefunded) {\n                bids[i].isRefunded = true;\n                _refundBid(auctionId, bids[i].bidder, bids[i].amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Refund all bidders (for cancelled auctions)\n     */\n    function _refundAllBidders(uint256 auctionId) internal {\n        Bid[] storage bids = auctionBids[auctionId];\n\n        for (uint256 i = 0; i < bids.length; i++) {\n            if (!bids[i].isRefunded) {\n                bids[i].isRefunded = true;\n                _refundBid(auctionId, bids[i].bidder, bids[i].amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if user has placed a bid on auction\n     */\n    function _hasUserBid(\n        uint256 auctionId,\n        address user\n    ) internal view returns (bool) {\n        uint256[] memory userBidsArray = userBids[user];\n        for (uint256 i = 0; i < userBidsArray.length; i++) {\n            if (userBidsArray[i] == auctionId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Calculate platform and royalty fees\n     */\n    function _calculateFees(\n        address nftContract,\n        uint256 tokenId,\n        uint256 salePrice\n    )\n        internal\n        view\n        returns (\n            uint256 platformFee,\n            uint256 royaltyFee,\n            address royaltyRecipient\n        )\n    {\n        // Calculate platform fee\n        platformFee = (salePrice * platformFeePercentage) / 10000;\n\n        // Calculate royalty fee if contract supports EIP-2981\n        try IERC2981(nftContract).royaltyInfo(tokenId, salePrice) returns (\n            address recipient,\n            uint256 royaltyAmount\n        ) {\n            royaltyFee = royaltyAmount;\n            royaltyRecipient = recipient;\n        } catch {\n            royaltyFee = 0;\n            royaltyRecipient = address(0);\n        }\n\n        // Ensure fees don't exceed sale price\n        require(\n            platformFee + royaltyFee <= salePrice,\n            \"Fees exceed sale price\"\n        );\n    }\n\n    // ============= ADMIN FUNCTIONS =============\n\n    /**\n     * @dev Update platform fee percentage\n     */\n    function updatePlatformFee(\n        uint256 newFeePercentage\n    ) external onlyAccessControlRole(accessControl.PRICE_MANAGER_ROLE()) {\n        require(newFeePercentage <= 1000, \"Fee too high\"); // Max 10%\n        platformFeePercentage = newFeePercentage;\n    }\n\n    /**\n     * @dev Update minimum bid increment\n     */\n    function updateMinimumBidIncrement(\n        uint256 newIncrement\n    ) external onlyAccessControlRole(accessControl.PRICE_MANAGER_ROLE()) {\n        require(newIncrement <= 2000, \"Increment too high\"); // Max 20%\n        minimumBidIncrement = newIncrement;\n    }\n\n    /**\n     * @dev Withdraw platform fees\n     */\n    function withdrawPlatformFees(\n        address to,\n        uint256 amount\n    )\n        external\n        onlyAccessControlRole(accessControl.WITHDRAWER_ROLE())\n        nonReentrant\n    {\n        require(to != address(0), \"Invalid recipient\");\n        require(to != address(this), \"Cannot withdraw to self\");\n        require(to.code.length == 0, \"Cannot withdraw to contract\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(amount <= address(this).balance, \"Insufficient balance\");\n\n        // Use call instead of transfer for better gas efficiency and to prevent reentrancy\n        (bool success, ) = payable(to).call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    /**\n     * @dev Emergency pause\n     */\n    function pause()\n        external\n        onlyAccessControlRole(accessControl.PAUSER_ROLE())\n    {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause\n     */\n    function unpause()\n        external\n        onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE())\n    {\n        _unpause();\n    }\n\n    // ============= STATISTICS FUNCTIONS =============\n\n    /**\n     * @dev Get auction statistics\n     */\n    function getAuctionStats()\n        external\n        view\n        returns (\n            uint256 totalAuctionsCount,\n            uint256 activeAuctionsCount,\n            uint256 settledAuctionsCount,\n            uint256 cancelledAuctionsCount,\n            uint256 totalVolume\n        )\n    {\n        totalAuctionsCount = _auctionIdCounter;\n\n        for (uint256 i = 0; i < _auctionIdCounter; i++) {\n            AuctionStatus status = auctions[i].status;\n\n            if (status == AuctionStatus.ACTIVE) {\n                activeAuctionsCount++;\n            } else if (status == AuctionStatus.SETTLED) {\n                settledAuctionsCount++;\n                totalVolume += auctions[i].highestBid;\n            } else if (status == AuctionStatus.CANCELLED) {\n                cancelledAuctionsCount++;\n            }\n        }\n    }\n\n    /**\n     * @dev Get auction type distribution\n     */\n    function getAuctionTypeDistribution()\n        external\n        view\n        returns (\n            uint256 englishCount,\n            uint256 dutchCount,\n            uint256 sealedBidCount,\n            uint256 reserveCount\n        )\n    {\n        for (uint256 i = 0; i < _auctionIdCounter; i++) {\n            AuctionType auctionType = auctions[i].auctionType;\n\n            if (auctionType == AuctionType.ENGLISH) {\n                englishCount++;\n            } else if (auctionType == AuctionType.DUTCH) {\n                dutchCount++;\n            } else if (auctionType == AuctionType.SEALED_BID) {\n                sealedBidCount++;\n            } else if (auctionType == AuctionType.RESERVE) {\n                reserveCount++;\n            }\n        }\n    }\n\n    // ============= RECEIVE FUNCTION =============\n\n    /**\n     * @dev Receive function to handle direct ETH transfers\n     */\n    receive() external payable {\n        // Accept ETH for fee collection\n    }\n\n    /**\n     * @dev Fallback function\n     */\n    fallback() external payable {\n        revert(\"Function not found\");\n    }\n}\n"
    },
    "contracts/MooveCustomization.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport \"./interfaces/IMooveCustomization.sol\";\r\n\r\n// ============= INTERFACES =============\r\n\r\ninterface IMooveNFT {\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    function updateTokenMetadata(uint256 tokenId) external;\r\n}\r\n\r\n/**\r\n * @title MooveCustomization\r\n * @dev Implementation contract for virtual vehicle NFT customizations\r\n * @notice All customizations are purely virtual and affect only NFT metadata and visual representation\r\n */\r\ncontract MooveCustomization is IMooveCustomization, AccessControl, ReentrancyGuard, Pausable {\r\n    // ============= CONSTANTS =============\r\n\r\n    bytes32 public constant CUSTOMIZATION_ADMIN_ROLE =\r\n        keccak256(\"CUSTOMIZATION_ADMIN_ROLE\");\r\n    bytes32 public constant PRICE_MANAGER_ROLE =\r\n        keccak256(\"PRICE_MANAGER_ROLE\");\r\n\r\n    uint256 public constant MAX_PERFORMANCE_BONUS = 100;\r\n    uint256 public constant MAX_CUSTOMIZATIONS_PER_VEHICLE = 50;\r\n\r\n    // ============= STATE VARIABLES =============\r\n\r\n    /// @dev Reference to the MooveNFT contract\r\n    IMooveNFT public immutable mooveNFT;\r\n\r\n    /// @dev Counter for customization IDs\r\n    uint256 private _customizationIdCounter;\r\n\r\n    /// @dev Mapping from customization ID to Customization struct\r\n    mapping(uint256 => Customization) private _customizations;\r\n\r\n    /// @dev Mapping from token ID to array of applied customization IDs\r\n    mapping(uint256 => uint256[]) private _vehicleCustomizations;\r\n\r\n    /// @dev Mapping from token ID to customization ID to check if applied\r\n    mapping(uint256 => mapping(uint256 => bool))\r\n        private _isCustomizationApplied;\r\n\r\n    /// @dev Mapping from token ID to performance upgrades\r\n    mapping(uint256 => PerformanceUpgrade) private _vehiclePerformance;\r\n\r\n    /// @dev Mapping from token ID to aesthetic customizations\r\n    mapping(uint256 => AestheticCustomization) private _vehicleAesthetics;\r\n\r\n    /// @dev Arrays to track customizations by type for efficient querying\r\n    mapping(CustomizationType => uint256[]) private _customizationsByType;\r\n\r\n    /// @dev Mapping to track active customizations\r\n    mapping(uint256 => bool) private _activeCustomizations;\r\n\r\n    // ============= MODIFIERS =============\r\n\r\n    /**\r\n     * @dev Modifier to check if the caller owns the vehicle token\r\n     */\r\n    modifier onlyVehicleOwner(uint256 tokenId) {\r\n        require(mooveNFT.ownerOf(tokenId) == msg.sender, \"Not vehicle owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to check if customization exists and is active\r\n     */\r\n    modifier customizationExists(uint256 customizationId) {\r\n        require(\r\n            _customizations[customizationId].id != 0,\r\n            \"Customization does not exist\"\r\n        );\r\n        require(\r\n            _activeCustomizations[customizationId],\r\n            \"Customization not active\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to check if vehicle exists\r\n     */\r\n    modifier vehicleExists(uint256 tokenId) {\r\n        require(\r\n            mooveNFT.ownerOf(tokenId) != address(0),\r\n            \"Vehicle does not exist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ============= CONSTRUCTOR =============\r\n\r\n    /**\r\n     * @dev Constructor sets the MooveNFT contract address and initial roles\r\n     * @param _mooveNFT Address of the MooveNFT contract\r\n     * @param _admin Address to be granted admin roles\r\n     */\r\n    constructor(address _mooveNFT, address _admin) {\r\n        require(_mooveNFT != address(0), \"Invalid MooveNFT address\");\r\n        require(_admin != address(0), \"Invalid admin address\");\r\n\r\n        // Initialize immutable variable\r\n        mooveNFT = IMooveNFT(_mooveNFT);\r\n\r\n        // Set up roles\r\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\r\n        _grantRole(CUSTOMIZATION_ADMIN_ROLE, _admin);\r\n        _grantRole(PRICE_MANAGER_ROLE, _admin);\r\n\r\n        _customizationIdCounter = 1; // Start from 1, 0 is reserved for \"not exists\"\r\n    }\r\n\r\n    // ============= CUSTOMIZATION MANAGEMENT =============\r\n\r\n    /**\r\n     * @dev Create a new customization option\r\n     */\r\n    function createCustomization(\r\n        string calldata name, // Optimized: changed from memory to calldata\r\n        string calldata description, // Optimized: changed from memory to calldata\r\n        CustomizationType custType,\r\n        uint256 price,\r\n        string calldata imageURI, // Optimized: changed from memory to calldata\r\n        uint256 maxSupply\r\n    )\r\n        external\r\n        override\r\n        onlyRole(CUSTOMIZATION_ADMIN_ROLE)\r\n        returns (uint256 customizationId)\r\n    {\r\n        require(bytes(name).length > 0, \"Name cannot be empty\");\r\n        require(bytes(description).length > 0, \"Description cannot be empty\");\r\n        require(bytes(imageURI).length > 0, \"Image URI cannot be empty\");\r\n\r\n        customizationId = _customizationIdCounter++;\r\n\r\n        _customizations[customizationId] = Customization({\r\n            id: customizationId,\r\n            name: name,\r\n            description: description,\r\n            custType: custType,\r\n            price: price,\r\n            imageURI: imageURI,\r\n            isActive: true,\r\n            maxSupply: uint32(maxSupply), // Optimized: packed\r\n            currentSupply: 0\r\n        });\r\n\r\n        _customizationsByType[custType].push(customizationId);\r\n        _activeCustomizations[customizationId] = true;\r\n\r\n        emit CustomizationCreated(customizationId, name, custType, price);\r\n    }\r\n\r\n    /**\r\n     * @dev Apply customization to NFT\r\n     * @param tokenId Token ID to customize\r\n     * @param customizationId Customization ID to apply\r\n     */\r\n    function applyCustomization(\r\n        uint256 tokenId,\r\n        uint256 customizationId\r\n    ) external payable override nonReentrant {\r\n        require(\r\n            mooveNFT.ownerOf(tokenId) == msg.sender,\r\n            \"Not token owner\"\r\n        );\r\n        require(\r\n            _customizations[customizationId].id != 0,\r\n            \"Customization does not exist\"\r\n        );\r\n\r\n        Customization storage customization = _customizations[customizationId];\r\n        require(\r\n            customization.isActive,\r\n            \"Customization not active\"\r\n        );\r\n        require(\r\n            msg.value >= customization.price,\r\n            \"Insufficient payment\"\r\n        );\r\n\r\n        // Update state first to prevent reentrancy\r\n        _vehicleCustomizations[tokenId].push(customizationId);\r\n        _isCustomizationApplied[tokenId][customizationId] = true;\r\n        unchecked {\r\n            customization.currentSupply++; // Optimized: unchecked increment\r\n        }\r\n\r\n        // Handle specific customization types\r\n        if (customization.custType == CustomizationType.PERFORMANCE) {\r\n            _applyPerformanceBonus(tokenId, customizationId);\r\n        } else if (customization.custType == CustomizationType.AESTHETIC) {\r\n            _applyAestheticChange(tokenId, customizationId);\r\n        }\r\n\r\n        // Refund excess payment\r\n        if (msg.value > customization.price) {\r\n            (bool refundSuccess, ) = payable(msg.sender).call{value: msg.value - customization.price}(\"\");\r\n            require(refundSuccess, \"Refund failed\");\r\n        }\r\n\r\n        emit CustomizationApplied(\r\n            tokenId,\r\n            customizationId,\r\n            msg.sender,\r\n            customization.price\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a customization from a vehicle NFT\r\n     */\r\n    function removeCustomization(\r\n        uint256 tokenId,\r\n        uint256 customizationId\r\n    ) external override onlyVehicleOwner(tokenId) returns (bool success) {\r\n        require(\r\n            _isCustomizationApplied[tokenId][customizationId],\r\n            \"Customization not applied\"\r\n        );\r\n\r\n        // Remove from applied customizations\r\n        _isCustomizationApplied[tokenId][customizationId] = false;\r\n\r\n        // Remove from vehicle customizations array\r\n        uint256[] storage vehicleCustoms = _vehicleCustomizations[tokenId];\r\n        uint256 length = vehicleCustoms.length;\r\n        for (uint256 i = 0; i < length;) { // Optimized: use unchecked increment\r\n            if (vehicleCustoms[i] == customizationId) {\r\n                vehicleCustoms[i] = vehicleCustoms[length - 1];\r\n                vehicleCustoms.pop();\r\n                break;\r\n            }\r\n            unchecked { i++; } // Optimized: unchecked increment\r\n        }\r\n\r\n        // Decrease supply\r\n        _customizations[customizationId].currentSupply--;\r\n\r\n        // Handle specific customization types\r\n        CustomizationType custType = _customizations[customizationId].custType;\r\n        if (custType == CustomizationType.PERFORMANCE) {\r\n            _removePerformanceBonus(tokenId, customizationId);\r\n        } else if (custType == CustomizationType.AESTHETIC) {\r\n            _removeAestheticChange(tokenId, customizationId);\r\n        }\r\n\r\n        emit CustomizationRemoved(tokenId, customizationId, msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Apply performance upgrade to a vehicle NFT\r\n     */\r\n    function applyPerformanceUpgrade(\r\n        uint256 tokenId,\r\n        PerformanceUpgrade calldata upgrade // Optimized: changed from memory to calldata\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        onlyVehicleOwner(tokenId)\r\n        whenNotPaused\r\n        returns (bool success)\r\n    {\r\n        require(\r\n            _isValidPerformanceUpgrade(upgrade),\r\n            \"Invalid performance upgrade\"\r\n        );\r\n\r\n        // Calculate cost based on bonus amounts\r\n        uint256 cost = _calculatePerformanceCost(upgrade);\r\n        require(msg.value >= cost, \"Insufficient payment\");\r\n\r\n        // Apply the upgrade\r\n        PerformanceUpgrade storage current = _vehiclePerformance[tokenId];\r\n        current.speedBonus = _addBonusCapped(\r\n            current.speedBonus,\r\n            upgrade.speedBonus\r\n        );\r\n        current.accelerationBonus = _addBonusCapped(\r\n            current.accelerationBonus,\r\n            upgrade.accelerationBonus\r\n        );\r\n        current.handlingBonus = _addBonusCapped(\r\n            current.handlingBonus,\r\n            upgrade.handlingBonus\r\n        );\r\n        current.durabilityBonus = _addBonusCapped(\r\n            current.durabilityBonus,\r\n            upgrade.durabilityBonus\r\n        );\r\n\r\n        // Refund excess payment\r\n        if (msg.value > cost) {\r\n            payable(msg.sender).transfer(msg.value - cost);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Apply aesthetic customization to a vehicle NFT\r\n     */\r\n    function applyAestheticCustomization(\r\n        uint256 tokenId,\r\n        AestheticCustomization calldata aesthetic // Optimized: changed from memory to calldata\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        onlyVehicleOwner(tokenId)\r\n        whenNotPaused\r\n        returns (bool success)\r\n    {\r\n        require(\r\n            _isValidAestheticCustomization(aesthetic),\r\n            \"Invalid aesthetic customization\"\r\n        );\r\n\r\n        // Calculate cost\r\n        uint256 cost = _calculateAestheticCost(aesthetic);\r\n        require(msg.value >= cost, \"Insufficient payment\");\r\n\r\n        // Apply the aesthetic changes\r\n        _vehicleAesthetics[tokenId] = aesthetic;\r\n\r\n        // Refund excess payment\r\n        if (msg.value > cost) {\r\n            payable(msg.sender).transfer(msg.value - cost);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // ============= QUERY FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Get customization details by ID\r\n     */\r\n    function getCustomization(\r\n        uint256 customizationId\r\n    ) external view override returns (Customization memory customization) {\r\n        require(\r\n            _customizations[customizationId].id != 0,\r\n            \"Customization does not exist\"\r\n        );\r\n        return _customizations[customizationId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get all active customizations\r\n     */\r\n    function getActiveCustomizations()\r\n        external\r\n        view\r\n        override\r\n        returns (Customization[] memory customizations)\r\n    {\r\n        // Count active customizations\r\n        uint256 activeCount = 0;\r\n        for (uint256 i = 1; i < _customizationIdCounter; i++) {\r\n            if (_activeCustomizations[i]) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        // Create array and populate\r\n        customizations = new Customization[](activeCount);\r\n        uint256 index = 0;\r\n        for (uint256 i = 1; i < _customizationIdCounter; i++) {\r\n            if (_activeCustomizations[i]) {\r\n                customizations[index] = _customizations[i];\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get customizations by type\r\n     */\r\n    function getCustomizationsByType(\r\n        CustomizationType custType\r\n    ) external view override returns (Customization[] memory customizations) {\r\n        uint256[] storage ids = _customizationsByType[custType];\r\n        uint256 activeCount = 0;\r\n\r\n        // Count active customizations of this type\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            if (_activeCustomizations[ids[i]]) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        // Create array and populate\r\n        customizations = new Customization[](activeCount);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            if (_activeCustomizations[ids[i]]) {\r\n                customizations[index] = _customizations[ids[i]];\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get all customizations applied to a vehicle\r\n     */\r\n    function getVehicleCustomizations(\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        view\r\n        override\r\n        vehicleExists(tokenId)\r\n        returns (uint256[] memory customizationIds)\r\n    {\r\n        return _vehicleCustomizations[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a customization is applied to a vehicle\r\n     */\r\n    function isCustomizationApplied(\r\n        uint256 tokenId,\r\n        uint256 customizationId\r\n    ) external view override returns (bool isApplied) {\r\n        return _isCustomizationApplied[tokenId][customizationId];\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate total cost for multiple customizations\r\n     */\r\n    function calculateTotalCost(\r\n        uint256[] memory customizationIds\r\n    ) external view override returns (uint256 totalCost) {\r\n        for (uint256 i = 0; i < customizationIds.length; i++) {\r\n            require(\r\n                _customizations[customizationIds[i]].id != 0,\r\n                \"Invalid customization ID\"\r\n            );\r\n            totalCost += _customizations[customizationIds[i]].price;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get vehicle performance stats\r\n     */\r\n    function getVehiclePerformance(\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        view\r\n        override\r\n        vehicleExists(tokenId)\r\n        returns (PerformanceUpgrade memory upgrade)\r\n    {\r\n        return _vehiclePerformance[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get vehicle aesthetic customizations\r\n     */\r\n    function getVehicleAesthetics(\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        view\r\n        override\r\n        vehicleExists(tokenId)\r\n        returns (AestheticCustomization memory aesthetic)\r\n    {\r\n        return _vehicleAesthetics[tokenId];\r\n    }\r\n\r\n    // ============= ADMIN FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Update customization price\r\n     */\r\n    function updateCustomizationPrice(\r\n        uint256 customizationId,\r\n        uint256 newPrice\r\n    ) external override onlyRole(PRICE_MANAGER_ROLE) {\r\n        require(\r\n            _customizations[customizationId].id != 0,\r\n            \"Customization does not exist\"\r\n        );\r\n\r\n        uint256 oldPrice = _customizations[customizationId].price;\r\n        _customizations[customizationId].price = newPrice;\r\n\r\n        emit CustomizationPriceUpdated(customizationId, oldPrice, newPrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Set customization active status\r\n     */\r\n    function setCustomizationActive(\r\n        uint256 customizationId,\r\n        bool isActive\r\n    ) external override onlyRole(CUSTOMIZATION_ADMIN_ROLE) {\r\n        require(\r\n            _customizations[customizationId].id != 0,\r\n            \"Customization does not exist\"\r\n        );\r\n\r\n        _customizations[customizationId].isActive = isActive;\r\n        _activeCustomizations[customizationId] = isActive;\r\n    }\r\n\r\n    /**\r\n     * @dev Update customization image URI\r\n     */\r\n    function updateCustomizationImage(\r\n        uint256 customizationId,\r\n        string calldata newImageURI // Optimized: changed from memory to calldata\r\n    ) external override onlyRole(CUSTOMIZATION_ADMIN_ROLE) {\r\n        require(\r\n            _customizations[customizationId].id != 0,\r\n            \"Customization does not exist\"\r\n        );\r\n        require(bytes(newImageURI).length > 0, \"Image URI cannot be empty\");\r\n\r\n        _customizations[customizationId].imageURI = newImageURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw contract balance\r\n     */\r\n    function withdraw(\r\n        address payable to,\r\n        uint256 amount\r\n    ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        require(to != address(0), \"Invalid recipient address\");\r\n        require(to != address(this), \"Cannot withdraw to self\");\r\n        require(to.code.length == 0, \"Cannot withdraw to contract\");\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(\r\n            amount <= address(this).balance,\r\n            \"Insufficient contract balance\"\r\n        );\r\n\r\n        // Use call instead of transfer for better gas efficiency and to prevent reentrancy\r\n        (bool success, ) = to.call{value: amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency pause function\r\n     */\r\n    function pause() external override onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause function\r\n     */\r\n    function unpause() external override onlyRole(DEFAULT_ADMIN_ROLE) {\r\n        _unpause();\r\n    }\r\n\r\n    // ============= INTERNAL FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Apply virtual performance bonus from a specific customization\r\n     */\r\n    function _applyPerformanceBonus(\r\n        uint256 tokenId,\r\n        uint256 /* customizationId */\r\n    ) internal {\r\n        PerformanceUpgrade storage performance = _vehiclePerformance[tokenId];\r\n\r\n        // Each performance customization gives +5 to virtual stats\r\n        performance.speedBonus = _addBonusCapped(performance.speedBonus, 5);\r\n        performance.accelerationBonus = _addBonusCapped(\r\n            performance.accelerationBonus,\r\n            5\r\n        );\r\n        performance.handlingBonus = _addBonusCapped(\r\n            performance.handlingBonus,\r\n            5\r\n        );\r\n        performance.durabilityBonus = _addBonusCapped(\r\n            performance.durabilityBonus,\r\n            5\r\n        );\r\n\r\n        _updateNFTMetadata(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove performance bonus from a specific customization\r\n     */\r\n    function _removePerformanceBonus(\r\n        uint256 tokenId,\r\n        uint256 /* customizationId */\r\n    ) internal {\r\n        PerformanceUpgrade storage performance = _vehiclePerformance[tokenId];\r\n\r\n        performance.speedBonus = performance.speedBonus >= 5\r\n            ? performance.speedBonus - 5\r\n            : 0;\r\n        performance.accelerationBonus = performance.accelerationBonus >= 5\r\n            ? performance.accelerationBonus - 5\r\n            : 0;\r\n        performance.handlingBonus = performance.handlingBonus >= 5\r\n            ? performance.handlingBonus - 5\r\n            : 0;\r\n        performance.durabilityBonus = performance.durabilityBonus >= 5\r\n            ? performance.durabilityBonus - 5\r\n            : 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Apply virtual aesthetic changes\r\n     */\r\n    function _applyAestheticChange(\r\n        uint256 tokenId,\r\n        uint256 /* customizationId */\r\n    ) internal {\r\n        _updateNFTMetadata(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove virtual aesthetic changes\r\n     */\r\n    function _removeAestheticChange(\r\n        uint256 tokenId,\r\n        uint256 /* customizationId */\r\n    ) internal {\r\n        _updateNFTMetadata(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Update NFT metadata to reflect applied customizations\r\n     */\r\n    function _updateNFTMetadata(uint256 tokenId) internal {\r\n        try mooveNFT.updateTokenMetadata(tokenId) {\r\n            // Metadata updated successfully\r\n        } catch {\r\n            // Handle update failure gracefully\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add bonus with cap at MAX_PERFORMANCE_BONUS\r\n     */\r\n    function _addBonusCapped(\r\n        uint8 current,\r\n        uint8 addition\r\n    ) internal pure returns (uint8) {\r\n        uint256 sum = uint256(current) + uint256(addition);\r\n        return\r\n            sum > MAX_PERFORMANCE_BONUS\r\n                ? uint8(MAX_PERFORMANCE_BONUS)\r\n                : uint8(sum);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate performance upgrade parameters\r\n     */\r\n    function _isValidPerformanceUpgrade(\r\n        PerformanceUpgrade memory upgrade\r\n    ) internal pure returns (bool) {\r\n        return\r\n            upgrade.speedBonus <= MAX_PERFORMANCE_BONUS &&\r\n            upgrade.accelerationBonus <= MAX_PERFORMANCE_BONUS &&\r\n            upgrade.handlingBonus <= MAX_PERFORMANCE_BONUS &&\r\n            upgrade.durabilityBonus <= MAX_PERFORMANCE_BONUS;\r\n    }\r\n\r\n    /**\r\n     * @dev Validate aesthetic customization parameters\r\n     */\r\n    function _isValidAestheticCustomization(\r\n        AestheticCustomization memory aesthetic\r\n    ) internal pure returns (bool) {\r\n        return\r\n            bytes(aesthetic.colorCode).length > 0 ||\r\n            aesthetic.skinId > 0 ||\r\n            aesthetic.decalIds.length > 0 ||\r\n            bytes(aesthetic.customURI).length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate cost for performance upgrade\r\n     */\r\n    function _calculatePerformanceCost(\r\n        PerformanceUpgrade memory upgrade\r\n    ) internal pure returns (uint256) {\r\n        uint256 totalBonus = uint256(upgrade.speedBonus) +\r\n            uint256(upgrade.accelerationBonus) +\r\n            uint256(upgrade.handlingBonus) +\r\n            uint256(upgrade.durabilityBonus);\r\n        return totalBonus * 0.001 ether;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate cost for aesthetic customization\r\n     */\r\n    function _calculateAestheticCost(\r\n        AestheticCustomization memory aesthetic\r\n    ) internal pure returns (uint256) {\r\n        uint256 cost = 0;\r\n\r\n        if (bytes(aesthetic.colorCode).length > 0) cost += 0.01 ether;\r\n        if (aesthetic.skinId > 0) cost += 0.02 ether;\r\n        if (aesthetic.decalIds.length > 0)\r\n            cost += aesthetic.decalIds.length * 0.005 ether;\r\n        if (bytes(aesthetic.customURI).length > 0) cost += 0.05 ether;\r\n\r\n        return cost;\r\n    }\r\n\r\n    /**\r\n     * @dev Receive function to accept ETH payments\r\n     */\r\n    receive() external payable {\r\n        // Contract can receive ETH\r\n    }\r\n} "
    },
    "contracts/MooveNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"./MooveAccessControl.sol\";\n\n/**\n * @title MooveNFT\n * @dev NFT contract for customizable stickers - OPTIMIZED for size reduction\n * @notice These NFTs represent customizable stickers created by admins for auction system\n */\ncontract MooveNFT is\n    ERC721,\n    ERC721URIStorage,\n    ERC721Royalty,\n    ReentrancyGuard,\n    Pausable\n{\n    // ============= STATE VARIABLES =============\n\n    /// @dev Reference to access control contract\n    MooveAccessControl public immutable accessControl;\n\n    /// @dev Counter for token IDs\n    uint256 private _tokenIdCounter;\n\n    /// @dev Mapping from token ID to sticker details\n    mapping(uint256 => StickerNFT) public stickers;\n\n    /// @dev Mapping from token ID to customization history\n    mapping(uint256 => CustomizationHistory[]) public customizationHistory;\n\n    /// @dev Mapping to track if sticker is customizable\n    mapping(uint256 => bool) public isCustomizable;\n\n    /// @dev Mapping from creator to their created stickers\n    mapping(address => uint256[]) public creatorStickers;\n\n    /// @dev Default royalty percentage (500 = 5%) - OPTIMIZED: removed separate variable\n    uint256 private constant DEFAULT_ROYALTY = 500;\n\n    // ============= STRUCTS =============\n\n    struct StickerNFT {\n        string name;\n        string description;\n        StickerCategory category;\n        StickerRarity rarity;\n        address creator;\n        uint32 creationDate; // Packed: reduced from uint256\n        bool isLimitedEdition;\n        uint32 editionSize; // Packed: reduced from uint256\n        uint32 editionNumber; // Packed: reduced from uint256\n        CustomizationOptions customization;\n    }\n\n    struct CustomizationOptions {\n        bool allowColorChange;\n        bool allowTextChange;\n        bool allowSizeChange;\n        bool allowEffectsChange;\n        string[] availableColors;\n        uint256 maxTextLength;\n    }\n\n    struct CustomizationHistory {\n        address customizer;\n        uint32 timestamp; // Packed: reduced from uint256\n        string changeDescription;\n        string previousState;\n        string newState;\n    }\n\n    enum StickerCategory {\n        VEHICLE_DECORATION,\n        BRAND_LOGO,\n        ARTISTIC,\n        COMMEMORATIVE,\n        SPECIAL_EVENT,\n        COMMUNITY_BADGE\n    }\n\n    enum StickerRarity {\n        COMMON,\n        UNCOMMON,\n        RARE,\n        EPIC,\n        LEGENDARY,\n        MYTHIC\n    }\n\n    // ============= EVENTS =============\n\n    event StickerMinted(\n        uint256 indexed tokenId,\n        address indexed creator,\n        address indexed owner,\n        string name,\n        StickerCategory category,\n        StickerRarity rarity,\n        bool isLimitedEdition\n    );\n\n    event StickerCustomized(\n        uint256 indexed tokenId,\n        address indexed customizer,\n        string changeDescription,\n        string newState\n    );\n\n    event CustomizationOptionsUpdated(\n        uint256 indexed tokenId,\n        CustomizationOptions newOptions\n    );\n\n    event RoyaltyUpdated(\n        uint256 indexed tokenId,\n        address indexed recipient,\n        uint96 feeNumerator\n    );\n\n    event NFTMinted(\n        uint256 indexed tokenId,\n        address indexed creator,\n        address indexed owner\n    );\n\n    // ============= MODIFIERS =============\n\n    modifier onlyAccessControlRole(bytes32 role) {\n        require(accessControl.hasRole(role, msg.sender), \"Access denied\");\n        _;\n    }\n\n    modifier onlyValidToken(uint256 tokenId) {\n        require(_exists(tokenId), \"Token does not exist\");\n        _;\n    }\n\n    /**\n     * @dev Check if token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    modifier onlyOwnerOrApproved(uint256 tokenId) {\n        require(\n            ownerOf(tokenId) == msg.sender ||\n                getApproved(tokenId) == msg.sender ||\n                isApprovedForAll(ownerOf(tokenId), msg.sender),\n            \"Not owner or approved\"\n        );\n        _;\n    }\n\n    modifier onlyCustomizable(uint256 tokenId) {\n        require(isCustomizable[tokenId], \"Sticker not customizable\");\n        _;\n    }\n\n    // ============= CONSTRUCTOR =============\n\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _accessControl\n    ) ERC721(tokenName, tokenSymbol) {\n        require(_accessControl != address(0), \"Invalid access control address\");\n        accessControl = MooveAccessControl(_accessControl);\n\n        // Set default royalty to contract creator initially\n        _setDefaultRoyalty(msg.sender, uint96(DEFAULT_ROYALTY));\n    }\n\n    // ============= MINTING FUNCTIONS =============\n\n    /**\n     * @dev Mint a new sticker NFT - OPTIMIZED for size\n     */\n    function mintStickerNFT(\n        address to,\n        string calldata stickerName,\n        string calldata metadataURI,\n        StickerCategory category,\n        StickerRarity rarity,\n        bool isLimitedEdition,\n        uint256 editionSize,\n        CustomizationOptions calldata customizationOptions,\n        string calldata editionName,\n        address royaltyRecipient,\n        uint96 royaltyPercentage\n    ) external onlyAccessControlRole(keccak256(\"CUSTOMIZATION_ADMIN_ROLE\")) {\n        _mintStickerInternal(\n            to,\n            stickerName,\n            metadataURI,\n            category,\n            rarity,\n            isLimitedEdition,\n            editionSize,\n            customizationOptions,\n            editionName,\n            royaltyRecipient,\n            royaltyPercentage\n        );\n    }\n\n    /**\n     * @dev Mint a basic NFT - OPTIMIZED: simplified\n     */\n    function mintNFT(\n        address to,\n        string calldata metadataURI // OPTIMIZED: changed to calldata\n    ) external onlyAccessControlRole(keccak256(\"MINTER_ROLE\")) returns (uint256 tokenId) {\n        tokenId = _tokenIdCounter++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, metadataURI);\n        emit NFTMinted(tokenId, msg.sender, to);\n        return tokenId;\n    }\n\n    /**\n     * @dev Batch mint stickers for limited editions - OPTIMIZED\n     */\n    function batchMintLimitedEdition(\n        address[] calldata recipients,\n        string calldata editionName,\n        string calldata editionDescription,\n        StickerCategory category,\n        StickerRarity rarity,\n        uint256 editionSize,\n        CustomizationOptions calldata customizationOptions,\n        string[] calldata tokenURIs,\n        address royaltyRecipient,\n        uint96 royaltyPercentage\n    )\n        external\n        onlyAccessControlRole(keccak256(\"CUSTOMIZATION_ADMIN_ROLE\"))\n        nonReentrant\n    {\n        require(recipients.length == tokenURIs.length, \"Array length mismatch\");\n        require(recipients.length <= editionSize, \"Exceeds edition size\");\n\n        uint256 length = recipients.length;\n        for (uint256 i = 0; i < length;) {\n            _mintStickerInternal(\n                recipients[i],\n                editionName,\n                editionDescription,\n                category,\n                rarity,\n                true,\n                editionSize,\n                customizationOptions,\n                tokenURIs[i],\n                royaltyRecipient,\n                royaltyPercentage\n            );\n            unchecked { i++; }\n        }\n    }\n\n    /**\n     * @dev Internal mint function - OPTIMIZED for size reduction\n     */\n    function _mintStickerInternal(\n        address to,\n        string calldata stickerName,\n        string calldata stickerDescription,\n        StickerCategory category,\n        StickerRarity rarity,\n        bool isLimitedEdition,\n        uint256 editionSize,\n        CustomizationOptions calldata customizationOptions,\n        string calldata _tokenURI,\n        address royaltyRecipient,\n        uint96 royaltyPercentage\n    ) internal {\n        require(to != address(0), \"Invalid recipient address\");\n        require(bytes(stickerName).length > 0, \"Name required\");\n        require(bytes(_tokenURI).length > 0, \"Token URI required\");\n\n        uint256 tokenId = _tokenIdCounter++;\n\n        // OPTIMIZED: Batch storage operations\n        stickers[tokenId] = StickerNFT({\n            name: stickerName,\n            description: stickerDescription,\n            category: category,\n            rarity: rarity,\n            creator: msg.sender,\n            creationDate: uint32(block.timestamp),\n            isLimitedEdition: isLimitedEdition,\n            editionSize: uint32(editionSize),\n            editionNumber: uint32(isLimitedEdition ? _getNextEditionNumber(msg.sender, stickerName, editionSize) : 0),\n            customization: customizationOptions\n        });\n\n        // OPTIMIZED: Batch boolean and array operations\n        isCustomizable[tokenId] = _hasCustomizationOptions(customizationOptions);\n        creatorStickers[msg.sender].push(tokenId);\n\n        // OPTIMIZED: Conditional royalty setting\n        if (royaltyRecipient != address(0) && royaltyPercentage > 0) {\n            _setTokenRoyalty(tokenId, royaltyRecipient, royaltyPercentage);\n        }\n\n        // OPTIMIZED: Batch mint operations\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, _tokenURI);\n\n        emit StickerMinted(tokenId, msg.sender, to, stickerName, category, rarity, isLimitedEdition);\n    }\n\n    // ============= CUSTOMIZATION FUNCTIONS =============\n\n    /**\n     * @dev Customize a sticker - OPTIMIZED\n     */\n    function customizeSticker(\n        uint256 tokenId,\n        string calldata changeDescription,\n        string calldata newState,\n        string calldata newTokenURI\n    ) external onlyValidToken(tokenId) onlyOwnerOrApproved(tokenId) onlyCustomizable(tokenId) nonReentrant {\n        // OPTIMIZED: Batch storage operations\n        customizationHistory[tokenId].push(CustomizationHistory({\n            customizer: msg.sender,\n            timestamp: uint32(block.timestamp),\n            changeDescription: changeDescription,\n            previousState: \"\",\n            newState: newState\n        }));\n\n        _setTokenURI(tokenId, newTokenURI);\n\n        emit StickerCustomized(tokenId, msg.sender, changeDescription, newState);\n    }\n\n    /**\n     * @dev Update customization options - OPTIMIZED\n     */\n    function updateCustomizationOptions(\n        uint256 tokenId,\n        CustomizationOptions calldata newOptions\n    ) external onlyValidToken(tokenId) onlyAccessControlRole(keccak256(\"CUSTOMIZATION_ADMIN_ROLE\")) {\n        stickers[tokenId].customization = newOptions;\n        isCustomizable[tokenId] = _hasCustomizationOptions(newOptions);\n        emit CustomizationOptionsUpdated(tokenId, newOptions);\n    }\n\n    // ============= ROYALTY FUNCTIONS =============\n\n    /**\n     * @dev Update token royalty - OPTIMIZED\n     */\n    function updateTokenRoyalty(\n        uint256 tokenId,\n        address recipient,\n        uint96 feeNumerator\n    ) external onlyValidToken(tokenId) {\n        require(\n            msg.sender == stickers[tokenId].creator || accessControl.hasRole(keccak256(\"CUSTOMIZATION_ADMIN_ROLE\"), msg.sender),\n            \"Not creator or admin\"\n        );\n        _setTokenRoyalty(tokenId, recipient, feeNumerator);\n        emit RoyaltyUpdated(tokenId, recipient, feeNumerator);\n    }\n\n    /**\n     * @dev Get royalty info - OPTIMIZED: simplified\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view override returns (address, uint256) {\n        (address recipient, uint256 royaltyAmount) = super.royaltyInfo(tokenId, salePrice);\n        \n        // OPTIMIZED: Use default royalty if no specific royalty set\n        if (recipient == address(0)) {\n            return (msg.sender, (salePrice * DEFAULT_ROYALTY) / 10000);\n        }\n        \n        return (recipient, royaltyAmount);\n    }\n\n    // ============= ADMIN FUNCTIONS =============\n\n    /**\n     * @dev Pause contract - OPTIMIZED\n     */\n    function pause() external onlyAccessControlRole(keccak256(\"PAUSER_ROLE\")) {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause contract - OPTIMIZED\n     */\n    function unpause() external onlyAccessControlRole(keccak256(\"PAUSER_ROLE\")) {\n        _unpause();\n    }\n\n    /**\n     * @dev Burn token - OPTIMIZED\n     */\n    function burn(uint256 tokenId) external onlyValidToken(tokenId) onlyOwnerOrApproved(tokenId) {\n        _burn(tokenId);\n    }\n\n    // ============= QUERY FUNCTIONS =============\n\n    /**\n     * @dev Get sticker details - OPTIMIZED\n     */\n    function getSticker(uint256 tokenId) external view onlyValidToken(tokenId) returns (StickerNFT memory) {\n        return stickers[tokenId];\n    }\n\n    /**\n     * @dev Get customization history - OPTIMIZED\n     */\n    function getCustomizationHistory(uint256 tokenId) external view onlyValidToken(tokenId) returns (CustomizationHistory[] memory) {\n        return customizationHistory[tokenId];\n    }\n\n    /**\n     * @dev Get creator stickers - OPTIMIZED\n     */\n    function getCreatorStickers(address creator) external view returns (uint256[] memory) {\n        return creatorStickers[creator];\n    }\n\n    /**\n     * @dev Check if sticker is customizable - OPTIMIZED\n     */\n    function isStickerCustomizable(uint256 tokenId) external view onlyValidToken(tokenId) returns (bool) {\n        return isCustomizable[tokenId];\n    }\n\n    // ============= INTERNAL FUNCTIONS =============\n\n    /**\n     * @dev Check if customization options exist - OPTIMIZED\n     */\n    function _hasCustomizationOptions(CustomizationOptions memory options) internal pure returns (bool) {\n        return options.allowColorChange || options.allowTextChange || options.allowSizeChange || options.allowEffectsChange;\n    }\n\n    /**\n     * @dev Get next edition number - OPTIMIZED\n     */\n    function _getNextEditionNumber(address creator, string memory stickerName, uint256 editionSize) internal view returns (uint256) {\n        uint256 count = 0;\n        uint256[] storage creatorTokens = creatorStickers[creator];\n        \n        for (uint256 i = 0; i < creatorTokens.length;) {\n            StickerNFT storage sticker = stickers[creatorTokens[i]];\n            if (sticker.isLimitedEdition && \n                keccak256(bytes(sticker.name)) == keccak256(bytes(stickerName)) &&\n                sticker.editionSize == editionSize) {\n                count++;\n            }\n            unchecked { i++; }\n        }\n        \n        return count + 1;\n    }\n\n    // ============= OVERRIDE FUNCTIONS =============\n\n    /**\n     * @dev Required override for ERC721URIStorage\n     */\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Required override for ERC721Royalty\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage, ERC721Royalty) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/MooveRentalPass.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport \"./MooveAccessControl.sol\";\r\n\r\n/**\r\n * @title MooveRentalPass\r\n * @dev NFT contract for 30-day vehicle access passes - NON-TRANSFERABLE\r\n * @notice These NFTs provide access codes for vehicles and cannot be traded\r\n */\r\ncontract MooveRentalPass is\r\n    ERC721,\r\n    ERC721URIStorage,\r\n    ReentrancyGuard,\r\n    Pausable\r\n{\r\n    // ============= STATE VARIABLES =============\r\n\r\n    /// @dev Reference to access control contract\r\n    MooveAccessControl public immutable accessControl;\r\n\r\n    /// @dev Counter for token IDs\r\n    uint256 private _tokenIdCounter = 1;\r\n\r\n    /// @dev Mapping from token ID to rental pass details\r\n    mapping(uint256 => RentalPass) public rentalPasses;\r\n\r\n    /// @dev Mapping from access code to token ID (for validation)\r\n    mapping(string => uint256) public accessCodeToToken;\r\n\r\n    /// @dev Mapping from user to active passes (for UI display)\r\n    mapping(address => uint256[]) public userActivePasses;\r\n\r\n    /// @dev Mapping to track if pass is active\r\n    mapping(uint256 => bool) public isPassActive;\r\n\r\n    // ============= STRUCTS =============\r\n\r\n    struct RentalPass {\r\n        VehicleType vehicleType;\r\n        string accessCode;\r\n        uint256 expirationDate;\r\n        uint256 purchasePrice;\r\n        string location;\r\n        bool isActive;\r\n        address originalOwner;\r\n    }\r\n\r\n    enum VehicleType {\r\n        BIKE,\r\n        SCOOTER,\r\n        MONOPATTINO\r\n    }\r\n\r\n    // ============= EVENTS =============\r\n\r\n    event RentalPassMinted(\r\n        uint256 indexed tokenId,\r\n        address indexed to,\r\n        VehicleType vehicleType,\r\n        string accessCode,\r\n        string location, // Fixed: string instead of uint256\r\n        uint256 price\r\n    );\r\n\r\n    event AccessCodeUsed(\r\n        uint256 indexed tokenId,\r\n        string accessCode,\r\n        address indexed user\r\n    );\r\n\r\n    event PassExpired(uint256 indexed tokenId, string accessCode);\r\n\r\n    event PassDeactivated(\r\n        uint256 indexed tokenId,\r\n        string accessCode,\r\n        string reason\r\n    );\r\n\r\n    // ============= MODIFIERS =============\r\n\r\n    modifier onlyAccessControlRole(bytes32 role) {\r\n        accessControl.validateRole(role, msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidToken(uint256 tokenId) {\r\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNonExpired(uint256 tokenId) {\r\n        require(\r\n            block.timestamp < rentalPasses[tokenId].expirationDate,\r\n            \"Pass expired\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ============= CONSTRUCTOR =============\r\n\r\n    constructor(address _accessControl) ERC721(\"Moove Rental Pass\", \"MRP\") {\r\n        require(_accessControl != address(0), \"Invalid access control address\");\r\n        accessControl = MooveAccessControl(_accessControl);\r\n    }\r\n\r\n    // ============= MINTING FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Internal function to mint a new rental pass NFT\r\n     */\r\n    function _mintRentalPass(\r\n        address to,\r\n        VehicleType vehicleType,\r\n        string memory accessCode,\r\n        string memory location,\r\n        uint256 price,\r\n        string memory _tokenURI\r\n    ) internal {\r\n        require(to != address(0), \"Invalid recipient address\");\r\n        require(bytes(accessCode).length > 0, \"Access code required\");\r\n        require(\r\n            accessCodeToToken[accessCode] == 0,\r\n            \"Access code already exists\"\r\n        );\r\n        require(bytes(location).length > 0, \"Location required\");\r\n\r\n        uint256 tokenId = _tokenIdCounter++;\r\n        uint256 expirationDate = block.timestamp + 30 days;\r\n\r\n        // Create rental pass struct\r\n        rentalPasses[tokenId] = RentalPass({\r\n            vehicleType: vehicleType,\r\n            accessCode: accessCode,\r\n            expirationDate: expirationDate,\r\n            purchasePrice: price,\r\n            location: location,\r\n            isActive: true,\r\n            originalOwner: to\r\n        });\r\n\r\n        // Map access code to token ID\r\n        accessCodeToToken[accessCode] = tokenId;\r\n        isPassActive[tokenId] = true;\r\n\r\n        // Add to user's active passes\r\n        userActivePasses[to].push(tokenId);\r\n\r\n        // Mint the NFT\r\n        _mint(to, tokenId);\r\n\r\n        // Set token URI\r\n        _setTokenURI(tokenId, _tokenURI);\r\n\r\n        // Emit event\r\n        emit RentalPassMinted(\r\n            tokenId,\r\n            to,\r\n            vehicleType,\r\n            accessCode,\r\n            location,\r\n            price\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mint a rental pass\r\n     * @param to Address to mint to\r\n     * @param vehicleType Type of vehicle\r\n     * @param passName Name of the pass\r\n     * @param passDescription Description of the pass\r\n     * @param duration Duration in seconds\r\n     * @param metadataURI URI for the token metadata\r\n     */\r\n    function mintRentalPass(\r\n        address to,\r\n        VehicleType vehicleType,\r\n        string memory passName,\r\n        string memory passDescription,\r\n        uint256 duration,\r\n        string memory metadataURI\r\n    ) external onlyAccessControlRole(accessControl.MINTER_ROLE()) nonReentrant {\r\n        _mintRentalPass(\r\n            to,\r\n            vehicleType,\r\n            passName,\r\n            passDescription,\r\n            duration,\r\n            metadataURI\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Batch mint rental passes for efficiency\r\n     */\r\n    function batchMintRentalPasses(\r\n        address[] calldata recipients,\r\n        VehicleType[] calldata vehicleTypes,\r\n        string[] calldata accessCodes,\r\n        string[] calldata locations,\r\n        uint256[] calldata prices,\r\n        string[] calldata tokenURIs\r\n    ) external onlyAccessControlRole(accessControl.MINTER_ROLE()) nonReentrant {\r\n        require(\r\n            recipients.length == vehicleTypes.length,\r\n            \"Array length mismatch\"\r\n        );\r\n        require(\r\n            recipients.length == accessCodes.length,\r\n            \"Array length mismatch\"\r\n        );\r\n        require(recipients.length == locations.length, \"Array length mismatch\");\r\n        require(recipients.length == prices.length, \"Array length mismatch\");\r\n        require(recipients.length == tokenURIs.length, \"Array length mismatch\");\r\n        require(recipients.length <= 50, \"Batch size too large\");\r\n\r\n        for (uint256 i = 0; i < recipients.length; i++) {\r\n            _mintRentalPass(\r\n                recipients[i],\r\n                vehicleTypes[i],\r\n                accessCodes[i],\r\n                locations[i],\r\n                prices[i],\r\n                tokenURIs[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============= ACCESS VALIDATION =============\r\n\r\n    /**\r\n     * @dev Validate access code and mark as used\r\n     */\r\n    function validateAndUseAccessCode(\r\n        string memory accessCode\r\n    )\r\n        external\r\n        onlyAccessControlRole(accessControl.MINTER_ROLE())\r\n        returns (uint256 tokenId, address owner, VehicleType vehicleType)\r\n    {\r\n        tokenId = accessCodeToToken[accessCode];\r\n        require(tokenId != 0, \"Invalid access code\");\r\n\r\n        RentalPass storage pass = rentalPasses[tokenId];\r\n        require(pass.isActive, \"Pass is not active\");\r\n        require(block.timestamp < pass.expirationDate, \"Pass expired\");\r\n\r\n        owner = _ownerOf(tokenId);\r\n        vehicleType = pass.vehicleType;\r\n\r\n        emit AccessCodeUsed(tokenId, accessCode, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if access code is valid without using it\r\n     */\r\n    function isAccessCodeValid(\r\n        string memory accessCode\r\n    )\r\n        external\r\n        view\r\n        returns (bool valid, uint256 tokenId, uint256 expirationDate)\r\n    {\r\n        tokenId = accessCodeToToken[accessCode];\r\n        if (tokenId == 0) return (false, 0, 0);\r\n\r\n        RentalPass memory pass = rentalPasses[tokenId];\r\n        valid = pass.isActive && block.timestamp < pass.expirationDate;\r\n        expirationDate = pass.expirationDate;\r\n    }\r\n\r\n    // ============= PASS MANAGEMENT =============\r\n\r\n    /**\r\n     * @dev Deactivate a rental pass (admin function)\r\n     */\r\n    function deactivatePass(\r\n        uint256 tokenId,\r\n        string memory reason\r\n    )\r\n        external\r\n        onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE())\r\n        onlyValidToken(tokenId)\r\n    {\r\n        RentalPass storage pass = rentalPasses[tokenId];\r\n        require(pass.isActive, \"Pass already inactive\");\r\n\r\n        pass.isActive = false;\r\n        isPassActive[tokenId] = false;\r\n\r\n        // Remove from user's active passes\r\n        _removeFromActivePasses(_ownerOf(tokenId), tokenId);\r\n\r\n        emit PassDeactivated(tokenId, pass.accessCode, reason);\r\n    }\r\n\r\n    /**\r\n     * @dev Cleanup expired passes (can be called by anyone to maintain state)\r\n     */\r\n    function cleanupExpiredPasses(uint256[] calldata tokenIds) external {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            uint256 tokenId = tokenIds[i];\r\n            if (_ownerOf(tokenId) != address(0)) {\r\n                RentalPass storage pass = rentalPasses[tokenId];\r\n                if (pass.isActive && block.timestamp >= pass.expirationDate) {\r\n                    pass.isActive = false;\r\n                    isPassActive[tokenId] = false;\r\n\r\n                    // Remove from user's active passes\r\n                    _removeFromActivePasses(_ownerOf(tokenId), tokenId);\r\n\r\n                    emit PassExpired(tokenId, pass.accessCode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============= VIEW FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Get rental pass details\r\n     */\r\n    function getRentalPass(\r\n        uint256 tokenId\r\n    ) external view onlyValidToken(tokenId) returns (RentalPass memory) {\r\n        return rentalPasses[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get user's active passes\r\n     */\r\n    function getUserActivePasses(\r\n        address user\r\n    ) external view returns (uint256[] memory) {\r\n        return userActivePasses[user];\r\n    }\r\n\r\n    /**\r\n     * @dev Get user's active passes with details\r\n     */\r\n    function getUserActivePassesWithDetails(\r\n        address user\r\n    ) external view returns (RentalPass[] memory activePasses) {\r\n        uint256[] memory tokenIds = userActivePasses[user];\r\n        activePasses = new RentalPass[](tokenIds.length);\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            activePasses[i] = rentalPasses[tokenIds[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get total supply of rental passes\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return _tokenIdCounter - 1; // Subtract 1 because counter starts at 1\r\n    }\r\n\r\n    /**\r\n     * @dev Check if pass is expired\r\n     */\r\n    function isPassExpired(\r\n        uint256 tokenId\r\n    ) external view onlyValidToken(tokenId) returns (bool) {\r\n        return block.timestamp >= rentalPasses[tokenId].expirationDate;\r\n    }\r\n\r\n    /**\r\n     * @dev Get token ID by access code\r\n     */\r\n    function getTokenByAccessCode(\r\n        string memory accessCode\r\n    ) external view returns (uint256) {\r\n        uint256 tokenId = accessCodeToToken[accessCode];\r\n        require(tokenId != 0, \"Access code not found\");\r\n        return tokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev Get passes expiring soon (within next 24 hours)\r\n     */\r\n    function getPassesExpiringSoon(\r\n        address user\r\n    ) external view returns (uint256[] memory expiringPasses) {\r\n        uint256[] memory userPasses = userActivePasses[user];\r\n        uint256 count = 0;\r\n\r\n        // Count expiring passes\r\n        for (uint256 i = 0; i < userPasses.length; i++) {\r\n            if (\r\n                rentalPasses[userPasses[i]].expirationDate <=\r\n                block.timestamp + 24 hours\r\n            ) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Fill array\r\n        expiringPasses = new uint256[](count);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < userPasses.length; i++) {\r\n            if (\r\n                rentalPasses[userPasses[i]].expirationDate <=\r\n                block.timestamp + 24 hours\r\n            ) {\r\n                expiringPasses[index++] = userPasses[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============= INTERNAL FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Remove token from user's active passes array\r\n     */\r\n    function _removeFromActivePasses(address user, uint256 tokenId) internal {\r\n        uint256[] storage passes = userActivePasses[user];\r\n        for (uint256 i = 0; i < passes.length; i++) {\r\n            if (passes[i] == tokenId) {\r\n                // Move last element to current position and remove last element\r\n                passes[i] = passes[passes.length - 1];\r\n                passes.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============= OVERRIDE FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Override _update to prevent transfers but allow minting (OpenZeppelin v5.x)\r\n     */\r\n    function _update(\r\n        address to,\r\n        uint256 tokenId,\r\n        address auth\r\n    ) internal override returns (address) {\r\n        address from = _ownerOf(tokenId);\r\n\r\n        // Allow minting (from == address(0)) but block all transfers\r\n        if (from != address(0)) {\r\n            revert(\"Rental passes are non-transferable\");\r\n        }\r\n\r\n        return super._update(to, tokenId, auth);\r\n    }\r\n\r\n    /**\r\n     * @dev Override tokenURI\r\n     */\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view override(ERC721, ERC721URIStorage) returns (string memory) {\r\n        return super.tokenURI(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Override supportsInterface\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view override(ERC721, ERC721URIStorage) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    // ============= BURN FUNCTIONALITY =============\r\n\r\n    /**\r\n     * @dev Burn a rental pass and cleanup associated data\r\n     * @param tokenId Token ID to burn\r\n     */\r\n    function burnRentalPass(uint256 tokenId) external {\r\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\r\n        require(\r\n            ownerOf(tokenId) == msg.sender ||\r\n                accessControl.hasRole(\r\n                    accessControl.MASTER_ADMIN_ROLE(),\r\n                    msg.sender\r\n                ),\r\n            \"Not authorized to burn\"\r\n        );\r\n\r\n        // Get pass data before burning (needed for cleanup)\r\n        RentalPass storage pass = rentalPasses[tokenId];\r\n        address owner = ownerOf(tokenId);\r\n\r\n        // Remove from user's active passes\r\n        _removeFromActivePasses(owner, tokenId);\r\n\r\n        // Cleanup mapping data\r\n        delete accessCodeToToken[pass.accessCode];\r\n        delete rentalPasses[tokenId];\r\n        delete isPassActive[tokenId];\r\n\r\n        // Call parent _burn function (this will work in v5)\r\n        _burn(tokenId);\r\n    }\r\n\r\n    // ============= EMERGENCY FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Emergency pause contract\r\n     */\r\n    function pause()\r\n        external\r\n        onlyAccessControlRole(accessControl.PAUSER_ROLE())\r\n    {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause contract\r\n     */\r\n    function unpause()\r\n        external\r\n        onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE())\r\n    {\r\n        _unpause();\r\n    }\r\n}\r\n"
    },
    "contracts/MooveTradingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"./MooveAccessControl.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\n/**\r\n * @title MooveTradingManager\r\n * @dev Estensione per gestire il trading di NFT personalizzabili\r\n * @notice Gestisce commissioni, lock personalizzazioni e validazioni per il trading\r\n */\r\n\r\ninterface IMooveTradingManager {\r\n    function recordAuctionSale(\r\n        address nftContract,\r\n        uint256 tokenId,\r\n        address seller,\r\n        address buyer,\r\n        uint256 price\r\n    ) external;\r\n}\r\n\r\ncontract MooveTradingManager is ReentrancyGuard, Pausable {\r\n    // ============= STORAGE VARIABLES =============\r\n\r\n    /// @dev Reference to the access control contract\r\n    MooveAccessControl public immutable accessControl;\r\n\r\n    /// @dev Trading fee percentage (basis points: 100 = 1%)\r\n    uint256 public tradingFeePercentage = 250; // 2.5%\r\n\r\n    /// @dev Marketplace commission percentage (basis points)\r\n    uint256 public marketplaceFeePercentage = 100; // 1%\r\n\r\n    /// @dev Minimum trading fee in wei\r\n    uint256 public constant minimumTradingFee = 0.001 ether;\r\n\r\n    /// @dev Maximum trading fee percentage (10%)\r\n    uint256 public constant MAX_TRADING_FEE = 1000;\r\n\r\n    /// @dev Treasury address for collecting fees\r\n    address public treasury;\r\n\r\n    /// @dev Mapping to track NFT customization locks during trades\r\n    mapping(address => mapping(uint256 => bool)) public customizationLocked;\r\n\r\n    /// @dev Mapping to track authorized NFT contracts\r\n    mapping(address => bool) public authorizedNFTContracts;\r\n\r\n    /// @dev Mapping to track active sales\r\n    mapping(address => mapping(uint256 => SaleInfo)) public activeSales;\r\n\r\n    /// @dev Mapping to track trading statistics\r\n    mapping(address => TradingStats) public userTradingStats;\r\n\r\n    // ============= STRUCTS =============\r\n\r\n    struct SaleInfo {\r\n        address seller;\r\n        uint256 price;\r\n        uint256 listedAt;\r\n        bool isActive;\r\n        bool allowCustomization;\r\n    }\r\n\r\n    struct TradingStats {\r\n        uint256 totalSales;\r\n        uint256 totalPurchases;\r\n        uint256 volumeTraded;\r\n        uint256 feesEarned; // For sellers\r\n        uint256 feesPaid; // For buyers\r\n    }\r\n\r\n    struct TradeDetails {\r\n        address nftContract;\r\n        uint256 tokenId;\r\n        address seller;\r\n        address buyer;\r\n        uint256 price;\r\n        uint256 tradingFee;\r\n        uint256 marketplaceFee;\r\n        uint256 sellerProceeds;\r\n    }\r\n\r\n    // ============= EVENTS =============\r\n\r\n    event NFTPreparedForTrade(\r\n        address indexed nftContract,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 price,\r\n        bool allowCustomization\r\n    );\r\n\r\n    event NFTTradeCompleted(\r\n        address indexed nftContract,\r\n        uint256 indexed tokenId,\r\n        address indexed buyer,\r\n        address seller,\r\n        uint256 finalPrice,\r\n        uint256 tradingFee,\r\n        uint256 marketplaceFee\r\n    );\r\n\r\n    event CustomizationLockChanged(\r\n        address indexed nftContract,\r\n        uint256 indexed tokenId,\r\n        bool locked\r\n    );\r\n\r\n    event TradingFeesUpdated(\r\n        uint256 oldTradingFee,\r\n        uint256 newTradingFee,\r\n        uint256 oldMarketplaceFee,\r\n        uint256 newMarketplaceFee\r\n    );\r\n\r\n    event NFTContractAuthorized(address indexed nftContract, bool authorized);\r\n\r\n    event TreasuryUpdated(\r\n        address indexed oldTreasury,\r\n        address indexed newTreasury\r\n    );\r\n\r\n    event FeesWithdrawn(address indexed to, uint256 amount);\r\n\r\n    // ============= MODIFIERS =============\r\n\r\n    modifier onlyAccessControlRole(bytes32 role) {\r\n        accessControl.validateRole(role, msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedNFT(address nftContract) {\r\n        require(\r\n            authorizedNFTContracts[nftContract],\r\n            \"NFT contract not authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenNotPaused() {\r\n        accessControl.validateNotPaused();\r\n        require(!paused(), \"Trading paused\");\r\n        _;\r\n    }\r\n\r\n    modifier validAddress(address addr) {\r\n        require(addr != address(0), \"Invalid address\");\r\n        _;\r\n    }\r\n\r\n    // ============= CONSTRUCTOR =============\r\n\r\n    constructor(\r\n        address _accessControl,\r\n        address _treasury\r\n    ) validAddress(_accessControl) validAddress(_treasury) {\r\n        accessControl = MooveAccessControl(_accessControl);\r\n        treasury = _treasury;\r\n    }\r\n\r\n    // ============= TRADING FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Prepare NFT for trading with customization lock options\r\n     * @param nftContract Address of the NFT contract\r\n     * @param tokenId Token ID to prepare for trading\r\n     * @param salePrice Price at which to list the NFT\r\n     * @param allowCustomization Whether to allow customization during sale period\r\n     */\r\n    function prepareNFTForTrade(\r\n        address nftContract,\r\n        uint256 tokenId,\r\n        uint256 salePrice,\r\n        bool allowCustomization\r\n    ) external onlyAuthorizedNFT(nftContract) onlyWhenNotPaused nonReentrant {\r\n        require(salePrice > 0, \"Invalid sale price\");\r\n\r\n        // Verify caller owns the NFT (this would need to be integrated with your NFT contract)\r\n        // For now, we assume the caller is authorized\r\n\r\n        // Lock customization if not allowed during sale\r\n        if (!allowCustomization) {\r\n            customizationLocked[nftContract][tokenId] = true;\r\n            emit CustomizationLockChanged(nftContract, tokenId, true);\r\n        }\r\n\r\n        // Create sale info\r\n        activeSales[nftContract][tokenId] = SaleInfo({\r\n            seller: msg.sender,\r\n            price: salePrice,\r\n            listedAt: block.timestamp,\r\n            isActive: true,\r\n            allowCustomization: allowCustomization\r\n        });\r\n\r\n        emit NFTPreparedForTrade(\r\n            nftContract,\r\n            tokenId,\r\n            msg.sender,\r\n            salePrice,\r\n            allowCustomization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Execute NFT trade\r\n     * @param nftContract Address of the NFT contract\r\n     * @param tokenId Token ID to trade\r\n     */\r\n    function executeNFTTrade(\r\n        address nftContract,\r\n        uint256 tokenId\r\n    ) external payable nonReentrant {\r\n        SaleInfo storage sale = activeSales[nftContract][tokenId];\r\n        require(sale.isActive, \"Sale not active\");\r\n        require(msg.value == sale.price, \"Incorrect payment amount\");\r\n        require(msg.sender != sale.seller, \"Cannot buy your own NFT\");\r\n\r\n        // Update state first to prevent reentrancy\r\n        sale.isActive = false;\r\n        customizationLocked[nftContract][tokenId] = false;\r\n\r\n        // Calculate trade details\r\n        TradeDetails memory trade = _calculateTradeDetails(\r\n            nftContract,\r\n            tokenId,\r\n            sale.seller,\r\n            msg.sender,\r\n            sale.price\r\n        );\r\n\r\n        // Process payments\r\n        _processTradePayments(trade);\r\n\r\n        // Transfer NFT - use safeTransferFrom to prevent arbitrary from\r\n        IERC721(nftContract).safeTransferFrom(sale.seller, msg.sender, tokenId);\r\n\r\n        // Refund excess payment\r\n        if (msg.value > sale.price) {\r\n            (bool refundSuccess, ) = payable(msg.sender).call{value: msg.value - sale.price}(\"\");\r\n            require(refundSuccess, \"Refund failed\");\r\n        }\r\n\r\n        // Update statistics\r\n        _updateTradingStats(trade);\r\n\r\n        emit NFTTradeCompleted(\r\n            nftContract,\r\n            tokenId,\r\n            msg.sender,\r\n            sale.seller,\r\n            sale.price,\r\n            trade.tradingFee,\r\n            trade.marketplaceFee\r\n        );\r\n\r\n        emit CustomizationLockChanged(nftContract, tokenId, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel NFT sale and unlock customization\r\n     * @param nftContract Address of the NFT contract\r\n     * @param tokenId Token ID to cancel sale for\r\n     */\r\n    function cancelNFTSale(\r\n        address nftContract,\r\n        uint256 tokenId\r\n    ) external onlyAuthorizedNFT(nftContract) nonReentrant {\r\n        SaleInfo storage sale = activeSales[nftContract][tokenId];\r\n        require(sale.isActive, \"NFT not for sale\");\r\n        require(sale.seller == msg.sender, \"Not the seller\");\r\n\r\n        // Unlock customization\r\n        customizationLocked[nftContract][tokenId] = false;\r\n\r\n        // Deactivate sale\r\n        sale.isActive = false;\r\n\r\n        emit CustomizationLockChanged(nftContract, tokenId, false);\r\n    }\r\n\r\n    // ============= CUSTOMIZATION MANAGEMENT =============\r\n\r\n    /**\r\n     * @dev Lock NFT customization (called by customization contract)\r\n     * @param nftContract Address of the NFT contract\r\n     * @param tokenId Token ID to lock\r\n     */\r\n    function lockCustomization(\r\n        address nftContract,\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        onlyAccessControlRole(accessControl.CUSTOMIZATION_ADMIN_ROLE())\r\n        onlyAuthorizedNFT(nftContract)\r\n    {\r\n        customizationLocked[nftContract][tokenId] = true;\r\n        emit CustomizationLockChanged(nftContract, tokenId, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Unlock NFT customization\r\n     * @param nftContract Address of the NFT contract\r\n     * @param tokenId Token ID to unlock\r\n     */\r\n    function unlockCustomization(\r\n        address nftContract,\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        onlyAccessControlRole(accessControl.CUSTOMIZATION_ADMIN_ROLE())\r\n        onlyAuthorizedNFT(nftContract)\r\n    {\r\n        customizationLocked[nftContract][tokenId] = false;\r\n        emit CustomizationLockChanged(nftContract, tokenId, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if NFT customization is locked\r\n     * @param nftContract Address of the NFT contract\r\n     * @param tokenId Token ID to check\r\n     * @return locked True if customization is locked\r\n     */\r\n    function isCustomizationLocked(\r\n        address nftContract,\r\n        uint256 tokenId\r\n    ) external view returns (bool locked) {\r\n        return customizationLocked[nftContract][tokenId];\r\n    }\r\n\r\n    // ============= ADMIN FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Update trading fees\r\n     * @param newTradingFee New trading fee percentage (basis points)\r\n     * @param newMarketplaceFee New marketplace fee percentage (basis points)\r\n     */\r\n    function updateTradingFees(\r\n        uint256 newTradingFee,\r\n        uint256 newMarketplaceFee\r\n    ) external onlyAccessControlRole(accessControl.PRICE_MANAGER_ROLE()) {\r\n        require(newTradingFee <= MAX_TRADING_FEE, \"Trading fee too high\");\r\n        require(\r\n            newMarketplaceFee <= MAX_TRADING_FEE,\r\n            \"Marketplace fee too high\"\r\n        );\r\n\r\n        uint256 oldTradingFee = tradingFeePercentage;\r\n        uint256 oldMarketplaceFee = marketplaceFeePercentage;\r\n\r\n        tradingFeePercentage = newTradingFee;\r\n        marketplaceFeePercentage = newMarketplaceFee;\r\n\r\n        emit TradingFeesUpdated(\r\n            oldTradingFee,\r\n            newTradingFee,\r\n            oldMarketplaceFee,\r\n            newMarketplaceFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Authorize NFT contract for trading\r\n     * @param nftContract Address of the NFT contract\r\n     */\r\n    function authorizeNFTContract(\r\n        address nftContract\r\n    )\r\n        external\r\n        onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE())\r\n        validAddress(nftContract)\r\n    {\r\n        require(nftContract.code.length > 0, \"Not a contract\");\r\n        authorizedNFTContracts[nftContract] = true;\r\n        emit NFTContractAuthorized(nftContract, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Deauthorize NFT contract for trading\r\n     * @param nftContract Address of the NFT contract\r\n     */\r\n    function deauthorizeNFTContract(\r\n        address nftContract\r\n    ) external onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE()) {\r\n        authorizedNFTContracts[nftContract] = false;\r\n        emit NFTContractAuthorized(nftContract, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Update treasury address\r\n     * @param newTreasury New treasury address\r\n     */\r\n    function updateTreasury(\r\n        address newTreasury\r\n    )\r\n        external\r\n        onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE())\r\n        validAddress(newTreasury)\r\n    {\r\n        address oldTreasury = treasury;\r\n        treasury = newTreasury;\r\n        emit TreasuryUpdated(oldTreasury, newTreasury);\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency pause trading\r\n     */\r\n    function pauseTrading()\r\n        external\r\n        onlyAccessControlRole(accessControl.PAUSER_ROLE())\r\n    {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause trading\r\n     */\r\n    function unpauseTrading()\r\n        external\r\n        onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE())\r\n    {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw accumulated fees\r\n     * @param to Address to send fees to\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function withdrawFees(\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        external\r\n        onlyAccessControlRole(accessControl.WITHDRAWER_ROLE())\r\n        validAddress(to)\r\n        nonReentrant\r\n    {\r\n        require(to != address(this), \"Cannot withdraw to self\");\r\n        require(to.code.length == 0, \"Cannot withdraw to contract\");\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(amount <= address(this).balance, \"Insufficient balance\");\r\n\r\n        // Use call instead of transfer for better gas efficiency and to prevent reentrancy\r\n        (bool success, ) = payable(to).call{value: amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        emit FeesWithdrawn(to, amount);\r\n    }\r\n\r\n    // ============= VIEW FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Get sale information for an NFT\r\n     * @param nftContract Address of the NFT contract\r\n     * @param tokenId Token ID\r\n     * @return sale Sale information\r\n     */\r\n    function getSaleInfo(\r\n        address nftContract,\r\n        uint256 tokenId\r\n    ) external view returns (SaleInfo memory sale) {\r\n        return activeSales[nftContract][tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get trading statistics for a user\r\n     * @param user User address\r\n     * @return stats Trading statistics\r\n     */\r\n    function getTradingStats(\r\n        address user\r\n    ) external view returns (TradingStats memory stats) {\r\n        return userTradingStats[user];\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate trade fees for a given price\r\n     * @param price Trade price\r\n     * @return tradingFee Trading fee amount\r\n     * @return marketplaceFee Marketplace fee amount\r\n     * @return sellerProceeds Amount seller receives\r\n     */\r\n    function calculateTradeFees(\r\n        uint256 price\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 tradingFee,\r\n            uint256 marketplaceFee,\r\n            uint256 sellerProceeds\r\n        )\r\n    {\r\n        tradingFee = (price * tradingFeePercentage) / 10000;\r\n        if (tradingFee < minimumTradingFee) {\r\n            tradingFee = minimumTradingFee;\r\n        }\r\n\r\n        marketplaceFee = (price * marketplaceFeePercentage) / 10000;\r\n        sellerProceeds = price - tradingFee - marketplaceFee;\r\n    }\r\n\r\n    // ============= INTERNAL FUNCTIONS =============\r\n\r\n    /**\r\n     * @dev Calculate detailed trade information\r\n     */\r\n    function _calculateTradeDetails(\r\n        address nftContract,\r\n        uint256 tokenId,\r\n        address seller,\r\n        address buyer,\r\n        uint256 price\r\n    ) internal view returns (TradeDetails memory) {\r\n        (\r\n            uint256 tradingFee,\r\n            uint256 marketplaceFee,\r\n            uint256 sellerProceeds\r\n        ) = this.calculateTradeFees(price);\r\n\r\n        return\r\n            TradeDetails({\r\n                nftContract: nftContract,\r\n                tokenId: tokenId,\r\n                seller: seller,\r\n                buyer: buyer,\r\n                price: price,\r\n                tradingFee: tradingFee,\r\n                marketplaceFee: marketplaceFee,\r\n                sellerProceeds: sellerProceeds\r\n            });\r\n    }\r\n\r\n    /**\r\n     * @dev Update trading statistics for buyer and seller\r\n     */\r\n    function _updateTradingStats(TradeDetails memory trade) internal {\r\n        // Update seller stats\r\n        TradingStats storage sellerStats = userTradingStats[trade.seller];\r\n        sellerStats.totalSales++;\r\n        sellerStats.volumeTraded += trade.price;\r\n        sellerStats.feesEarned += trade.sellerProceeds;\r\n\r\n        // Update buyer stats\r\n        TradingStats storage buyerStats = userTradingStats[trade.buyer];\r\n        buyerStats.totalPurchases++;\r\n        buyerStats.volumeTraded += trade.price;\r\n        buyerStats.feesPaid += trade.tradingFee + trade.marketplaceFee;\r\n    }\r\n\r\n    /**\r\n     * @dev Process payments for a trade\r\n     */\r\n    function _processTradePayments(TradeDetails memory trade) internal {\r\n        require(trade.seller != address(0), \"Invalid seller address\");\r\n        require(trade.seller.code.length == 0, \"Seller cannot be a contract\");\r\n        require(trade.sellerProceeds > 0, \"Invalid seller proceeds\");\r\n        \r\n        // Send proceeds to seller using call for better security\r\n        (bool success, ) = payable(trade.seller).call{value: trade.sellerProceeds}(\"\");\r\n        require(success, \"Transfer to seller failed\");\r\n\r\n        // Keep fees in contract for later withdrawal to treasury\r\n        // Trading fee and marketplace fee stay in contract balance\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency withdraw all funds to treasury\r\n     */\r\n    function emergencyWithdraw() external onlyAccessControlRole(accessControl.MASTER_ADMIN_ROLE()) nonReentrant {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No funds to withdraw\");\r\n\r\n        // Use call instead of transfer for better gas efficiency and to prevent reentrancy\r\n        (bool success, ) = payable(treasury).call{value: balance}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        emit FeesWithdrawn(treasury, balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Receive function to accept ETH\r\n     */\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/test/TestPriceCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"../libraries/PriceCalculator.sol\";\r\n\r\ncontract TestPriceCalculator {\r\n    using PriceCalculator for uint256;\r\n\r\n    function calculateDutchPrice(\r\n        uint256 startPrice,\r\n        uint256 endPrice,\r\n        uint256 startTime,\r\n        uint256 endTime\r\n    ) external view returns (uint256) {\r\n        return PriceCalculator.calculateDutchPrice(\r\n            startPrice,\r\n            endPrice,\r\n            startTime,\r\n            endTime\r\n        );\r\n    }\r\n} "
    },
    "contracts/test/TestVehicleMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\nimport \"../libraries/VehicleMetadata.sol\";\r\n\r\ncontract TestVehicleMetadata {\r\n    using VehicleMetadata for VehicleMetadata.CustomizationData;\r\n\r\n    VehicleMetadata.CustomizationData public customizationData;\r\n\r\n    function addSticker(string memory sticker) external {\r\n        VehicleMetadata.addSticker(customizationData, sticker);\r\n    }\r\n\r\n    function getStickers() external view returns (string[] memory) {\r\n        return customizationData.stickers;\r\n    }\r\n\r\n    function getColorScheme() external view returns (string memory) {\r\n        return customizationData.colorScheme;\r\n    }\r\n\r\n    function getAchievements() external view returns (string[] memory) {\r\n        return customizationData.achievements;\r\n    }\r\n\r\n    function getLastUpdated() external view returns (uint256) {\r\n        return customizationData.lastUpdated;\r\n    }\r\n\r\n    function setColorScheme(string memory colorScheme) external {\r\n        customizationData.colorScheme = colorScheme;\r\n        customizationData.lastUpdated = block.timestamp;\r\n    }\r\n\r\n    function addAchievement(string memory achievement) external {\r\n        customizationData.achievements.push(achievement);\r\n        customizationData.lastUpdated = block.timestamp;\r\n    }\r\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}