"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/marketplace/page",{

/***/ "(app-pages-browser)/./hooks/useLocationAndCity.ts":
/*!*************************************!*\
  !*** ./hooks/useLocationAndCity.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLocationAndCity: function() { return /* binding */ useLocationAndCity; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_vehicleGeoLocation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/vehicleGeoLocation */ \"(app-pages-browser)/./utils/vehicleGeoLocation.ts\");\n\n\nfunction useLocationAndCity() {\n    const [locationState, setLocationState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        currentCity: null,\n        isLoading: true,\n        error: null,\n        canRent: false,\n        nearbyVehicles: [],\n        location: null,\n        showLocationModal: false,\n        locationMethod: \"none\"\n    });\n    const geoSystem = new _utils_vehicleGeoLocation__WEBPACK_IMPORTED_MODULE_1__.VehicleGeolocationSystem();\n    const refreshLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setLocationState((prev)=>({\n                ...prev,\n                isLoading: true,\n                error: null,\n                showLocationModal: false\n            }));\n        try {\n            const locationStateResult = await geoSystem.getCurrentLocationState();\n            // Get fresh coordinates for location field\n            let coordinates = null;\n            try {\n                const freshLocation = await geoSystem.getCurrentLocation();\n                coordinates = freshLocation;\n            } catch (coordError) {\n                var _locationStateResult_currentCity;\n                // If coordinates fail, try to use city coordinates as fallback\n                if ((_locationStateResult_currentCity = locationStateResult.currentCity) === null || _locationStateResult_currentCity === void 0 ? void 0 : _locationStateResult_currentCity.coordinates) {\n                    coordinates = locationStateResult.currentCity.coordinates;\n                }\n            }\n            // Determine location method based on the result\n            let locationMethod = \"none\";\n            if (locationStateResult.method === \"gps\") {\n                locationMethod = locationStateResult.error ? \"manual\" : \"gps\"; // Manual if fallback was used\n            } else if (locationStateResult.method === \"manual\") {\n                locationMethod = \"manual\";\n            }\n            setLocationState((prev)=>({\n                    ...prev,\n                    currentCity: locationStateResult.currentCity,\n                    isLoading: false,\n                    error: locationStateResult.error,\n                    canRent: locationStateResult.canRent,\n                    location: coordinates,\n                    locationMethod: locationMethod,\n                    showLocationModal: false\n                }));\n            // Development fallback\n            if ( true && !locationStateResult.canRent && locationStateResult.error) {\n                console.log(\"\\uD83C\\uDFD7️ Development mode: Auto-setting Rome as test location...\");\n                try {\n                    const testState = await geoSystem.setTestLocation(\"rome\");\n                    setLocationState((prev)=>{\n                        var _testState_currentCity;\n                        return {\n                            ...prev,\n                            currentCity: testState.currentCity,\n                            isLoading: false,\n                            error: \"Dev mode: Using \".concat((_testState_currentCity = testState.currentCity) === null || _testState_currentCity === void 0 ? void 0 : _testState_currentCity.name, \". Original error: \").concat(locationStateResult.error),\n                            canRent: testState.canRent,\n                            locationMethod: \"manual\",\n                            showLocationModal: false\n                        };\n                    });\n                } catch (testError) {\n                    console.error(\"Test location failed:\", testError);\n                }\n            }\n        } catch (error) {\n            setLocationState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    error: error.message || \"Location access failed\",\n                    canRent: false,\n                    showLocationModal: true,\n                    locationMethod: \"none\"\n                }));\n        }\n    }, []);\n    const setTestLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cityId)=>{\n        setLocationState((prev)=>({\n                ...prev,\n                isLoading: true,\n                error: null\n            }));\n        try {\n            var _testState_currentCity;\n            const testState = await geoSystem.setTestLocation(cityId);\n            // Get city coordinates\n            const cityCoordinates = ((_testState_currentCity = testState.currentCity) === null || _testState_currentCity === void 0 ? void 0 : _testState_currentCity.coordinates) || null;\n            setLocationState((prev)=>({\n                    ...prev,\n                    currentCity: testState.currentCity,\n                    isLoading: false,\n                    error: null,\n                    canRent: testState.canRent,\n                    location: cityCoordinates,\n                    locationMethod: \"manual\",\n                    showLocationModal: false\n                }));\n            console.log(\"\\uD83E\\uDDEA Test location set: \".concat(cityId));\n        } catch (error) {\n            setLocationState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    error: error.message,\n                    locationMethod: \"none\"\n                }));\n        }\n    }, []);\n    const clearLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        geoSystem.clearLocationCache();\n        setLocationState({\n            currentCity: null,\n            isLoading: false,\n            error: null,\n            canRent: false,\n            nearbyVehicles: [],\n            location: null,\n            showLocationModal: false,\n            locationMethod: \"none\"\n        });\n        console.log(\"\\uD83D\\uDDD1️ Location cleared\");\n    }, []);\n    // Initialize on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let mounted = true;\n        const initialize = async ()=>{\n            if (!mounted) return;\n            await refreshLocation();\n        };\n        initialize();\n        return ()=>{\n            mounted = false;\n        };\n    }, [\n        refreshLocation\n    ]);\n    // Return extended state with both location and coordinates (same value)\n    return {\n        ...locationState,\n        coordinates: locationState.location,\n        refreshLocation,\n        setTestLocation,\n        clearLocation\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUxvY2F0aW9uQW5kQ2l0eS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlEO0FBQ2E7QUF3Qi9ELFNBQVNJO0lBQ2QsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR04sK0NBQVFBLENBQWdCO1FBQ2hFTyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGdCQUFnQixFQUFFO1FBQ2xCQyxVQUFVO1FBQ1ZDLG1CQUFtQjtRQUNuQkMsZ0JBQWdCO0lBQ2xCO0lBRUEsTUFBTUMsWUFBWSxJQUFJWiwrRUFBd0JBO0lBRTlDLE1BQU1hLGtCQUFrQmQsa0RBQVdBLENBQUM7UUFDbENJLGlCQUFpQixDQUFDVyxPQUFVO2dCQUMxQixHQUFHQSxJQUFJO2dCQUNQVCxXQUFXO2dCQUNYQyxPQUFPO2dCQUNQSSxtQkFBbUI7WUFDckI7UUFFQSxJQUFJO1lBQ0YsTUFBTUssc0JBQXNCLE1BQU1ILFVBQVVJLHVCQUF1QjtZQUVuRSwyQ0FBMkM7WUFDM0MsSUFBSUMsY0FBbUQ7WUFDdkQsSUFBSTtnQkFDRixNQUFNQyxnQkFBZ0IsTUFBTU4sVUFBVU8sa0JBQWtCO2dCQUN4REYsY0FBY0M7WUFDaEIsRUFBRSxPQUFPRSxZQUFZO29CQUVmTDtnQkFESiwrREFBK0Q7Z0JBQy9ELEtBQUlBLG1DQUFBQSxvQkFBb0JYLFdBQVcsY0FBL0JXLHVEQUFBQSxpQ0FBaUNFLFdBQVcsRUFBRTtvQkFDaERBLGNBQWNGLG9CQUFvQlgsV0FBVyxDQUFDYSxXQUFXO2dCQUMzRDtZQUNGO1lBRUEsZ0RBQWdEO1lBQ2hELElBQUlOLGlCQUE0QztZQUNoRCxJQUFJSSxvQkFBb0JNLE1BQU0sS0FBSyxPQUFPO2dCQUN4Q1YsaUJBQWlCSSxvQkFBb0JULEtBQUssR0FBRyxXQUFXLE9BQU8sOEJBQThCO1lBQy9GLE9BQU8sSUFBSVMsb0JBQW9CTSxNQUFNLEtBQUssVUFBVTtnQkFDbERWLGlCQUFpQjtZQUNuQjtZQUVB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VUFBVTtRQUNaO0lBQ0YsR0FBRztRQUFDckI7S0FBZ0I7SUFFcEIsd0VBQXdFO0lBQ3hFLE9BQU87UUFDTCxHQUFHWCxhQUFhO1FBQ2hCZSxhQUFhZixjQUFjTyxRQUFRO1FBQ25DSTtRQUNBYTtRQUNBTTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlTG9jYXRpb25BbmRDaXR5LnRzPzhiZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgVmVoaWNsZUdlb2xvY2F0aW9uU3lzdGVtIH0gZnJvbSBcIkAvdXRpbHMvdmVoaWNsZUdlb0xvY2F0aW9uXCI7XHJcbmltcG9ydCB7IEVVUk9QRUFOX0NJVElFUyB9IGZyb20gXCJAL2NvbmZpZy9jaXRpZXNcIjtcclxuXHJcbmludGVyZmFjZSBMb2NhdGlvblN0YXRlIHtcclxuICBjdXJyZW50Q2l0eTogYW55IHwgbnVsbDtcclxuICBpc0xvYWRpbmc6IGJvb2xlYW47XHJcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbiAgY2FuUmVudDogYm9vbGVhbjtcclxuICBuZWFyYnlWZWhpY2xlczogYW55W107XHJcbiAgbG9jYXRpb246IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsOyAvLyBUaGlzIGlzIGNvb3JkaW5hdGVzXHJcbiAgc2hvd0xvY2F0aW9uTW9kYWw6IGJvb2xlYW47XHJcbiAgbG9jYXRpb25NZXRob2Q6IFwiZ3BzXCIgfCBcIm1hbnVhbFwiIHwgXCJub25lXCI7XHJcbn1cclxuXHJcbi8vIEV4dGVuZGVkIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9uc1xyXG5pbnRlcmZhY2UgRXh0ZW5kZWRMb2NhdGlvblN0YXRlIGV4dGVuZHMgTG9jYXRpb25TdGF0ZSB7XHJcbiAgY29vcmRpbmF0ZXM6IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH0gfCBudWxsOyAvLyBBbGlhcyBmb3IgbG9jYXRpb25cclxuICByZWZyZXNoTG9jYXRpb246ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgc2V0VGVzdExvY2F0aW9uOiAoXHJcbiAgICBjaXR5SWQ6IFwicm9tZVwiIHwgXCJtaWxhblwiIHwgXCJwYXJpc1wiIHwgXCJiZXJsaW5cIiB8IFwibWFkcmlkXCJcclxuICApID0+IFByb21pc2U8dm9pZD47XHJcbiAgY2xlYXJMb2NhdGlvbjogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2F0aW9uQW5kQ2l0eSgpOiBFeHRlbmRlZExvY2F0aW9uU3RhdGUge1xyXG4gIGNvbnN0IFtsb2NhdGlvblN0YXRlLCBzZXRMb2NhdGlvblN0YXRlXSA9IHVzZVN0YXRlPExvY2F0aW9uU3RhdGU+KHtcclxuICAgIGN1cnJlbnRDaXR5OiBudWxsLFxyXG4gICAgaXNMb2FkaW5nOiB0cnVlLFxyXG4gICAgZXJyb3I6IG51bGwsXHJcbiAgICBjYW5SZW50OiBmYWxzZSxcclxuICAgIG5lYXJieVZlaGljbGVzOiBbXSxcclxuICAgIGxvY2F0aW9uOiBudWxsLFxyXG4gICAgc2hvd0xvY2F0aW9uTW9kYWw6IGZhbHNlLFxyXG4gICAgbG9jYXRpb25NZXRob2Q6IFwibm9uZVwiLFxyXG4gIH0pO1xyXG5cclxuICBjb25zdCBnZW9TeXN0ZW0gPSBuZXcgVmVoaWNsZUdlb2xvY2F0aW9uU3lzdGVtKCk7XHJcblxyXG4gIGNvbnN0IHJlZnJlc2hMb2NhdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHNldExvY2F0aW9uU3RhdGUoKHByZXYpID0+ICh7XHJcbiAgICAgIC4uLnByZXYsXHJcbiAgICAgIGlzTG9hZGluZzogdHJ1ZSxcclxuICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgIHNob3dMb2NhdGlvbk1vZGFsOiBmYWxzZSxcclxuICAgIH0pKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBsb2NhdGlvblN0YXRlUmVzdWx0ID0gYXdhaXQgZ2VvU3lzdGVtLmdldEN1cnJlbnRMb2NhdGlvblN0YXRlKCk7XHJcblxyXG4gICAgICAvLyBHZXQgZnJlc2ggY29vcmRpbmF0ZXMgZm9yIGxvY2F0aW9uIGZpZWxkXHJcbiAgICAgIGxldCBjb29yZGluYXRlczogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGZyZXNoTG9jYXRpb24gPSBhd2FpdCBnZW9TeXN0ZW0uZ2V0Q3VycmVudExvY2F0aW9uKCk7XHJcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBmcmVzaExvY2F0aW9uO1xyXG4gICAgICB9IGNhdGNoIChjb29yZEVycm9yKSB7XHJcbiAgICAgICAgLy8gSWYgY29vcmRpbmF0ZXMgZmFpbCwgdHJ5IHRvIHVzZSBjaXR5IGNvb3JkaW5hdGVzIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgaWYgKGxvY2F0aW9uU3RhdGVSZXN1bHQuY3VycmVudENpdHk/LmNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGxvY2F0aW9uU3RhdGVSZXN1bHQuY3VycmVudENpdHkuY29vcmRpbmF0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbG9jYXRpb24gbWV0aG9kIGJhc2VkIG9uIHRoZSByZXN1bHRcclxuICAgICAgbGV0IGxvY2F0aW9uTWV0aG9kOiBcImdwc1wiIHwgXCJtYW51YWxcIiB8IFwibm9uZVwiID0gXCJub25lXCI7XHJcbiAgICAgIGlmIChsb2NhdGlvblN0YXRlUmVzdWx0Lm1ldGhvZCA9PT0gXCJncHNcIikge1xyXG4gICAgICAgIGxvY2F0aW9uTWV0aG9kID0gbG9jYXRpb25TdGF0ZVJlc3VsdC5lcnJvciA/IFwibWFudWFsXCIgOiBcImdwc1wiOyAvLyBNYW51YWwgaWYgZmFsbGJhY2sgd2FzIHVzZWRcclxuICAgICAgfSBlbHNlIGlmIChsb2NhdGlvblN0YXRlUmVzdWx0Lm1ldGhvZCA9PT0gXCJtYW51YWxcIikge1xyXG4gICAgICAgIGxvY2F0aW9uTWV0aG9kID0gXCJtYW51YWxcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0TG9jYXRpb25TdGF0ZSgocHJldikgPT4gKHtcclxuICAgICAgICAuLi5wcmV2LFxyXG4gICAgICAgIGN1cnJlbnRDaXR5OiBsb2NhdGlvblN0YXRlUmVzdWx0LmN1cnJlbnRDaXR5LFxyXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6IGxvY2F0aW9uU3RhdGVSZXN1bHQuZXJyb3IsXHJcbiAgICAgICAgY2FuUmVudDogbG9jYXRpb25TdGF0ZVJlc3VsdC5jYW5SZW50LFxyXG4gICAgICAgIGxvY2F0aW9uOiBjb29yZGluYXRlcyxcclxuICAgICAgICBsb2NhdGlvbk1ldGhvZDogbG9jYXRpb25NZXRob2QsXHJcbiAgICAgICAgc2hvd0xvY2F0aW9uTW9kYWw6IGZhbHNlLFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICAvLyBEZXZlbG9wbWVudCBmYWxsYmFja1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJlxyXG4gICAgICAgICFsb2NhdGlvblN0YXRlUmVzdWx0LmNhblJlbnQgJiZcclxuICAgICAgICBsb2NhdGlvblN0YXRlUmVzdWx0LmVycm9yXHJcbiAgICAgICkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgXCLwn4+X77iPIERldmVsb3BtZW50IG1vZGU6IEF1dG8tc2V0dGluZyBSb21lIGFzIHRlc3QgbG9jYXRpb24uLi5cIlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB0ZXN0U3RhdGUgPSBhd2FpdCBnZW9TeXN0ZW0uc2V0VGVzdExvY2F0aW9uKFwicm9tZVwiKTtcclxuICAgICAgICAgIHNldExvY2F0aW9uU3RhdGUoKHByZXYpID0+ICh7XHJcbiAgICAgICAgICAgIC4uLnByZXYsXHJcbiAgICAgICAgICAgIGN1cnJlbnRDaXR5OiB0ZXN0U3RhdGUuY3VycmVudENpdHksXHJcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBgRGV2IG1vZGU6IFVzaW5nICR7dGVzdFN0YXRlLmN1cnJlbnRDaXR5Py5uYW1lfS4gT3JpZ2luYWwgZXJyb3I6ICR7bG9jYXRpb25TdGF0ZVJlc3VsdC5lcnJvcn1gLFxyXG4gICAgICAgICAgICBjYW5SZW50OiB0ZXN0U3RhdGUuY2FuUmVudCxcclxuICAgICAgICAgICAgbG9jYXRpb25NZXRob2Q6IFwibWFudWFsXCIsXHJcbiAgICAgICAgICAgIHNob3dMb2NhdGlvbk1vZGFsOiBmYWxzZSxcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9IGNhdGNoICh0ZXN0RXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUZXN0IGxvY2F0aW9uIGZhaWxlZDpcIiwgdGVzdEVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgc2V0TG9jYXRpb25TdGF0ZSgocHJldikgPT4gKHtcclxuICAgICAgICAuLi5wcmV2LFxyXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgXCJMb2NhdGlvbiBhY2Nlc3MgZmFpbGVkXCIsXHJcbiAgICAgICAgY2FuUmVudDogZmFsc2UsXHJcbiAgICAgICAgc2hvd0xvY2F0aW9uTW9kYWw6IHRydWUsIC8vIFNob3cgbW9kYWwgb24gZXJyb3JcclxuICAgICAgICBsb2NhdGlvbk1ldGhvZDogXCJub25lXCIsXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IHNldFRlc3RMb2NhdGlvbiA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKFxyXG4gICAgICBjaXR5SWQ6IFwicm9tZVwiIHwgXCJtaWxhblwiIHwgXCJwYXJpc1wiIHwgXCJiZXJsaW5cIiB8IFwibWFkcmlkXCJcclxuICAgICk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICBzZXRMb2NhdGlvblN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBpc0xvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdGVzdFN0YXRlID0gYXdhaXQgZ2VvU3lzdGVtLnNldFRlc3RMb2NhdGlvbihjaXR5SWQpO1xyXG5cclxuICAgICAgICAvLyBHZXQgY2l0eSBjb29yZGluYXRlc1xyXG4gICAgICAgIGNvbnN0IGNpdHlDb29yZGluYXRlcyA9IHRlc3RTdGF0ZS5jdXJyZW50Q2l0eT8uY29vcmRpbmF0ZXMgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgc2V0TG9jYXRpb25TdGF0ZSgocHJldikgPT4gKHtcclxuICAgICAgICAgIC4uLnByZXYsXHJcbiAgICAgICAgICBjdXJyZW50Q2l0eTogdGVzdFN0YXRlLmN1cnJlbnRDaXR5LFxyXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICAgICAgY2FuUmVudDogdGVzdFN0YXRlLmNhblJlbnQsXHJcbiAgICAgICAgICBsb2NhdGlvbjogY2l0eUNvb3JkaW5hdGVzLFxyXG4gICAgICAgICAgbG9jYXRpb25NZXRob2Q6IFwibWFudWFsXCIsXHJcbiAgICAgICAgICBzaG93TG9jYXRpb25Nb2RhbDogZmFsc2UsXHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+nqiBUZXN0IGxvY2F0aW9uIHNldDogJHtjaXR5SWR9YCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICBzZXRMb2NhdGlvblN0YXRlKChwcmV2KSA9PiAoe1xyXG4gICAgICAgICAgLi4ucHJldixcclxuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICAgIGxvY2F0aW9uTWV0aG9kOiBcIm5vbmVcIixcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbXVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGNsZWFyTG9jYXRpb24gPSB1c2VDYWxsYmFjaygoKTogdm9pZCA9PiB7XHJcbiAgICBnZW9TeXN0ZW0uY2xlYXJMb2NhdGlvbkNhY2hlKCk7XHJcbiAgICBzZXRMb2NhdGlvblN0YXRlKHtcclxuICAgICAgY3VycmVudENpdHk6IG51bGwsXHJcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICBjYW5SZW50OiBmYWxzZSxcclxuICAgICAgbmVhcmJ5VmVoaWNsZXM6IFtdLFxyXG4gICAgICBsb2NhdGlvbjogbnVsbCxcclxuICAgICAgc2hvd0xvY2F0aW9uTW9kYWw6IGZhbHNlLFxyXG4gICAgICBsb2NhdGlvbk1ldGhvZDogXCJub25lXCIsXHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKFwi8J+Xke+4jyBMb2NhdGlvbiBjbGVhcmVkXCIpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBvbiBtb3VudFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBsZXQgbW91bnRlZCA9IHRydWU7XHJcblxyXG4gICAgY29uc3QgaW5pdGlhbGl6ZSA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgICAgaWYgKCFtb3VudGVkKSByZXR1cm47XHJcbiAgICAgIGF3YWl0IHJlZnJlc2hMb2NhdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbml0aWFsaXplKCk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgbW91bnRlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICB9LCBbcmVmcmVzaExvY2F0aW9uXSk7XHJcblxyXG4gIC8vIFJldHVybiBleHRlbmRlZCBzdGF0ZSB3aXRoIGJvdGggbG9jYXRpb24gYW5kIGNvb3JkaW5hdGVzIChzYW1lIHZhbHVlKVxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5sb2NhdGlvblN0YXRlLFxyXG4gICAgY29vcmRpbmF0ZXM6IGxvY2F0aW9uU3RhdGUubG9jYXRpb24sIC8vIEFsaWFzIGZvciBjb21wYXRpYmlsaXR5XHJcbiAgICByZWZyZXNoTG9jYXRpb24sXHJcbiAgICBzZXRUZXN0TG9jYXRpb24sXHJcbiAgICBjbGVhckxvY2F0aW9uLFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0iLCJ1c2VMb2NhdGlvbkFuZENpdHkiLCJsb2NhdGlvblN0YXRlIiwic2V0TG9jYXRpb25TdGF0ZSIsImN1cnJlbnRDaXR5IiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJjYW5SZW50IiwibmVhcmJ5VmVoaWNsZXMiLCJsb2NhdGlvbiIsInNob3dMb2NhdGlvbk1vZGFsIiwibG9jYXRpb25NZXRob2QiLCJnZW9TeXN0ZW0iLCJyZWZyZXNoTG9jYXRpb24iLCJwcmV2IiwibG9jYXRpb25TdGF0ZVJlc3VsdCIsImdldEN1cnJlbnRMb2NhdGlvblN0YXRlIiwiY29vcmRpbmF0ZXMiLCJmcmVzaExvY2F0aW9uIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwiY29vcmRFcnJvciIsIm1ldGhvZCIsInByb2Nlc3MiLCJjb25zb2xlIiwibG9nIiwidGVzdFN0YXRlIiwic2V0VGVzdExvY2F0aW9uIiwibmFtZSIsInRlc3RFcnJvciIsIm1lc3NhZ2UiLCJjaXR5SWQiLCJjaXR5Q29vcmRpbmF0ZXMiLCJjbGVhckxvY2F0aW9uIiwiY2xlYXJMb2NhdGlvbkNhY2hlIiwibW91bnRlZCIsImluaXRpYWxpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useLocationAndCity.ts\n"));

/***/ })

});