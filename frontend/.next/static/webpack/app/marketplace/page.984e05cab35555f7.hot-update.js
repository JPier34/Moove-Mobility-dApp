"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/marketplace/page",{

/***/ "(app-pages-browser)/./utils/vehicleGeoLocation.ts":
/*!*************************************!*\
  !*** ./utils/vehicleGeoLocation.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VehicleGeolocationSystem: function() { return /* binding */ VehicleGeolocationSystem; },\n/* harmony export */   formatDistance: function() { return /* binding */ formatDistance; },\n/* harmony export */   getBatteryColor: function() { return /* binding */ getBatteryColor; },\n/* harmony export */   getVehicleEmoji: function() { return /* binding */ getVehicleEmoji; }\n/* harmony export */ });\n/* harmony import */ var _config_cities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/config/cities */ \"(app-pages-browser)/./config/cities.ts\");\n\n// ============= CONSTANTS =============\nconst GEOLOCATION_OPTIONS = {\n    enableHighAccuracy: false,\n    timeout: 10000,\n    maximumAge: 300000\n};\nconst STORAGE_KEY = \"moove_city_location\";\nconst CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\nclass VehicleGeolocationSystem {\n    static getInstance() {\n        if (!VehicleGeolocationSystem.instance) {\n            VehicleGeolocationSystem.instance = new VehicleGeolocationSystem();\n            VehicleGeolocationSystem.instance.initializeVehicleFleet();\n        }\n        return VehicleGeolocationSystem.instance;\n    }\n    // ============= PERSISTENT LOCATION MANAGEMENT =============\n    saveLocationToStorage(state) {\n        try {\n            if ( true && window.sessionStorage) {\n                sessionStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n            }\n        } catch (error) {\n            console.warn(\"Failed to save location:\", error);\n        }\n    }\n    loadLocationFromStorage() {\n        try {\n            if ( false || !window.sessionStorage) {\n                return null;\n            }\n            const stored = sessionStorage.getItem(STORAGE_KEY);\n            if (!stored) return null;\n            const data = JSON.parse(stored);\n            const now = Date.now();\n            // Check if cache is still valid\n            if (now - data.lastUpdated > CACHE_DURATION) {\n                sessionStorage.removeItem(STORAGE_KEY);\n                return null;\n            }\n            return data;\n        } catch (error) {\n            console.warn(\"Failed to load location:\", error);\n            return null;\n        }\n    }\n    // ============= MAIN LOCATION METHODS =============\n    /**\r\n   * Get current user location with caching\r\n   */ async getCurrentLocation() {\n        // Try cache first for LocationCoordinates compatibility\n        const cached = this.loadLocationFromStorage();\n        if (cached && cached.currentCity) {\n            console.log(\"Using cached location\");\n            return cached.currentCity.coordinates;\n        }\n        // Get fresh location\n        if (!navigator.geolocation) {\n            throw new Error(\"Geolocation is not supported by this browser\");\n        }\n        return new Promise((resolve, reject)=>{\n            navigator.geolocation.getCurrentPosition((position)=>{\n                const coordinates = {\n                    lat: position.coords.latitude,\n                    lng: position.coords.longitude\n                };\n                // Find and cache nearest city\n                const nearestCity = this.findNearestSupportedCity(coordinates);\n                this.saveLocationState(coordinates, nearestCity);\n                resolve(coordinates);\n            }, (error)=>{\n                let message;\n                switch(error.code){\n                    case error.PERMISSION_DENIED:\n                        message = \"Location access denied. Please enable location services.\";\n                        break;\n                    case error.POSITION_UNAVAILABLE:\n                        message = \"Location information unavailable.\";\n                        break;\n                    case error.TIMEOUT:\n                        message = \"Location request timed out.\";\n                        break;\n                    default:\n                        message = \"Unknown location error.\";\n                }\n                reject(new Error(message));\n            }, GEOLOCATION_OPTIONS);\n        });\n    }\n    /**\r\n   * Get current location state (new method for compatibility)\r\n   */ async getCurrentLocationState() {\n        // Try cache first\n        const cached = this.loadLocationFromStorage();\n        if (cached) {\n            console.log(\"Using cached location state\");\n            return cached;\n        }\n        // Get fresh location\n        try {\n            const coordinates = await this.getCurrentLocation();\n            const nearestCity = this.findNearestSupportedCity(coordinates);\n            return this.saveLocationState(coordinates, nearestCity);\n        } catch (error) {\n            return {\n                currentCity: null,\n                isLoading: false,\n                error: error.message,\n                canRent: false,\n                lastUpdated: Date.now(),\n                method: \"gps\"\n            };\n        }\n    }\n    saveLocationState(coordinates, nearestCity) {\n        const state = {\n            currentCity: nearestCity,\n            isLoading: false,\n            error: null,\n            canRent: !!nearestCity,\n            lastUpdated: Date.now(),\n            method: \"gps\"\n        };\n        this.saveLocationToStorage(state);\n        return state;\n    }\n    findNearestSupportedCity(coordinates) {\n        let nearestCity = null;\n        let minDistance = Infinity;\n        for (const city of _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES){\n            const { bounds } = city;\n            // Check if inside city bounds first\n            if (coordinates.lat >= bounds.south && coordinates.lat <= bounds.north && coordinates.lng >= bounds.west && coordinates.lng <= bounds.east) {\n                return city; // Inside city, return immediately\n            }\n            // Calculate distance to city center\n            const distance = this.calculateDistance(coordinates.lat, coordinates.lng, city.coordinates.lat, city.coordinates.lng);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearestCity = city;\n            }\n        }\n        // Only return city if within reasonable distance (100km)\n        return minDistance <= 200 ? nearestCity : null;\n    }\n    /**\r\n   * Check if user is in a supported city\r\n   */ checkCitySupport(location) {\n        // Check if user is within any supported city bounds\n        for (const city of _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES){\n            const { bounds } = city;\n            if (location.lat >= bounds.south && location.lat <= bounds.north && location.lng >= bounds.west && location.lng <= bounds.east) {\n                return {\n                    inCity: true,\n                    cityName: city.id,\n                    distance: 0\n                };\n            }\n        }\n        // User is not in a supported city, find nearest one\n        const distances = _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.map((city)=>({\n                city: city.id,\n                name: city.name,\n                distance: this.calculateDistance(location.lat, location.lng, city.coordinates.lat, city.coordinates.lng)\n            }));\n        const nearest = distances.reduce((min, curr)=>curr.distance < min.distance ? curr : min);\n        return {\n            inCity: false,\n            distance: nearest.distance,\n            nearestCity: nearest.name\n        };\n    }\n    // ============= DEVELOPMENT/TESTING METHODS =============\n    /**\r\n   * Set manual location for testing\r\n   */ async setTestLocation(cityId) {\n        const city = _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.find((c)=>c.id === cityId);\n        if (!city) {\n            throw new Error(\"City \".concat(cityId, \" not found\"));\n        }\n        const state = {\n            currentCity: city,\n            isLoading: false,\n            error: null,\n            canRent: true,\n            lastUpdated: Date.now(),\n            method: \"manual\"\n        };\n        this.saveLocationToStorage(state);\n        console.log(\"\\uD83E\\uDDEA Test location set: \".concat(city.name));\n        return state;\n    }\n    /**\r\n   * Clear location cache\r\n   */ clearLocationCache() {\n        try {\n            if ( true && window.sessionStorage) {\n                sessionStorage.removeItem(STORAGE_KEY);\n            }\n            console.log(\"Location cache cleared\");\n        } catch (error) {\n            console.warn(\"Failed to clear location:\", error);\n        }\n    }\n    /**\r\n   * Check location permission (for compatibility)\r\n   */ async checkLocationPermission() {\n        if (!navigator.permissions) {\n            return \"prompt\";\n        }\n        try {\n            const permission = await navigator.permissions.query({\n                name: \"geolocation\"\n            });\n            return permission.state;\n        } catch (error) {\n            console.warn(\"Could not check location permission:\", error);\n            return \"prompt\";\n        }\n    }\n    // ============= NEARBY VEHICLES METHODS (existing functionality) =============\n    /**\r\n   * Get nearby vehicles within specified radius\r\n   */ async getNearbyVehicles(location) {\n        let radiusKm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2, vehicleType = arguments.length > 2 ? arguments[2] : void 0, onlyAvailable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n        // Simulate API delay\n        await new Promise((resolve)=>setTimeout(resolve, 300));\n        const nearbyVehicles = [];\n        this.vehicleLocations.forEach((vehicle)=>{\n            // Filter by availability if requested\n            if (onlyAvailable && !vehicle.isAvailable) return;\n            // Filter by vehicle type if specified\n            if (vehicleType && vehicle.vehicleType !== vehicleType) return;\n            const distance = this.calculateDistance(location.lat, location.lng, vehicle.coordinates.lat, vehicle.coordinates.lng);\n            if (distance <= radiusKm) {\n                nearbyVehicles.push({\n                    vehicleId: vehicle.vehicleId,\n                    vehicleType: vehicle.vehicleType,\n                    location: {\n                        lat: vehicle.coordinates.lat,\n                        lng: vehicle.coordinates.lng\n                    },\n                    distance,\n                    batteryLevel: vehicle.batteryLevel,\n                    estimatedRange: vehicle.estimatedRange,\n                    isAvailable: vehicle.isAvailable,\n                    lastUpdate: vehicle.lastUpdate,\n                    cityId: vehicle.cityId\n                });\n            }\n        });\n        // Sort by distance\n        return nearbyVehicles.sort((a, b)=>a.distance - b.distance);\n    }\n    // Get vehicles near user location\n    getVehiclesNearLocation(userLat, userLng) {\n        let radiusKm = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2, vehicleType = arguments.length > 3 ? arguments[3] : void 0;\n        const nearbyVehicles = [];\n        this.vehicleLocations.forEach((vehicle)=>{\n            if (!vehicle.isAvailable) return;\n            if (vehicleType && vehicle.vehicleType !== vehicleType) return;\n            const distance = this.calculateDistance(userLat, userLng, vehicle.coordinates.lat, vehicle.coordinates.lng);\n            if (distance <= radiusKm) {\n                nearbyVehicles.push({\n                    ...vehicle,\n                    distance\n                });\n            }\n        });\n        return nearbyVehicles.sort((a, b)=>a.distance - b.distance);\n    }\n    // Get vehicles in specific city\n    getVehiclesInCity(cityId, vehicleType) {\n        const cityVehicles = [];\n        this.vehicleLocations.forEach((vehicle)=>{\n            if (vehicle.cityId !== cityId) return;\n            if (!vehicle.isAvailable) return;\n            if (vehicleType && vehicle.vehicleType !== vehicleType) return;\n            cityVehicles.push(vehicle);\n        });\n        return cityVehicles;\n    }\n    // ============= UTILITY METHODS =============\n    calculateDistance(lat1, lng1, lat2, lng2) {\n        const R = 6371; // Earth's radius in kilometers\n        const dLat = this.toRadians(lat2 - lat1);\n        const dLng = this.toRadians(lng2 - lng1);\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n    toRadians(degrees) {\n        return degrees * (Math.PI / 180);\n    }\n    // ============= VEHICLE FLEET METHODS (existing) =============\n    initializeVehicleFleet() {\n        _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.forEach((city)=>{\n            Object.entries(city.vehicleLimit).forEach((param)=>{\n                let [vehicleType, limit] = param;\n                if (limit > 0 && city.allowedVehicles.includes(vehicleType)) {\n                    for(let i = 0; i < limit; i++){\n                        const vehicleId = this.generateVehicleId(city.id, vehicleType, i);\n                        const location = this.generateRandomLocationInCity(city);\n                        this.vehicleLocations.set(vehicleId, {\n                            vehicleId,\n                            vehicleType: vehicleType,\n                            cityId: city.id,\n                            coordinates: location,\n                            batteryLevel: Math.floor(Math.random() * 40) + 60,\n                            isAvailable: Math.random() > 0.15,\n                            lastUpdate: new Date(),\n                            estimatedRange: this.calculateRange(vehicleType)\n                        });\n                    }\n                }\n            });\n        });\n    }\n    generateVehicleId(cityId, vehicleType, index) {\n        const typeCode = {\n            bike: \"BK\",\n            scooter: \"SC\",\n            monopattino: \"MP\"\n        }[vehicleType];\n        const cityCode = cityId.substring(0, 3).toUpperCase();\n        return \"MOOVE-\".concat(cityCode, \"-\").concat(typeCode, \"-\").concat((index + 1).toString().padStart(3, \"0\"));\n    }\n    generateRandomLocationInCity(city) {\n        const latRange = city.bounds.north - city.bounds.south;\n        const lngRange = city.bounds.east - city.bounds.west;\n        return {\n            lat: city.bounds.south + Math.random() * latRange,\n            lng: city.bounds.west + Math.random() * lngRange\n        };\n    }\n    calculateRange(vehicleType) {\n        const ranges = {\n            bike: [\n                25,\n                50\n            ],\n            scooter: [\n                30,\n                60\n            ],\n            monopattino: [\n                15,\n                35\n            ]\n        };\n        const [min, max] = ranges[vehicleType];\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    // Vehicle management methods (existing)\n    reserveVehicle(vehicleId) {\n        const vehicle = this.vehicleLocations.get(vehicleId);\n        if (vehicle && vehicle.isAvailable) {\n            vehicle.isAvailable = false;\n            vehicle.lastUpdate = new Date();\n            return true;\n        }\n        return false;\n    }\n    releaseVehicle(vehicleId, newLocation) {\n        const vehicle = this.vehicleLocations.get(vehicleId);\n        if (vehicle) {\n            vehicle.isAvailable = true;\n            vehicle.lastUpdate = new Date();\n            if (newLocation) {\n                vehicle.coordinates = newLocation;\n            }\n            vehicle.batteryLevel = Math.max(0, vehicle.batteryLevel - Math.floor(Math.random() * 20));\n        }\n    }\n    getVehicle(vehicleId) {\n        return this.vehicleLocations.get(vehicleId);\n    }\n    getAllVehicles() {\n        return Array.from(this.vehicleLocations.values());\n    }\n    updateVehicleLocation(vehicleId, newLocation) {\n        const vehicle = this.vehicleLocations.get(vehicleId);\n        if (vehicle) {\n            vehicle.coordinates = newLocation;\n            vehicle.lastUpdate = new Date();\n        }\n    }\n    constructor(){\n        this.vehicleLocations = new Map();\n        if (!this.vehicleLocations.size) {\n            this.initializeVehicleFleet();\n        }\n    }\n}\n// ============= HELPER FUNCTIONS (existing) =============\nfunction formatDistance(distanceKm) {\n    if (distanceKm < 0.1) {\n        return \"Very close\";\n    } else if (distanceKm < 1) {\n        return \"\".concat(Math.round(distanceKm * 1000), \"m\");\n    } else {\n        return \"\".concat(distanceKm.toFixed(1), \"km\");\n    }\n}\nfunction getBatteryColor(level) {\n    if (level > 70) return \"text-green-600\";\n    if (level > 30) return \"text-yellow-600\";\n    return \"text-red-600\";\n}\nfunction getVehicleEmoji(type) {\n    switch(type){\n        case \"bike\":\n            return \"\\uD83D\\uDEB2\";\n        case \"scooter\":\n            return \"\\uD83D\\uDEF4\";\n        case \"monopattino\":\n            return \"\\uD83D\\uDEF5\";\n        default:\n            return \"\\uD83D\\uDEB2\";\n    }\n}\n// Export default for compatibility\n/* harmony default export */ __webpack_exports__[\"default\"] = (VehicleGeolocationSystem);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3ZlaGljbGVHZW9Mb2NhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNrRDtBQXFEbEQsd0NBQXdDO0FBQ3hDLE1BQU1DLHNCQUF1QztJQUMzQ0Msb0JBQW9CO0lBQ3BCQyxTQUFTO0lBQ1RDLFlBQVk7QUFDZDtBQUVBLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsaUJBQWlCLEtBQUssS0FBSyxNQUFNLGFBQWE7QUFFN0MsTUFBTUM7SUFJWCxPQUFPQyxjQUF3QztRQUM3QyxJQUFJLENBQUNELHlCQUF5QkUsUUFBUSxFQUFFO1lBQ3RDRix5QkFBeUJFLFFBQVEsR0FBRyxJQUFJRjtZQUN4Q0EseUJBQXlCRSxRQUFRLENBQUNDLHNCQUFzQjtRQUMxRDtRQUNBLE9BQU9ILHlCQUF5QkUsUUFBUTtJQUMxQztJQVFBLDZEQUE2RDtJQUVyREUsc0JBQXNCQyxLQUEwQixFQUFRO1FBQzlELElBQUk7WUFDRixJQUFJLEtBQTZCLElBQUlDLE9BQU9DLGNBQWMsRUFBRTtnQkFDMURBLGVBQWVDLE9BQU8sQ0FBQ1YsYUFBYVcsS0FBS0MsU0FBUyxDQUFDTDtZQUNyRDtRQUNGLEVBQUUsT0FBT00sT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsNEJBQTRCRjtRQUMzQztJQUNGO0lBRVFHLDBCQUFzRDtRQUM1RCxJQUFJO1lBQ0YsSUFBSSxNQUE2QixJQUFJLENBQUNSLE9BQU9DLGNBQWMsRUFBRTtnQkFDM0QsT0FBTztZQUNUO1lBRUEsTUFBTVEsU0FBU1IsZUFBZVMsT0FBTyxDQUFDbEI7WUFDdEMsSUFBSSxDQUFDaUIsUUFBUSxPQUFPO1lBRXBCLE1BQU1FLE9BQU9SLEtBQUtTLEtBQUssQ0FBQ0g7WUFDeEIsTUFBTUksTUFBTUMsS0FBS0QsR0FBRztZQUVwQixnQ0FBZ0M7WUFDaEMsSUFBSUEsTUFBTUYsS0FBS0ksV0FBVyxHQUFHdEIsZ0JBQWdCO2dCQUMzQ1EsZUFBZWUsVUFBVSxDQUFDeEI7Z0JBQzFCLE9BQU87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LG1DQUFtQztBQUNuQywrREFBZXpLLHdCQUF3QkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy92ZWhpY2xlR2VvTG9jYXRpb24udHM/NTlmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWhpY2xlVHlwZSB9IGZyb20gXCJAL2NvbmZpZy9jaXRpZXNcIjtcclxuaW1wb3J0IHsgRVVST1BFQU5fQ0lUSUVTIH0gZnJvbSBcIkAvY29uZmlnL2NpdGllc1wiO1xyXG5pbXBvcnQgeyBDaXR5Q29uZmlnIH0gZnJvbSBcIkAvY29uZmlnL2NpdGllc1wiO1xyXG5cclxuLy8gPT09PT09PT09PT09PSBUWVBFUyAoa2VlcCBleGlzdGluZyBpbnRlcmZhY2VzIGZvciBjb21wYXRpYmlsaXR5KSA9PT09PT09PT09PT09XHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb25Db29yZGluYXRlcyB7XHJcbiAgbGF0OiBudW1iZXI7XHJcbiAgbG5nOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2l0eVN1cHBvcnQge1xyXG4gIGluQ2l0eTogYm9vbGVhbjtcclxuICBjaXR5TmFtZT86IHN0cmluZztcclxuICBkaXN0YW5jZT86IG51bWJlcjtcclxuICBuZWFyZXN0Q2l0eT86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOZWFyYnlWZWhpY2xlIHtcclxuICB2ZWhpY2xlSWQ6IHN0cmluZztcclxuICB2ZWhpY2xlVHlwZTogVmVoaWNsZVR5cGU7XHJcbiAgbG9jYXRpb246IExvY2F0aW9uQ29vcmRpbmF0ZXM7XHJcbiAgZGlzdGFuY2U6IG51bWJlcjtcclxuICBiYXR0ZXJ5TGV2ZWw6IG51bWJlcjtcclxuICBlc3RpbWF0ZWRSYW5nZTogbnVtYmVyO1xyXG4gIGlzQXZhaWxhYmxlOiBib29sZWFuO1xyXG4gIGxhc3RVcGRhdGU6IERhdGU7XHJcbiAgY2l0eUlkOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIE5ldyBzaW1wbGlmaWVkIHN0YXRlIGludGVyZmFjZVxyXG5pbnRlcmZhY2UgTG9jYXRpb25TdGF0ZVJlc3VsdCB7XHJcbiAgY3VycmVudENpdHk6IGFueSB8IG51bGw7XHJcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xyXG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xyXG4gIGNhblJlbnQ6IGJvb2xlYW47XHJcbiAgbGFzdFVwZGF0ZWQ6IG51bWJlcjtcclxuICBtZXRob2Q6IFwiZ3BzXCIgfCBcIm1hbnVhbFwiIHwgXCJjYWNoZWRcIjtcclxufVxyXG5cclxuLy8gVmVoaWNsZSBsb2NhdGlvbiBpbnRlcmZhY2UgKGZvciBmbGVldCBtYW5hZ2VtZW50KVxyXG5pbnRlcmZhY2UgVmVoaWNsZUxvY2F0aW9uIHtcclxuICB2ZWhpY2xlSWQ6IHN0cmluZztcclxuICB2ZWhpY2xlVHlwZTogVmVoaWNsZVR5cGU7XHJcbiAgY2l0eUlkOiBzdHJpbmc7XHJcbiAgY29vcmRpbmF0ZXM6IHtcclxuICAgIGxhdDogbnVtYmVyO1xyXG4gICAgbG5nOiBudW1iZXI7XHJcbiAgfTtcclxuICBiYXR0ZXJ5TGV2ZWw6IG51bWJlcjtcclxuICBpc0F2YWlsYWJsZTogYm9vbGVhbjtcclxuICBsYXN0VXBkYXRlOiBEYXRlO1xyXG4gIGVzdGltYXRlZFJhbmdlOiBudW1iZXI7XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT0gQ09OU1RBTlRTID09PT09PT09PT09PT1cclxuY29uc3QgR0VPTE9DQVRJT05fT1BUSU9OUzogUG9zaXRpb25PcHRpb25zID0ge1xyXG4gIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2UsIC8vIExlc3MgcmVzb3VyY2UgaW50ZW5zaXZlXHJcbiAgdGltZW91dDogMTAwMDAsIC8vIDEwIHNlY29uZHNcclxuICBtYXhpbXVtQWdlOiAzMDAwMDAsIC8vIDUgbWludXRlcyBjYWNoZVxyXG59O1xyXG5cclxuY29uc3QgU1RPUkFHRV9LRVkgPSBcIm1vb3ZlX2NpdHlfbG9jYXRpb25cIjtcclxuY29uc3QgQ0FDSEVfRFVSQVRJT04gPSAzMCAqIDYwICogMTAwMDsgLy8gMzAgbWludXRlc1xyXG5cclxuZXhwb3J0IGNsYXNzIFZlaGljbGVHZW9sb2NhdGlvblN5c3RlbSB7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFZlaGljbGVHZW9sb2NhdGlvblN5c3RlbTtcclxuICBwcml2YXRlIHZlaGljbGVMb2NhdGlvbnM6IE1hcDxzdHJpbmcsIFZlaGljbGVMb2NhdGlvbj4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0ge1xyXG4gICAgaWYgKCFWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0uaW5zdGFuY2UpIHtcclxuICAgICAgVmVoaWNsZUdlb2xvY2F0aW9uU3lzdGVtLmluc3RhbmNlID0gbmV3IFZlaGljbGVHZW9sb2NhdGlvblN5c3RlbSgpO1xyXG4gICAgICBWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0uaW5zdGFuY2UuaW5pdGlhbGl6ZVZlaGljbGVGbGVldCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFZlaGljbGVHZW9sb2NhdGlvblN5c3RlbS5pbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgaWYgKCF0aGlzLnZlaGljbGVMb2NhdGlvbnMuc2l6ZSkge1xyXG4gICAgICB0aGlzLmluaXRpYWxpemVWZWhpY2xlRmxlZXQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT0gUEVSU0lTVEVOVCBMT0NBVElPTiBNQU5BR0VNRU5UID09PT09PT09PT09PT1cclxuXHJcbiAgcHJpdmF0ZSBzYXZlTG9jYXRpb25Ub1N0b3JhZ2Uoc3RhdGU6IExvY2F0aW9uU3RhdGVSZXN1bHQpOiB2b2lkIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZSkge1xyXG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzYXZlIGxvY2F0aW9uOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGxvYWRMb2NhdGlvbkZyb21TdG9yYWdlKCk6IExvY2F0aW9uU3RhdGVSZXN1bHQgfCBudWxsIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICF3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc3RvcmVkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSk7XHJcbiAgICAgIGlmICghc3RvcmVkKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHN0b3JlZCkgYXMgTG9jYXRpb25TdGF0ZVJlc3VsdDtcclxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGNhY2hlIGlzIHN0aWxsIHZhbGlkXHJcbiAgICAgIGlmIChub3cgLSBkYXRhLmxhc3RVcGRhdGVkID4gQ0FDSEVfRFVSQVRJT04pIHtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gbG9hZCBsb2NhdGlvbjpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT0gTUFJTiBMT0NBVElPTiBNRVRIT0RTID09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgdXNlciBsb2NhdGlvbiB3aXRoIGNhY2hpbmdcclxuICAgKi9cclxuICBhc3luYyBnZXRDdXJyZW50TG9jYXRpb24oKTogUHJvbWlzZTxMb2NhdGlvbkNvb3JkaW5hdGVzPiB7XHJcbiAgICAvLyBUcnkgY2FjaGUgZmlyc3QgZm9yIExvY2F0aW9uQ29vcmRpbmF0ZXMgY29tcGF0aWJpbGl0eVxyXG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5sb2FkTG9jYXRpb25Gcm9tU3RvcmFnZSgpO1xyXG4gICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuY3VycmVudENpdHkpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJVc2luZyBjYWNoZWQgbG9jYXRpb25cIik7XHJcbiAgICAgIHJldHVybiBjYWNoZWQuY3VycmVudENpdHkuY29vcmRpbmF0ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IGZyZXNoIGxvY2F0aW9uXHJcbiAgICBpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW9sb2NhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8TG9jYXRpb25Db29yZGluYXRlcz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKFxyXG4gICAgICAgIChwb3NpdGlvbikgPT4ge1xyXG4gICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXM6IExvY2F0aW9uQ29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICAgIGxhdDogcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsbmc6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIEZpbmQgYW5kIGNhY2hlIG5lYXJlc3QgY2l0eVxyXG4gICAgICAgICAgY29uc3QgbmVhcmVzdENpdHkgPSB0aGlzLmZpbmROZWFyZXN0U3VwcG9ydGVkQ2l0eShjb29yZGluYXRlcyk7XHJcbiAgICAgICAgICB0aGlzLnNhdmVMb2NhdGlvblN0YXRlKGNvb3JkaW5hdGVzLCBuZWFyZXN0Q2l0eSk7XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShjb29yZGluYXRlcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAoZXJyb3IpID0+IHtcclxuICAgICAgICAgIGxldCBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBlcnJvci5QRVJNSVNTSU9OX0RFTklFRDpcclxuICAgICAgICAgICAgICBtZXNzYWdlID1cclxuICAgICAgICAgICAgICAgIFwiTG9jYXRpb24gYWNjZXNzIGRlbmllZC4gUGxlYXNlIGVuYWJsZSBsb2NhdGlvbiBzZXJ2aWNlcy5cIjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBlcnJvci5QT1NJVElPTl9VTkFWQUlMQUJMRTpcclxuICAgICAgICAgICAgICBtZXNzYWdlID0gXCJMb2NhdGlvbiBpbmZvcm1hdGlvbiB1bmF2YWlsYWJsZS5cIjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBlcnJvci5USU1FT1VUOlxyXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkxvY2F0aW9uIHJlcXVlc3QgdGltZWQgb3V0LlwiO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlVua25vd24gbG9jYXRpb24gZXJyb3IuXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKG1lc3NhZ2UpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEdFT0xPQ0FUSU9OX09QVElPTlNcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgbG9jYXRpb24gc3RhdGUgKG5ldyBtZXRob2QgZm9yIGNvbXBhdGliaWxpdHkpXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0Q3VycmVudExvY2F0aW9uU3RhdGUoKTogUHJvbWlzZTxMb2NhdGlvblN0YXRlUmVzdWx0PiB7XHJcbiAgICAvLyBUcnkgY2FjaGUgZmlyc3RcclxuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMubG9hZExvY2F0aW9uRnJvbVN0b3JhZ2UoKTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJVc2luZyBjYWNoZWQgbG9jYXRpb24gc3RhdGVcIik7XHJcbiAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IGZyZXNoIGxvY2F0aW9uXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uKCk7XHJcbiAgICAgIGNvbnN0IG5lYXJlc3RDaXR5ID0gdGhpcy5maW5kTmVhcmVzdFN1cHBvcnRlZENpdHkoY29vcmRpbmF0ZXMpO1xyXG4gICAgICByZXR1cm4gdGhpcy5zYXZlTG9jYXRpb25TdGF0ZShjb29yZGluYXRlcywgbmVhcmVzdENpdHkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGN1cnJlbnRDaXR5OiBudWxsLFxyXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgY2FuUmVudDogZmFsc2UsXHJcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXHJcbiAgICAgICAgbWV0aG9kOiBcImdwc1wiLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzYXZlTG9jYXRpb25TdGF0ZShcclxuICAgIGNvb3JkaW5hdGVzOiBMb2NhdGlvbkNvb3JkaW5hdGVzLFxyXG4gICAgbmVhcmVzdENpdHk6IGFueSB8IG51bGxcclxuICApOiBMb2NhdGlvblN0YXRlUmVzdWx0IHtcclxuICAgIGNvbnN0IHN0YXRlOiBMb2NhdGlvblN0YXRlUmVzdWx0ID0ge1xyXG4gICAgICBjdXJyZW50Q2l0eTogbmVhcmVzdENpdHksXHJcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICBjYW5SZW50OiAhIW5lYXJlc3RDaXR5LFxyXG4gICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKSxcclxuICAgICAgbWV0aG9kOiBcImdwc1wiLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNhdmVMb2NhdGlvblRvU3RvcmFnZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGZpbmROZWFyZXN0U3VwcG9ydGVkQ2l0eShcclxuICAgIGNvb3JkaW5hdGVzOiBMb2NhdGlvbkNvb3JkaW5hdGVzXHJcbiAgKTogYW55IHwgbnVsbCB7XHJcbiAgICBsZXQgbmVhcmVzdENpdHkgPSBudWxsO1xyXG4gICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XHJcblxyXG4gICAgZm9yIChjb25zdCBjaXR5IG9mIEVVUk9QRUFOX0NJVElFUykge1xyXG4gICAgICBjb25zdCB7IGJvdW5kcyB9ID0gY2l0eTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGluc2lkZSBjaXR5IGJvdW5kcyBmaXJzdFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY29vcmRpbmF0ZXMubGF0ID49IGJvdW5kcy5zb3V0aCAmJlxyXG4gICAgICAgIGNvb3JkaW5hdGVzLmxhdCA8PSBib3VuZHMubm9ydGggJiZcclxuICAgICAgICBjb29yZGluYXRlcy5sbmcgPj0gYm91bmRzLndlc3QgJiZcclxuICAgICAgICBjb29yZGluYXRlcy5sbmcgPD0gYm91bmRzLmVhc3RcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIGNpdHk7IC8vIEluc2lkZSBjaXR5LCByZXR1cm4gaW1tZWRpYXRlbHlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIHRvIGNpdHkgY2VudGVyXHJcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcclxuICAgICAgICBjb29yZGluYXRlcy5sYXQsXHJcbiAgICAgICAgY29vcmRpbmF0ZXMubG5nLFxyXG4gICAgICAgIGNpdHkuY29vcmRpbmF0ZXMubGF0LFxyXG4gICAgICAgIGNpdHkuY29vcmRpbmF0ZXMubG5nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xyXG4gICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgbmVhcmVzdENpdHkgPSBjaXR5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25seSByZXR1cm4gY2l0eSBpZiB3aXRoaW4gcmVhc29uYWJsZSBkaXN0YW5jZSAoMTAwa20pXHJcbiAgICByZXR1cm4gbWluRGlzdGFuY2UgPD0gMjAwID8gbmVhcmVzdENpdHkgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdXNlciBpcyBpbiBhIHN1cHBvcnRlZCBjaXR5XHJcbiAgICovXHJcbiAgY2hlY2tDaXR5U3VwcG9ydChsb2NhdGlvbjogTG9jYXRpb25Db29yZGluYXRlcyk6IENpdHlTdXBwb3J0IHtcclxuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgd2l0aGluIGFueSBzdXBwb3J0ZWQgY2l0eSBib3VuZHNcclxuICAgIGZvciAoY29uc3QgY2l0eSBvZiBFVVJPUEVBTl9DSVRJRVMpIHtcclxuICAgICAgY29uc3QgeyBib3VuZHMgfSA9IGNpdHk7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgbG9jYXRpb24ubGF0ID49IGJvdW5kcy5zb3V0aCAmJlxyXG4gICAgICAgIGxvY2F0aW9uLmxhdCA8PSBib3VuZHMubm9ydGggJiZcclxuICAgICAgICBsb2NhdGlvbi5sbmcgPj0gYm91bmRzLndlc3QgJiZcclxuICAgICAgICBsb2NhdGlvbi5sbmcgPD0gYm91bmRzLmVhc3RcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGluQ2l0eTogdHJ1ZSxcclxuICAgICAgICAgIGNpdHlOYW1lOiBjaXR5LmlkLFxyXG4gICAgICAgICAgZGlzdGFuY2U6IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZXIgaXMgbm90IGluIGEgc3VwcG9ydGVkIGNpdHksIGZpbmQgbmVhcmVzdCBvbmVcclxuICAgIGNvbnN0IGRpc3RhbmNlcyA9IEVVUk9QRUFOX0NJVElFUy5tYXAoKGNpdHkpID0+ICh7XHJcbiAgICAgIGNpdHk6IGNpdHkuaWQsXHJcbiAgICAgIG5hbWU6IGNpdHkubmFtZSxcclxuICAgICAgZGlzdGFuY2U6IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoXHJcbiAgICAgICAgbG9jYXRpb24ubGF0LFxyXG4gICAgICAgIGxvY2F0aW9uLmxuZyxcclxuICAgICAgICBjaXR5LmNvb3JkaW5hdGVzLmxhdCxcclxuICAgICAgICBjaXR5LmNvb3JkaW5hdGVzLmxuZ1xyXG4gICAgICApLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGNvbnN0IG5lYXJlc3QgPSBkaXN0YW5jZXMucmVkdWNlKChtaW4sIGN1cnIpID0+XHJcbiAgICAgIGN1cnIuZGlzdGFuY2UgPCBtaW4uZGlzdGFuY2UgPyBjdXJyIDogbWluXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGluQ2l0eTogZmFsc2UsXHJcbiAgICAgIGRpc3RhbmNlOiBuZWFyZXN0LmRpc3RhbmNlLFxyXG4gICAgICBuZWFyZXN0Q2l0eTogbmVhcmVzdC5uYW1lLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT0gREVWRUxPUE1FTlQvVEVTVElORyBNRVRIT0RTID09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IG1hbnVhbCBsb2NhdGlvbiBmb3IgdGVzdGluZ1xyXG4gICAqL1xyXG4gIGFzeW5jIHNldFRlc3RMb2NhdGlvbihjaXR5SWQ6IHN0cmluZyk6IFByb21pc2U8TG9jYXRpb25TdGF0ZVJlc3VsdD4ge1xyXG4gICAgY29uc3QgY2l0eSA9IEVVUk9QRUFOX0NJVElFUy5maW5kKChjKSA9PiBjLmlkID09PSBjaXR5SWQpO1xyXG5cclxuICAgIGlmICghY2l0eSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENpdHkgJHtjaXR5SWR9IG5vdCBmb3VuZGApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXRlOiBMb2NhdGlvblN0YXRlUmVzdWx0ID0ge1xyXG4gICAgICBjdXJyZW50Q2l0eTogY2l0eSxcclxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgIGNhblJlbnQ6IHRydWUsXHJcbiAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpLFxyXG4gICAgICBtZXRob2Q6IFwibWFudWFsXCIsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2F2ZUxvY2F0aW9uVG9TdG9yYWdlKHN0YXRlKTtcclxuICAgIGNvbnNvbGUubG9nKGDwn6eqIFRlc3QgbG9jYXRpb24gc2V0OiAke2NpdHkubmFtZX1gKTtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIGxvY2F0aW9uIGNhY2hlXHJcbiAgICovXHJcbiAgY2xlYXJMb2NhdGlvbkNhY2hlKCk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnNlc3Npb25TdG9yYWdlKSB7XHJcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0tFWSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5sb2coXCJMb2NhdGlvbiBjYWNoZSBjbGVhcmVkXCIpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNsZWFyIGxvY2F0aW9uOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBsb2NhdGlvbiBwZXJtaXNzaW9uIChmb3IgY29tcGF0aWJpbGl0eSlcclxuICAgKi9cclxuICBhc3luYyBjaGVja0xvY2F0aW9uUGVybWlzc2lvbigpOiBQcm9taXNlPFwiZ3JhbnRlZFwiIHwgXCJkZW5pZWRcIiB8IFwicHJvbXB0XCI+IHtcclxuICAgIGlmICghbmF2aWdhdG9yLnBlcm1pc3Npb25zKSB7XHJcbiAgICAgIHJldHVybiBcInByb21wdFwiO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSBhd2FpdCBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoe1xyXG4gICAgICAgIG5hbWU6IFwiZ2VvbG9jYXRpb25cIiBhcyBQZXJtaXNzaW9uTmFtZSxcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBwZXJtaXNzaW9uLnN0YXRlIGFzIFwiZ3JhbnRlZFwiIHwgXCJkZW5pZWRcIiB8IFwicHJvbXB0XCI7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgY2hlY2sgbG9jYXRpb24gcGVybWlzc2lvbjpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gXCJwcm9tcHRcIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT0gTkVBUkJZIFZFSElDTEVTIE1FVEhPRFMgKGV4aXN0aW5nIGZ1bmN0aW9uYWxpdHkpID09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG5lYXJieSB2ZWhpY2xlcyB3aXRoaW4gc3BlY2lmaWVkIHJhZGl1c1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldE5lYXJieVZlaGljbGVzKFxyXG4gICAgbG9jYXRpb246IExvY2F0aW9uQ29vcmRpbmF0ZXMsXHJcbiAgICByYWRpdXNLbTogbnVtYmVyID0gMixcclxuICAgIHZlaGljbGVUeXBlPzogVmVoaWNsZVR5cGUsXHJcbiAgICBvbmx5QXZhaWxhYmxlOiBib29sZWFuID0gdHJ1ZVxyXG4gICk6IFByb21pc2U8TmVhcmJ5VmVoaWNsZVtdPiB7XHJcbiAgICAvLyBTaW11bGF0ZSBBUEkgZGVsYXlcclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xyXG5cclxuICAgIGNvbnN0IG5lYXJieVZlaGljbGVzOiBOZWFyYnlWZWhpY2xlW10gPSBbXTtcclxuXHJcbiAgICB0aGlzLnZlaGljbGVMb2NhdGlvbnMuZm9yRWFjaCgodmVoaWNsZSkgPT4ge1xyXG4gICAgICAvLyBGaWx0ZXIgYnkgYXZhaWxhYmlsaXR5IGlmIHJlcXVlc3RlZFxyXG4gICAgICBpZiAob25seUF2YWlsYWJsZSAmJiAhdmVoaWNsZS5pc0F2YWlsYWJsZSkgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gRmlsdGVyIGJ5IHZlaGljbGUgdHlwZSBpZiBzcGVjaWZpZWRcclxuICAgICAgaWYgKHZlaGljbGVUeXBlICYmIHZlaGljbGUudmVoaWNsZVR5cGUgIT09IHZlaGljbGVUeXBlKSByZXR1cm47XHJcblxyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoXHJcbiAgICAgICAgbG9jYXRpb24ubGF0LFxyXG4gICAgICAgIGxvY2F0aW9uLmxuZyxcclxuICAgICAgICB2ZWhpY2xlLmNvb3JkaW5hdGVzLmxhdCxcclxuICAgICAgICB2ZWhpY2xlLmNvb3JkaW5hdGVzLmxuZ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGRpc3RhbmNlIDw9IHJhZGl1c0ttKSB7XHJcbiAgICAgICAgbmVhcmJ5VmVoaWNsZXMucHVzaCh7XHJcbiAgICAgICAgICB2ZWhpY2xlSWQ6IHZlaGljbGUudmVoaWNsZUlkLFxyXG4gICAgICAgICAgdmVoaWNsZVR5cGU6IHZlaGljbGUudmVoaWNsZVR5cGUsXHJcbiAgICAgICAgICBsb2NhdGlvbjoge1xyXG4gICAgICAgICAgICBsYXQ6IHZlaGljbGUuY29vcmRpbmF0ZXMubGF0LFxyXG4gICAgICAgICAgICBsbmc6IHZlaGljbGUuY29vcmRpbmF0ZXMubG5nLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGRpc3RhbmNlLFxyXG4gICAgICAgICAgYmF0dGVyeUxldmVsOiB2ZWhpY2xlLmJhdHRlcnlMZXZlbCxcclxuICAgICAgICAgIGVzdGltYXRlZFJhbmdlOiB2ZWhpY2xlLmVzdGltYXRlZFJhbmdlLFxyXG4gICAgICAgICAgaXNBdmFpbGFibGU6IHZlaGljbGUuaXNBdmFpbGFibGUsXHJcbiAgICAgICAgICBsYXN0VXBkYXRlOiB2ZWhpY2xlLmxhc3RVcGRhdGUsXHJcbiAgICAgICAgICBjaXR5SWQ6IHZlaGljbGUuY2l0eUlkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTb3J0IGJ5IGRpc3RhbmNlXHJcbiAgICByZXR1cm4gbmVhcmJ5VmVoaWNsZXMuc29ydCgoYSwgYikgPT4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHZlaGljbGVzIG5lYXIgdXNlciBsb2NhdGlvblxyXG4gIGdldFZlaGljbGVzTmVhckxvY2F0aW9uKFxyXG4gICAgdXNlckxhdDogbnVtYmVyLFxyXG4gICAgdXNlckxuZzogbnVtYmVyLFxyXG4gICAgcmFkaXVzS206IG51bWJlciA9IDIsXHJcbiAgICB2ZWhpY2xlVHlwZT86IFZlaGljbGVUeXBlXHJcbiAgKTogKFZlaGljbGVMb2NhdGlvbiAmIHsgZGlzdGFuY2U6IG51bWJlciB9KVtdIHtcclxuICAgIGNvbnN0IG5lYXJieVZlaGljbGVzOiAoVmVoaWNsZUxvY2F0aW9uICYgeyBkaXN0YW5jZTogbnVtYmVyIH0pW10gPSBbXTtcclxuXHJcbiAgICB0aGlzLnZlaGljbGVMb2NhdGlvbnMuZm9yRWFjaCgodmVoaWNsZSkgPT4ge1xyXG4gICAgICBpZiAoIXZlaGljbGUuaXNBdmFpbGFibGUpIHJldHVybjtcclxuICAgICAgaWYgKHZlaGljbGVUeXBlICYmIHZlaGljbGUudmVoaWNsZVR5cGUgIT09IHZlaGljbGVUeXBlKSByZXR1cm47XHJcblxyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoXHJcbiAgICAgICAgdXNlckxhdCxcclxuICAgICAgICB1c2VyTG5nLFxyXG4gICAgICAgIHZlaGljbGUuY29vcmRpbmF0ZXMubGF0LFxyXG4gICAgICAgIHZlaGljbGUuY29vcmRpbmF0ZXMubG5nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gcmFkaXVzS20pIHtcclxuICAgICAgICBuZWFyYnlWZWhpY2xlcy5wdXNoKHtcclxuICAgICAgICAgIC4uLnZlaGljbGUsXHJcbiAgICAgICAgICBkaXN0YW5jZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5lYXJieVZlaGljbGVzLnNvcnQoKGEsIGIpID0+IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlKTtcclxuICB9XHJcblxyXG4gIC8vIEdldCB2ZWhpY2xlcyBpbiBzcGVjaWZpYyBjaXR5XHJcbiAgZ2V0VmVoaWNsZXNJbkNpdHkoXHJcbiAgICBjaXR5SWQ6IHN0cmluZyxcclxuICAgIHZlaGljbGVUeXBlPzogVmVoaWNsZVR5cGVcclxuICApOiBWZWhpY2xlTG9jYXRpb25bXSB7XHJcbiAgICBjb25zdCBjaXR5VmVoaWNsZXM6IFZlaGljbGVMb2NhdGlvbltdID0gW107XHJcblxyXG4gICAgdGhpcy52ZWhpY2xlTG9jYXRpb25zLmZvckVhY2goKHZlaGljbGUpID0+IHtcclxuICAgICAgaWYgKHZlaGljbGUuY2l0eUlkICE9PSBjaXR5SWQpIHJldHVybjtcclxuICAgICAgaWYgKCF2ZWhpY2xlLmlzQXZhaWxhYmxlKSByZXR1cm47XHJcbiAgICAgIGlmICh2ZWhpY2xlVHlwZSAmJiB2ZWhpY2xlLnZlaGljbGVUeXBlICE9PSB2ZWhpY2xlVHlwZSkgcmV0dXJuO1xyXG5cclxuICAgICAgY2l0eVZlaGljbGVzLnB1c2godmVoaWNsZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY2l0eVZlaGljbGVzO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PSBVVElMSVRZIE1FVEhPRFMgPT09PT09PT09PT09PVxyXG5cclxuICBwcml2YXRlIGNhbGN1bGF0ZURpc3RhbmNlKFxyXG4gICAgbGF0MTogbnVtYmVyLFxyXG4gICAgbG5nMTogbnVtYmVyLFxyXG4gICAgbGF0MjogbnVtYmVyLFxyXG4gICAgbG5nMjogbnVtYmVyXHJcbiAgKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IFIgPSA2MzcxOyAvLyBFYXJ0aCdzIHJhZGl1cyBpbiBraWxvbWV0ZXJzXHJcbiAgICBjb25zdCBkTGF0ID0gdGhpcy50b1JhZGlhbnMobGF0MiAtIGxhdDEpO1xyXG4gICAgY29uc3QgZExuZyA9IHRoaXMudG9SYWRpYW5zKGxuZzIgLSBsbmcxKTtcclxuXHJcbiAgICBjb25zdCBhID1cclxuICAgICAgTWF0aC5zaW4oZExhdCAvIDIpICogTWF0aC5zaW4oZExhdCAvIDIpICtcclxuICAgICAgTWF0aC5jb3ModGhpcy50b1JhZGlhbnMobGF0MSkpICpcclxuICAgICAgICBNYXRoLmNvcyh0aGlzLnRvUmFkaWFucyhsYXQyKSkgKlxyXG4gICAgICAgIE1hdGguc2luKGRMbmcgLyAyKSAqXHJcbiAgICAgICAgTWF0aC5zaW4oZExuZyAvIDIpO1xyXG5cclxuICAgIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xyXG4gICAgcmV0dXJuIFIgKiBjO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB0b1JhZGlhbnMoZGVncmVlczogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBkZWdyZWVzICogKE1hdGguUEkgLyAxODApO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PSBWRUhJQ0xFIEZMRUVUIE1FVEhPRFMgKGV4aXN0aW5nKSA9PT09PT09PT09PT09XHJcblxyXG4gIGluaXRpYWxpemVWZWhpY2xlRmxlZXQoKTogdm9pZCB7XHJcbiAgICBFVVJPUEVBTl9DSVRJRVMuZm9yRWFjaCgoY2l0eSkgPT4ge1xyXG4gICAgICBPYmplY3QuZW50cmllcyhjaXR5LnZlaGljbGVMaW1pdCkuZm9yRWFjaCgoW3ZlaGljbGVUeXBlLCBsaW1pdF0pID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBsaW1pdCA+IDAgJiZcclxuICAgICAgICAgIGNpdHkuYWxsb3dlZFZlaGljbGVzLmluY2x1ZGVzKHZlaGljbGVUeXBlIGFzIFZlaGljbGVUeXBlKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlaGljbGVJZCA9IHRoaXMuZ2VuZXJhdGVWZWhpY2xlSWQoXHJcbiAgICAgICAgICAgICAgY2l0eS5pZCxcclxuICAgICAgICAgICAgICB2ZWhpY2xlVHlwZSBhcyBWZWhpY2xlVHlwZSxcclxuICAgICAgICAgICAgICBpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZW5lcmF0ZVJhbmRvbUxvY2F0aW9uSW5DaXR5KGNpdHkpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy52ZWhpY2xlTG9jYXRpb25zLnNldCh2ZWhpY2xlSWQsIHtcclxuICAgICAgICAgICAgICB2ZWhpY2xlSWQsXHJcbiAgICAgICAgICAgICAgdmVoaWNsZVR5cGU6IHZlaGljbGVUeXBlIGFzIFZlaGljbGVUeXBlLFxyXG4gICAgICAgICAgICAgIGNpdHlJZDogY2l0eS5pZCxcclxuICAgICAgICAgICAgICBjb29yZGluYXRlczogbG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgYmF0dGVyeUxldmVsOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0MCkgKyA2MCwgLy8gNjAtMTAwJVxyXG4gICAgICAgICAgICAgIGlzQXZhaWxhYmxlOiBNYXRoLnJhbmRvbSgpID4gMC4xNSwgLy8gODUlIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgIGxhc3RVcGRhdGU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgZXN0aW1hdGVkUmFuZ2U6IHRoaXMuY2FsY3VsYXRlUmFuZ2UodmVoaWNsZVR5cGUgYXMgVmVoaWNsZVR5cGUpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdlbmVyYXRlVmVoaWNsZUlkKFxyXG4gICAgY2l0eUlkOiBzdHJpbmcsXHJcbiAgICB2ZWhpY2xlVHlwZTogVmVoaWNsZVR5cGUsXHJcbiAgICBpbmRleDogbnVtYmVyXHJcbiAgKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHR5cGVDb2RlID0ge1xyXG4gICAgICBiaWtlOiBcIkJLXCIsXHJcbiAgICAgIHNjb290ZXI6IFwiU0NcIixcclxuICAgICAgbW9ub3BhdHRpbm86IFwiTVBcIixcclxuICAgIH1bdmVoaWNsZVR5cGVdO1xyXG5cclxuICAgIGNvbnN0IGNpdHlDb2RlID0gY2l0eUlkLnN1YnN0cmluZygwLCAzKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgcmV0dXJuIGBNT09WRS0ke2NpdHlDb2RlfS0ke3R5cGVDb2RlfS0keyhpbmRleCArIDEpXHJcbiAgICAgIC50b1N0cmluZygpXHJcbiAgICAgIC5wYWRTdGFydCgzLCBcIjBcIil9YDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVSYW5kb21Mb2NhdGlvbkluQ2l0eShjaXR5OiBDaXR5Q29uZmlnKToge1xyXG4gICAgbGF0OiBudW1iZXI7XHJcbiAgICBsbmc6IG51bWJlcjtcclxuICB9IHtcclxuICAgIGNvbnN0IGxhdFJhbmdlID0gY2l0eS5ib3VuZHMubm9ydGggLSBjaXR5LmJvdW5kcy5zb3V0aDtcclxuICAgIGNvbnN0IGxuZ1JhbmdlID0gY2l0eS5ib3VuZHMuZWFzdCAtIGNpdHkuYm91bmRzLndlc3Q7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGF0OiBjaXR5LmJvdW5kcy5zb3V0aCArIE1hdGgucmFuZG9tKCkgKiBsYXRSYW5nZSxcclxuICAgICAgbG5nOiBjaXR5LmJvdW5kcy53ZXN0ICsgTWF0aC5yYW5kb20oKSAqIGxuZ1JhbmdlLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2FsY3VsYXRlUmFuZ2UodmVoaWNsZVR5cGU6IFZlaGljbGVUeXBlKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IHJhbmdlcyA9IHtcclxuICAgICAgYmlrZTogWzI1LCA1MF0sIC8vIDI1LTUwa21cclxuICAgICAgc2Nvb3RlcjogWzMwLCA2MF0sIC8vIDMwLTYwa21cclxuICAgICAgbW9ub3BhdHRpbm86IFsxNSwgMzVdLCAvLyAxNS0zNWttXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IFttaW4sIG1heF0gPSByYW5nZXNbdmVoaWNsZVR5cGVdO1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XHJcbiAgfVxyXG5cclxuICAvLyBWZWhpY2xlIG1hbmFnZW1lbnQgbWV0aG9kcyAoZXhpc3RpbmcpXHJcbiAgcmVzZXJ2ZVZlaGljbGUodmVoaWNsZUlkOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHZlaGljbGUgPSB0aGlzLnZlaGljbGVMb2NhdGlvbnMuZ2V0KHZlaGljbGVJZCk7XHJcbiAgICBpZiAodmVoaWNsZSAmJiB2ZWhpY2xlLmlzQXZhaWxhYmxlKSB7XHJcbiAgICAgIHZlaGljbGUuaXNBdmFpbGFibGUgPSBmYWxzZTtcclxuICAgICAgdmVoaWNsZS5sYXN0VXBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZWxlYXNlVmVoaWNsZShcclxuICAgIHZlaGljbGVJZDogc3RyaW5nLFxyXG4gICAgbmV3TG9jYXRpb24/OiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9XHJcbiAgKTogdm9pZCB7XHJcbiAgICBjb25zdCB2ZWhpY2xlID0gdGhpcy52ZWhpY2xlTG9jYXRpb25zLmdldCh2ZWhpY2xlSWQpO1xyXG4gICAgaWYgKHZlaGljbGUpIHtcclxuICAgICAgdmVoaWNsZS5pc0F2YWlsYWJsZSA9IHRydWU7XHJcbiAgICAgIHZlaGljbGUubGFzdFVwZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGlmIChuZXdMb2NhdGlvbikge1xyXG4gICAgICAgIHZlaGljbGUuY29vcmRpbmF0ZXMgPSBuZXdMb2NhdGlvbjtcclxuICAgICAgfVxyXG4gICAgICB2ZWhpY2xlLmJhdHRlcnlMZXZlbCA9IE1hdGgubWF4KFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgdmVoaWNsZS5iYXR0ZXJ5TGV2ZWwgLSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMClcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldFZlaGljbGUodmVoaWNsZUlkOiBzdHJpbmcpOiBWZWhpY2xlTG9jYXRpb24gfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMudmVoaWNsZUxvY2F0aW9ucy5nZXQodmVoaWNsZUlkKTtcclxuICB9XHJcblxyXG4gIGdldEFsbFZlaGljbGVzKCk6IFZlaGljbGVMb2NhdGlvbltdIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmVoaWNsZUxvY2F0aW9ucy52YWx1ZXMoKSk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVWZWhpY2xlTG9jYXRpb24oXHJcbiAgICB2ZWhpY2xlSWQ6IHN0cmluZyxcclxuICAgIG5ld0xvY2F0aW9uOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9XHJcbiAgKTogdm9pZCB7XHJcbiAgICBjb25zdCB2ZWhpY2xlID0gdGhpcy52ZWhpY2xlTG9jYXRpb25zLmdldCh2ZWhpY2xlSWQpO1xyXG4gICAgaWYgKHZlaGljbGUpIHtcclxuICAgICAgdmVoaWNsZS5jb29yZGluYXRlcyA9IG5ld0xvY2F0aW9uO1xyXG4gICAgICB2ZWhpY2xlLmxhc3RVcGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PSBIRUxQRVIgRlVOQ1RJT05TIChleGlzdGluZykgPT09PT09PT09PT09PVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERpc3RhbmNlKGRpc3RhbmNlS206IG51bWJlcik6IHN0cmluZyB7XHJcbiAgaWYgKGRpc3RhbmNlS20gPCAwLjEpIHtcclxuICAgIHJldHVybiBcIlZlcnkgY2xvc2VcIjtcclxuICB9IGVsc2UgaWYgKGRpc3RhbmNlS20gPCAxKSB7XHJcbiAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChkaXN0YW5jZUttICogMTAwMCl9bWA7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgJHtkaXN0YW5jZUttLnRvRml4ZWQoMSl9a21gO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJhdHRlcnlDb2xvcihsZXZlbDogbnVtYmVyKTogc3RyaW5nIHtcclxuICBpZiAobGV2ZWwgPiA3MCkgcmV0dXJuIFwidGV4dC1ncmVlbi02MDBcIjtcclxuICBpZiAobGV2ZWwgPiAzMCkgcmV0dXJuIFwidGV4dC15ZWxsb3ctNjAwXCI7XHJcbiAgcmV0dXJuIFwidGV4dC1yZWQtNjAwXCI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWZWhpY2xlRW1vamkodHlwZTogVmVoaWNsZVR5cGUpOiBzdHJpbmcge1xyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBcImJpa2VcIjpcclxuICAgICAgcmV0dXJuIFwi8J+aslwiO1xyXG4gICAgY2FzZSBcInNjb290ZXJcIjpcclxuICAgICAgcmV0dXJuIFwi8J+btFwiO1xyXG4gICAgY2FzZSBcIm1vbm9wYXR0aW5vXCI6XHJcbiAgICAgIHJldHVybiBcIvCfm7VcIjtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBcIvCfmrJcIjtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBkZWZhdWx0IGZvciBjb21wYXRpYmlsaXR5XHJcbmV4cG9ydCBkZWZhdWx0IFZlaGljbGVHZW9sb2NhdGlvblN5c3RlbTtcclxuIl0sIm5hbWVzIjpbIkVVUk9QRUFOX0NJVElFUyIsIkdFT0xPQ0FUSU9OX09QVElPTlMiLCJlbmFibGVIaWdoQWNjdXJhY3kiLCJ0aW1lb3V0IiwibWF4aW11bUFnZSIsIlNUT1JBR0VfS0VZIiwiQ0FDSEVfRFVSQVRJT04iLCJWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0iLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiaW5pdGlhbGl6ZVZlaGljbGVGbGVldCIsInNhdmVMb2NhdGlvblRvU3RvcmFnZSIsInN0YXRlIiwid2luZG93Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJsb2FkTG9jYXRpb25Gcm9tU3RvcmFnZSIsInN0b3JlZCIsImdldEl0ZW0iLCJkYXRhIiwicGFyc2UiLCJub3ciLCJEYXRlIiwibGFzdFVwZGF0ZWQiLCJyZW1vdmVJdGVtIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwiY2FjaGVkIiwiY3VycmVudENpdHkiLCJsb2ciLCJjb29yZGluYXRlcyIsIm5hdmlnYXRvciIsImdlb2xvY2F0aW9uIiwiRXJyb3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImdldEN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwibGF0IiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsbmciLCJsb25naXR1ZGUiLCJuZWFyZXN0Q2l0eSIsImZpbmROZWFyZXN0U3VwcG9ydGVkQ2l0eSIsInNhdmVMb2NhdGlvblN0YXRlIiwibWVzc2FnZSIsImNvZGUiLCJQRVJNSVNTSU9OX0RFTklFRCIsIlBPU0lUSU9OX1VOQVZBSUxBQkxFIiwiVElNRU9VVCIsImdldEN1cnJlbnRMb2NhdGlvblN0YXRlIiwiaXNMb2FkaW5nIiwiY2FuUmVudCIsIm1ldGhvZCIsIm1pbkRpc3RhbmNlIiwiSW5maW5pdHkiLCJjaXR5IiwiYm91bmRzIiwic291dGgiLCJub3J0aCIsIndlc3QiLCJlYXN0IiwiZGlzdGFuY2UiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImNoZWNrQ2l0eVN1cHBvcnQiLCJsb2NhdGlvbiIsImluQ2l0eSIsImNpdHlOYW1lIiwiaWQiLCJkaXN0YW5jZXMiLCJtYXAiLCJuYW1lIiwibmVhcmVzdCIsInJlZHVjZSIsIm1pbiIsImN1cnIiLCJzZXRUZXN0TG9jYXRpb24iLCJjaXR5SWQiLCJmaW5kIiwiYyIsImNsZWFyTG9jYXRpb25DYWNoZSIsImNoZWNrTG9jYXRpb25QZXJtaXNzaW9uIiwicGVybWlzc2lvbnMiLCJwZXJtaXNzaW9uIiwicXVlcnkiLCJnZXROZWFyYnlWZWhpY2xlcyIsInJhZGl1c0ttIiwidmVoaWNsZVR5cGUiLCJvbmx5QXZhaWxhYmxlIiwic2V0VGltZW91dCIsIm5lYXJieVZlaGljbGVzIiwidmVoaWNsZUxvY2F0aW9ucyIsImZvckVhY2giLCJ2ZWhpY2xlIiwiaXNBdmFpbGFibGUiLCJwdXNoIiwidmVoaWNsZUlkIiwiYmF0dGVyeUxldmVsIiwiZXN0aW1hdGVkUmFuZ2UiLCJsYXN0VXBkYXRlIiwic29ydCIsImEiLCJiIiwiZ2V0VmVoaWNsZXNOZWFyTG9jYXRpb24iLCJ1c2VyTGF0IiwidXNlckxuZyIsImdldFZlaGljbGVzSW5DaXR5IiwiY2l0eVZlaGljbGVzIiwibGF0MSIsImxuZzEiLCJsYXQyIiwibG5nMiIsIlIiLCJkTGF0IiwidG9SYWRpYW5zIiwiZExuZyIsIk1hdGgiLCJzaW4iLCJjb3MiLCJhdGFuMiIsInNxcnQiLCJkZWdyZWVzIiwiUEkiLCJPYmplY3QiLCJlbnRyaWVzIiwidmVoaWNsZUxpbWl0IiwibGltaXQiLCJhbGxvd2VkVmVoaWNsZXMiLCJpbmNsdWRlcyIsImkiLCJnZW5lcmF0ZVZlaGljbGVJZCIsImdlbmVyYXRlUmFuZG9tTG9jYXRpb25JbkNpdHkiLCJzZXQiLCJmbG9vciIsInJhbmRvbSIsImNhbGN1bGF0ZVJhbmdlIiwiaW5kZXgiLCJ0eXBlQ29kZSIsImJpa2UiLCJzY29vdGVyIiwibW9ub3BhdHRpbm8iLCJjaXR5Q29kZSIsInN1YnN0cmluZyIsInRvVXBwZXJDYXNlIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImxhdFJhbmdlIiwibG5nUmFuZ2UiLCJyYW5nZXMiLCJtYXgiLCJyZXNlcnZlVmVoaWNsZSIsImdldCIsInJlbGVhc2VWZWhpY2xlIiwibmV3TG9jYXRpb24iLCJnZXRWZWhpY2xlIiwiZ2V0QWxsVmVoaWNsZXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJ1cGRhdGVWZWhpY2xlTG9jYXRpb24iLCJjb25zdHJ1Y3RvciIsIk1hcCIsInNpemUiLCJmb3JtYXREaXN0YW5jZSIsImRpc3RhbmNlS20iLCJyb3VuZCIsInRvRml4ZWQiLCJnZXRCYXR0ZXJ5Q29sb3IiLCJsZXZlbCIsImdldFZlaGljbGVFbW9qaSIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/vehicleGeoLocation.ts\n"));

/***/ })

});