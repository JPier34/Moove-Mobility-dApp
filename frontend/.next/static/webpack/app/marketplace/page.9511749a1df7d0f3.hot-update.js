"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/marketplace/page",{

/***/ "(app-pages-browser)/./utils/vehicleGeoLocation.ts":
/*!*************************************!*\
  !*** ./utils/vehicleGeoLocation.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VehicleGeolocationSystem: function() { return /* binding */ VehicleGeolocationSystem; },\n/* harmony export */   formatDistance: function() { return /* binding */ formatDistance; },\n/* harmony export */   getBatteryColor: function() { return /* binding */ getBatteryColor; },\n/* harmony export */   getVehicleEmoji: function() { return /* binding */ getVehicleEmoji; }\n/* harmony export */ });\n/* harmony import */ var _config_cities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/config/cities */ \"(app-pages-browser)/./config/cities.ts\");\n\n// ============= CONSTANTS =============\nconst GEOLOCATION_OPTIONS = {\n    enableHighAccuracy: false,\n    timeout: 10000,\n    maximumAge: 300000\n};\nconst STORAGE_KEY = \"moove_city_location\";\nconst CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\nclass VehicleGeolocationSystem {\n    static getInstance() {\n        if (!VehicleGeolocationSystem.instance) {\n            VehicleGeolocationSystem.instance = new VehicleGeolocationSystem();\n            VehicleGeolocationSystem.instance.initializeVehicleFleet();\n        }\n        return VehicleGeolocationSystem.instance;\n    }\n    // ============= PERSISTENT LOCATION MANAGEMENT =============\n    saveLocationToStorage(state) {\n        try {\n            if ( true && window.sessionStorage) {\n                sessionStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n            }\n        } catch (error) {\n            console.warn(\"Failed to save location:\", error);\n        }\n    }\n    loadLocationFromStorage() {\n        try {\n            if ( false || !window.sessionStorage) {\n                return null;\n            }\n            const stored = sessionStorage.getItem(STORAGE_KEY);\n            if (!stored) return null;\n            const data = JSON.parse(stored);\n            const now = Date.now();\n            // Check if cache is still valid\n            if (now - data.lastUpdated > CACHE_DURATION) {\n                sessionStorage.removeItem(STORAGE_KEY);\n                return null;\n            }\n            return data;\n        } catch (error) {\n            console.warn(\"Failed to load location:\", error);\n            return null;\n        }\n    }\n    // ============= MAIN LOCATION METHODS =============\n    /**\r\n   * Get current user location with caching\r\n   */ async getCurrentLocation() {\n        // Try cache first for LocationCoordinates compatibility\n        const cached = this.loadLocationFromStorage();\n        if (cached && cached.currentCity) {\n            console.log(\"Using cached location\");\n            return cached.currentCity.coordinates;\n        }\n        // Get fresh location\n        if (!navigator.geolocation) {\n            throw new Error(\"Geolocation is not supported by this browser\");\n        }\n        return new Promise((resolve, reject)=>{\n            navigator.geolocation.getCurrentPosition((position)=>{\n                const coordinates = {\n                    lat: position.coords.latitude,\n                    lng: position.coords.longitude\n                };\n                // Find and cache nearest city\n                const nearestCity = this.findNearestSupportedCity(coordinates);\n                this.saveLocationState(coordinates, nearestCity);\n                resolve(coordinates);\n            }, (error)=>{\n                let message;\n                switch(error.code){\n                    case error.PERMISSION_DENIED:\n                        message = \"Location access denied. Please enable location services.\";\n                        break;\n                    case error.POSITION_UNAVAILABLE:\n                        message = \"Location information unavailable.\";\n                        break;\n                    case error.TIMEOUT:\n                        message = \"Location request timed out.\";\n                        break;\n                    default:\n                        message = \"Unknown location error.\";\n                }\n                reject(new Error(message));\n            }, GEOLOCATION_OPTIONS);\n        });\n    }\n    /**\r\n   * Get current location state\r\n   */ saveLocationState(coordinates, nearestCity) {\n        let method = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"gps\", error = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n        const state = {\n            currentCity: nearestCity,\n            isLoading: false,\n            error: error,\n            canRent: !!nearestCity,\n            lastUpdated: Date.now(),\n            method: method\n        };\n        this.saveLocationToStorage(state);\n        return state;\n    }\n    findNearestSupportedCity(coordinates) {\n        let nearestCity = null;\n        let minDistance = Infinity;\n        for (const city of _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES){\n            const { bounds } = city;\n            // Check if inside city bounds first\n            if (coordinates.lat >= bounds.south && coordinates.lat <= bounds.north && coordinates.lng >= bounds.west && coordinates.lng <= bounds.east) {\n                return city; // Inside city, return immediately\n            }\n            // Calculate distance to city center\n            const distance = this.calculateDistance(coordinates.lat, coordinates.lng, city.coordinates.lat, city.coordinates.lng);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearestCity = city;\n            }\n        }\n        // Only return city if within reasonable distance (200km)\n        return minDistance <= 200 ? nearestCity : null;\n    }\n    // Fallback method for distances >= 200kms\n    getIntelligentFallbackCity(coordinates) {\n        const lat = coordinates.lat;\n        const lng = coordinates.lng;\n        // European regions - provide sensible defaults based on geography\n        if (lat >= 35 && lat <= 47 && lng >= 6 && lng <= 20) {\n            // Central/Southern Europe (Italy, parts of Germany, Austria, etc.)\n            if (lat >= 41 && lng >= 8 && lng <= 19) {\n                return _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.find((c)=>c.id === \"rome\"); // Italy area\n            } else if (lat >= 45 && lng >= 6 && lng <= 15) {\n                return _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.find((c)=>c.id === \"milan\"); // Northern Italy/Alps\n            } else if (lat >= 50 && lng >= 10 && lng <= 15) {\n                return _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.find((c)=>c.id === \"berlin\"); // Germany area\n            }\n        } else if (lat >= 43 && lat <= 51 && lng >= -5 && lng <= 8) {\n            // Western Europe (France, Spain, UK)\n            if (lat <= 46) {\n                return _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.find((c)=>c.id === \"madrid\"); // Spain area\n            } else {\n                return _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.find((c)=>c.id === \"paris\"); // France area\n            }\n        }\n        // Default fallback - Rome (central Europe)\n        return _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.find((c)=>c.id === \"rome\");\n    }\n    /**\r\n   * Get current location state\r\n   */ async getCurrentLocationState() {\n        // Try cache first\n        const cached = this.loadLocationFromStorage();\n        if (cached) {\n            console.log(\"Using cached location state\");\n            return cached;\n        }\n        // Get fresh location\n        try {\n            const coordinates = await this.getCurrentLocation();\n            let nearestCity = this.findNearestSupportedCity(coordinates);\n            let method = \"gps\";\n            let error = null;\n            // If no city found within 200km, use intelligent fallback\n            if (!nearestCity) {\n                nearestCity = this.getIntelligentFallbackCity(coordinates);\n                method = \"manual\"; // Mark as manual since it's a fallback\n                error = \"You're outside our service area. We've selected \".concat(nearestCity === null || nearestCity === void 0 ? void 0 : nearestCity.name, \" as the nearest supported city.\");\n                console.log(\"\\uD83D\\uDCCD User location outside 200km service area. Fallback: \".concat(nearestCity === null || nearestCity === void 0 ? void 0 : nearestCity.name));\n            }\n            return this.saveLocationState(coordinates, nearestCity, method, error);\n        } catch (error) {\n            return {\n                currentCity: null,\n                isLoading: false,\n                error: error.message,\n                canRent: false,\n                lastUpdated: Date.now(),\n                method: \"gps\"\n            };\n        }\n    }\n    /**\r\n   * Check if user is in a supported city\r\n   */ checkCitySupport(location) {\n        // Check if user is within any supported city bounds\n        for (const city of _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES){\n            const { bounds } = city;\n            if (location.lat >= bounds.south && location.lat <= bounds.north && location.lng >= bounds.west && location.lng <= bounds.east) {\n                return {\n                    inCity: true,\n                    cityName: city.id,\n                    distance: 0\n                };\n            }\n        }\n        // User is not in a supported city, find nearest one\n        const distances = _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.map((city)=>({\n                city: city.id,\n                name: city.name,\n                distance: this.calculateDistance(location.lat, location.lng, city.coordinates.lat, city.coordinates.lng)\n            }));\n        const nearest = distances.reduce((min, curr)=>curr.distance < min.distance ? curr : min);\n        return {\n            inCity: false,\n            distance: nearest.distance,\n            nearestCity: nearest.name\n        };\n    }\n    // ============= DEVELOPMENT/TESTING METHODS =============\n    /**\r\n   * Set manual location for testing\r\n   */ async setTestLocation(cityId) {\n        const city = _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.find((c)=>c.id === cityId);\n        if (!city) {\n            throw new Error(\"City \".concat(cityId, \" not found\"));\n        }\n        const state = {\n            currentCity: city,\n            isLoading: false,\n            error: null,\n            canRent: true,\n            lastUpdated: Date.now(),\n            method: \"manual\"\n        };\n        this.saveLocationToStorage(state);\n        console.log(\"\\uD83E\\uDDEA Test location set: \".concat(city.name));\n        return state;\n    }\n    /**\r\n   * Clear location cache\r\n   */ clearLocationCache() {\n        try {\n            if ( true && window.sessionStorage) {\n                sessionStorage.removeItem(STORAGE_KEY);\n            }\n            console.log(\"Location cache cleared\");\n        } catch (error) {\n            console.warn(\"Failed to clear location:\", error);\n        }\n    }\n    /**\r\n   * Check location permission (for compatibility)\r\n   */ async checkLocationPermission() {\n        if (!navigator.permissions) {\n            return \"prompt\";\n        }\n        try {\n            const permission = await navigator.permissions.query({\n                name: \"geolocation\"\n            });\n            return permission.state;\n        } catch (error) {\n            console.warn(\"Could not check location permission:\", error);\n            return \"prompt\";\n        }\n    }\n    // ============= NEARBY VEHICLES METHODS =============\n    /**\r\n   * Get nearby vehicles within specified radius\r\n   */ async getNearbyVehicles(location) {\n        let radiusKm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2, vehicleType = arguments.length > 2 ? arguments[2] : void 0, onlyAvailable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n        // Simulate API delay\n        await new Promise((resolve)=>setTimeout(resolve, 300));\n        const nearbyVehicles = [];\n        this.vehicleLocations.forEach((vehicle)=>{\n            // Filter by availability if requested\n            if (onlyAvailable && !vehicle.isAvailable) return;\n            // Filter by vehicle type if specified\n            if (vehicleType && vehicle.vehicleType !== vehicleType) return;\n            const distance = this.calculateDistance(location.lat, location.lng, vehicle.coordinates.lat, vehicle.coordinates.lng);\n            if (distance <= radiusKm) {\n                nearbyVehicles.push({\n                    vehicleId: vehicle.vehicleId,\n                    vehicleType: vehicle.vehicleType,\n                    location: {\n                        lat: vehicle.coordinates.lat,\n                        lng: vehicle.coordinates.lng\n                    },\n                    distance,\n                    batteryLevel: vehicle.batteryLevel,\n                    estimatedRange: vehicle.estimatedRange,\n                    isAvailable: vehicle.isAvailable,\n                    lastUpdate: vehicle.lastUpdate,\n                    cityId: vehicle.cityId\n                });\n            }\n        });\n        // Sort by distance\n        return nearbyVehicles.sort((a, b)=>a.distance - b.distance);\n    }\n    // Get vehicles near user location\n    getVehiclesNearLocation(userLat, userLng) {\n        let radiusKm = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2, vehicleType = arguments.length > 3 ? arguments[3] : void 0;\n        const nearbyVehicles = [];\n        this.vehicleLocations.forEach((vehicle)=>{\n            if (!vehicle.isAvailable) return;\n            if (vehicleType && vehicle.vehicleType !== vehicleType) return;\n            const distance = this.calculateDistance(userLat, userLng, vehicle.coordinates.lat, vehicle.coordinates.lng);\n            if (distance <= radiusKm) {\n                nearbyVehicles.push({\n                    ...vehicle,\n                    distance\n                });\n            }\n        });\n        return nearbyVehicles.sort((a, b)=>a.distance - b.distance);\n    }\n    // Get vehicles in specific city\n    getVehiclesInCity(cityId, vehicleType) {\n        const cityVehicles = [];\n        this.vehicleLocations.forEach((vehicle)=>{\n            if (vehicle.cityId !== cityId) return;\n            if (!vehicle.isAvailable) return;\n            if (vehicleType && vehicle.vehicleType !== vehicleType) return;\n            cityVehicles.push(vehicle);\n        });\n        return cityVehicles;\n    }\n    // ============= UTILITY METHODS =============\n    calculateDistance(lat1, lng1, lat2, lng2) {\n        const R = 6371; // Earth's radius in kilometers\n        const dLat = this.toRadians(lat2 - lat1);\n        const dLng = this.toRadians(lng2 - lng1);\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n    toRadians(degrees) {\n        return degrees * (Math.PI / 180);\n    }\n    // ============= VEHICLE FLEET METHODS (existing) =============\n    initializeVehicleFleet() {\n        _config_cities__WEBPACK_IMPORTED_MODULE_0__.EUROPEAN_CITIES.forEach((city)=>{\n            Object.entries(city.vehicleLimit).forEach((param)=>{\n                let [vehicleType, limit] = param;\n                if (limit > 0 && city.allowedVehicles.includes(vehicleType)) {\n                    for(let i = 0; i < limit; i++){\n                        const vehicleId = this.generateVehicleId(city.id, vehicleType, i);\n                        const location = this.generateRandomLocationInCity(city);\n                        this.vehicleLocations.set(vehicleId, {\n                            vehicleId,\n                            vehicleType: vehicleType,\n                            cityId: city.id,\n                            coordinates: location,\n                            batteryLevel: Math.floor(Math.random() * 40) + 60,\n                            isAvailable: Math.random() > 0.15,\n                            lastUpdate: new Date(),\n                            estimatedRange: this.calculateRange(vehicleType)\n                        });\n                    }\n                }\n            });\n        });\n    }\n    generateVehicleId(cityId, vehicleType, index) {\n        const typeCode = {\n            bike: \"BK\",\n            scooter: \"SC\",\n            monopattino: \"MP\"\n        }[vehicleType];\n        const cityCode = cityId.substring(0, 3).toUpperCase();\n        return \"MOOVE-\".concat(cityCode, \"-\").concat(typeCode, \"-\").concat((index + 1).toString().padStart(3, \"0\"));\n    }\n    generateRandomLocationInCity(city) {\n        const latRange = city.bounds.north - city.bounds.south;\n        const lngRange = city.bounds.east - city.bounds.west;\n        return {\n            lat: city.bounds.south + Math.random() * latRange,\n            lng: city.bounds.west + Math.random() * lngRange\n        };\n    }\n    calculateRange(vehicleType) {\n        const ranges = {\n            bike: [\n                25,\n                50\n            ],\n            scooter: [\n                30,\n                60\n            ],\n            monopattino: [\n                15,\n                35\n            ]\n        };\n        const [min, max] = ranges[vehicleType];\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    // Vehicle management methods (existing)\n    reserveVehicle(vehicleId) {\n        const vehicle = this.vehicleLocations.get(vehicleId);\n        if (vehicle && vehicle.isAvailable) {\n            vehicle.isAvailable = false;\n            vehicle.lastUpdate = new Date();\n            return true;\n        }\n        return false;\n    }\n    releaseVehicle(vehicleId, newLocation) {\n        const vehicle = this.vehicleLocations.get(vehicleId);\n        if (vehicle) {\n            vehicle.isAvailable = true;\n            vehicle.lastUpdate = new Date();\n            if (newLocation) {\n                vehicle.coordinates = newLocation;\n            }\n            vehicle.batteryLevel = Math.max(0, vehicle.batteryLevel - Math.floor(Math.random() * 20));\n        }\n    }\n    getVehicle(vehicleId) {\n        return this.vehicleLocations.get(vehicleId);\n    }\n    getAllVehicles() {\n        return Array.from(this.vehicleLocations.values());\n    }\n    updateVehicleLocation(vehicleId, newLocation) {\n        const vehicle = this.vehicleLocations.get(vehicleId);\n        if (vehicle) {\n            vehicle.coordinates = newLocation;\n            vehicle.lastUpdate = new Date();\n        }\n    }\n    constructor(){\n        this.vehicleLocations = new Map();\n        if (!this.vehicleLocations.size) {\n            this.initializeVehicleFleet();\n        }\n    }\n}\n// ============= HELPER FUNCTIONS (existing) =============\nfunction formatDistance(distanceKm) {\n    if (distanceKm < 0.1) {\n        return \"Very close\";\n    } else if (distanceKm < 1) {\n        return \"\".concat(Math.round(distanceKm * 1000), \"m\");\n    } else {\n        return \"\".concat(distanceKm.toFixed(1), \"km\");\n    }\n}\nfunction getBatteryColor(level) {\n    if (level > 70) return \"text-green-600\";\n    if (level > 30) return \"text-yellow-600\";\n    return \"text-red-600\";\n}\nfunction getVehicleEmoji(type) {\n    switch(type){\n        case \"bike\":\n            return \"\\uD83D\\uDEB2\";\n        case \"scooter\":\n            return \"\\uD83D\\uDEF4\";\n        case \"monopattino\":\n            return \"\\uD83D\\uDEF5\";\n        default:\n            return \"\\uD83D\\uDEB2\";\n    }\n}\n// Export default for compatibility\n/* harmony default export */ __webpack_exports__[\"default\"] = (VehicleGeolocationSystem);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3ZlaGljbGVHZW9Mb2NhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNrRDtBQXFEbEQsd0NBQXdDO0FBQ3hDLE1BQU1DLHNCQUF1QztJQUMzQ0Msb0JBQW9CO0lBQ3BCQyxTQUFTO0lBQ1RDLFlBQVk7QUFDZDtBQUVBLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsaUJBQWlCLEtBQUssS0FBSyxNQUFNLGFBQWE7QUFFN0MsTUFBTUM7SUFJWCxPQUFPQyxjQUF3QztRQUM3QyxJQUFJLENBQUNELHlCQUF5QkUsUUFBUSxFQUFFO1lBQ3RDRix5QkFBeUJFLFFBQVEsR0FBRyxJQUFJRjtZQUN4Q0EseUJBQXlCRSxRQUFRLENBQUNDLHNCQUFzQjtRQUMxRDtRQUNBLE9BQU9ILHlCQUF5QkUsUUFBUTtJQUMxQztJQVFBLDZEQUE2RDtJQUVyREUsc0JBQXNCQyxLQUEwQixFQUFRO1FBQzlELElBQUk7WUFDRixJQUFJLEtBQTZCLElBQUlDLE9BQU9DLGNBQWMsRUFBRTtnQkFDMURBLGVBQWVDLE9BQU8sQ0FBQ1YsYUFBYVcsS0FBS0MsU0FBUyxDQUFDTDtZQUNyRDtRQUNGLEVBQUUsT0FBT00sT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsNEJBQTRCRjtRQUMzQztJQUNGO0lBRVFHLDBCQUFzRDtRQUM1RCxJQUFJO1lBQ0YsSUFBSSxNQUE2QixJQUFJLENBQUNSLE9BQU9DLGNBQWMsRUFBRTtnQkFDM0QsT0FBTztZQUNUO1lBRUEsTUFBTVEsU0FBU1IsZUFBZVMsT0FBTyxDQUFDbEI7WUFDdEMsSUFBSSxDQUFDaUIsUUFBUSxPQUFPO1lBRXBCLE1BQU1FLE9BQU9SLEtBQUtTLEtBQUssQ0FBQ0g7WUFDeEIsTUFBTUksTUFBTUMsS0FBS0QsR0FBRztZQUVwQixnQ0FBZ0M7WUFDaEMsSUFBSUEsTUFBTUYsS0FBS0ksV0FBVyxHQUFHdEIsZ0JBQWdCO2dCQUMzQ1EsZUFBZWUsVUFBVSxDQUFDeEI7Z0JBQzFCLE9BQU87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YSxHQUFHO1FBQ3pCLE9BQU8sR0FBaUMsT0FBOUJoRCxLQUFLaUQsS0FBSyxDQUFDRCxhQUFhLE9BQU07SUFDMUMsT0FBTztRQUNMLE9BQU8sR0FBeUIsT0FBdEJBLFdBQVdFLE9BQU8sQ0FBQyxJQUFHO0lBQ2xDO0FBQ0Y7QUFFTyxTQUFTQyxnQkFBZ0JDLEtBQWE7SUFDM0MsSUFBSUEsUUFBUSxJQUFJLE9BQU87SUFDdkIsSUFBSUEsUUFBUSxJQUFJLE9BQU87SUFDdkIsT0FBTztBQUNUO0FBRU8sU0FBU0MsZ0JBQWdCQyxJQUFpQjtJQUMvQyxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0Y7QUFFQSxtQ0FBbUM7QUFDbkMsK0RBQWUxSyx3QkFBd0JBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvdmVoaWNsZUdlb0xvY2F0aW9uLnRzPzU5ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVoaWNsZVR5cGUgfSBmcm9tIFwiQC9jb25maWcvY2l0aWVzXCI7XHJcbmltcG9ydCB7IEVVUk9QRUFOX0NJVElFUyB9IGZyb20gXCJAL2NvbmZpZy9jaXRpZXNcIjtcclxuaW1wb3J0IHsgQ2l0eUNvbmZpZyB9IGZyb20gXCJAL2NvbmZpZy9jaXRpZXNcIjtcclxuXHJcbi8vID09PT09PT09PT09PT0gVFlQRVMgKGtlZXAgZXhpc3RpbmcgaW50ZXJmYWNlcyBmb3IgY29tcGF0aWJpbGl0eSkgPT09PT09PT09PT09PVxyXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uQ29vcmRpbmF0ZXMge1xyXG4gIGxhdDogbnVtYmVyO1xyXG4gIGxuZzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENpdHlTdXBwb3J0IHtcclxuICBpbkNpdHk6IGJvb2xlYW47XHJcbiAgY2l0eU5hbWU/OiBzdHJpbmc7XHJcbiAgZGlzdGFuY2U/OiBudW1iZXI7XHJcbiAgbmVhcmVzdENpdHk/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmVhcmJ5VmVoaWNsZSB7XHJcbiAgdmVoaWNsZUlkOiBzdHJpbmc7XHJcbiAgdmVoaWNsZVR5cGU6IFZlaGljbGVUeXBlO1xyXG4gIGxvY2F0aW9uOiBMb2NhdGlvbkNvb3JkaW5hdGVzO1xyXG4gIGRpc3RhbmNlOiBudW1iZXI7XHJcbiAgYmF0dGVyeUxldmVsOiBudW1iZXI7XHJcbiAgZXN0aW1hdGVkUmFuZ2U6IG51bWJlcjtcclxuICBpc0F2YWlsYWJsZTogYm9vbGVhbjtcclxuICBsYXN0VXBkYXRlOiBEYXRlO1xyXG4gIGNpdHlJZDogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBOZXcgc2ltcGxpZmllZCBzdGF0ZSBpbnRlcmZhY2VcclxuaW50ZXJmYWNlIExvY2F0aW9uU3RhdGVSZXN1bHQge1xyXG4gIGN1cnJlbnRDaXR5OiBhbnkgfCBudWxsO1xyXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcclxuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcclxuICBjYW5SZW50OiBib29sZWFuO1xyXG4gIGxhc3RVcGRhdGVkOiBudW1iZXI7XHJcbiAgbWV0aG9kOiBcImdwc1wiIHwgXCJtYW51YWxcIiB8IFwiY2FjaGVkXCI7XHJcbn1cclxuXHJcbi8vIFZlaGljbGUgbG9jYXRpb24gaW50ZXJmYWNlIChmb3IgZmxlZXQgbWFuYWdlbWVudClcclxuaW50ZXJmYWNlIFZlaGljbGVMb2NhdGlvbiB7XHJcbiAgdmVoaWNsZUlkOiBzdHJpbmc7XHJcbiAgdmVoaWNsZVR5cGU6IFZlaGljbGVUeXBlO1xyXG4gIGNpdHlJZDogc3RyaW5nO1xyXG4gIGNvb3JkaW5hdGVzOiB7XHJcbiAgICBsYXQ6IG51bWJlcjtcclxuICAgIGxuZzogbnVtYmVyO1xyXG4gIH07XHJcbiAgYmF0dGVyeUxldmVsOiBudW1iZXI7XHJcbiAgaXNBdmFpbGFibGU6IGJvb2xlYW47XHJcbiAgbGFzdFVwZGF0ZTogRGF0ZTtcclxuICBlc3RpbWF0ZWRSYW5nZTogbnVtYmVyO1xyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09IENPTlNUQU5UUyA9PT09PT09PT09PT09XHJcbmNvbnN0IEdFT0xPQ0FUSU9OX09QVElPTlM6IFBvc2l0aW9uT3B0aW9ucyA9IHtcclxuICBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlLCAvLyBMZXNzIHJlc291cmNlIGludGVuc2l2ZVxyXG4gIHRpbWVvdXQ6IDEwMDAwLCAvLyAxMCBzZWNvbmRzXHJcbiAgbWF4aW11bUFnZTogMzAwMDAwLCAvLyA1IG1pbnV0ZXMgY2FjaGVcclxufTtcclxuXHJcbmNvbnN0IFNUT1JBR0VfS0VZID0gXCJtb292ZV9jaXR5X2xvY2F0aW9uXCI7XHJcbmNvbnN0IENBQ0hFX0RVUkFUSU9OID0gMzAgKiA2MCAqIDEwMDA7IC8vIDMwIG1pbnV0ZXNcclxuXHJcbmV4cG9ydCBjbGFzcyBWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0ge1xyXG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW07XHJcbiAgcHJpdmF0ZSB2ZWhpY2xlTG9jYXRpb25zOiBNYXA8c3RyaW5nLCBWZWhpY2xlTG9jYXRpb24+ID0gbmV3IE1hcCgpO1xyXG5cclxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVmVoaWNsZUdlb2xvY2F0aW9uU3lzdGVtIHtcclxuICAgIGlmICghVmVoaWNsZUdlb2xvY2F0aW9uU3lzdGVtLmluc3RhbmNlKSB7XHJcbiAgICAgIFZlaGljbGVHZW9sb2NhdGlvblN5c3RlbS5pbnN0YW5jZSA9IG5ldyBWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0oKTtcclxuICAgICAgVmVoaWNsZUdlb2xvY2F0aW9uU3lzdGVtLmluc3RhbmNlLmluaXRpYWxpemVWZWhpY2xlRmxlZXQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0uaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGlmICghdGhpcy52ZWhpY2xlTG9jYXRpb25zLnNpemUpIHtcclxuICAgICAgdGhpcy5pbml0aWFsaXplVmVoaWNsZUZsZWV0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09IFBFUlNJU1RFTlQgTE9DQVRJT04gTUFOQUdFTUVOVCA9PT09PT09PT09PT09XHJcblxyXG4gIHByaXZhdGUgc2F2ZUxvY2F0aW9uVG9TdG9yYWdlKHN0YXRlOiBMb2NhdGlvblN0YXRlUmVzdWx0KTogdm9pZCB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc2F2ZSBsb2NhdGlvbjpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBsb2FkTG9jYXRpb25Gcm9tU3RvcmFnZSgpOiBMb2NhdGlvblN0YXRlUmVzdWx0IHwgbnVsbCB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93LnNlc3Npb25TdG9yYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpO1xyXG4gICAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzdG9yZWQpIGFzIExvY2F0aW9uU3RhdGVSZXN1bHQ7XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBjYWNoZSBpcyBzdGlsbCB2YWxpZFxyXG4gICAgICBpZiAobm93IC0gZGF0YS5sYXN0VXBkYXRlZCA+IENBQ0hFX0RVUkFUSU9OKSB7XHJcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0tFWSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGxvYWQgbG9jYXRpb246XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09IE1BSU4gTE9DQVRJT04gTUVUSE9EUyA9PT09PT09PT09PT09XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IHVzZXIgbG9jYXRpb24gd2l0aCBjYWNoaW5nXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0Q3VycmVudExvY2F0aW9uKCk6IFByb21pc2U8TG9jYXRpb25Db29yZGluYXRlcz4ge1xyXG4gICAgLy8gVHJ5IGNhY2hlIGZpcnN0IGZvciBMb2NhdGlvbkNvb3JkaW5hdGVzIGNvbXBhdGliaWxpdHlcclxuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMubG9hZExvY2F0aW9uRnJvbVN0b3JhZ2UoKTtcclxuICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmN1cnJlbnRDaXR5KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgY2FjaGVkIGxvY2F0aW9uXCIpO1xyXG4gICAgICByZXR1cm4gY2FjaGVkLmN1cnJlbnRDaXR5LmNvb3JkaW5hdGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBmcmVzaCBsb2NhdGlvblxyXG4gICAgaWYgKCFuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VvbG9jYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPExvY2F0aW9uQ29vcmRpbmF0ZXM+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcclxuICAgICAgICAocG9zaXRpb24pID0+IHtcclxuICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzOiBMb2NhdGlvbkNvb3JkaW5hdGVzID0ge1xyXG4gICAgICAgICAgICBsYXQ6IHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSxcclxuICAgICAgICAgICAgbG5nOiBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBGaW5kIGFuZCBjYWNoZSBuZWFyZXN0IGNpdHlcclxuICAgICAgICAgIGNvbnN0IG5lYXJlc3RDaXR5ID0gdGhpcy5maW5kTmVhcmVzdFN1cHBvcnRlZENpdHkoY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgICAgdGhpcy5zYXZlTG9jYXRpb25TdGF0ZShjb29yZGluYXRlcywgbmVhcmVzdENpdHkpO1xyXG5cclxuICAgICAgICAgIHJlc29sdmUoY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICBsZXQgbWVzc2FnZTogc3RyaW5nO1xyXG4gICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgZXJyb3IuUEVSTUlTU0lPTl9ERU5JRUQ6XHJcbiAgICAgICAgICAgICAgbWVzc2FnZSA9XHJcbiAgICAgICAgICAgICAgICBcIkxvY2F0aW9uIGFjY2VzcyBkZW5pZWQuIFBsZWFzZSBlbmFibGUgbG9jYXRpb24gc2VydmljZXMuXCI7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZXJyb3IuUE9TSVRJT05fVU5BVkFJTEFCTEU6XHJcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiTG9jYXRpb24gaW5mb3JtYXRpb24gdW5hdmFpbGFibGUuXCI7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZXJyb3IuVElNRU9VVDpcclxuICAgICAgICAgICAgICBtZXNzYWdlID0gXCJMb2NhdGlvbiByZXF1ZXN0IHRpbWVkIG91dC5cIjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBtZXNzYWdlID0gXCJVbmtub3duIGxvY2F0aW9uIGVycm9yLlwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtZXNzYWdlKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBHRU9MT0NBVElPTl9PUFRJT05TXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IGxvY2F0aW9uIHN0YXRlXHJcbiAgICovXHJcblxyXG4gIHByaXZhdGUgc2F2ZUxvY2F0aW9uU3RhdGUoXHJcbiAgICBjb29yZGluYXRlczogTG9jYXRpb25Db29yZGluYXRlcyxcclxuICAgIG5lYXJlc3RDaXR5OiBhbnkgfCBudWxsLFxyXG4gICAgbWV0aG9kOiBcImdwc1wiIHwgXCJtYW51YWxcIiB8IFwiY2FjaGVkXCIgPSBcImdwc1wiLFxyXG4gICAgZXJyb3I6IHN0cmluZyB8IG51bGwgPSBudWxsXHJcbiAgKTogTG9jYXRpb25TdGF0ZVJlc3VsdCB7XHJcbiAgICBjb25zdCBzdGF0ZTogTG9jYXRpb25TdGF0ZVJlc3VsdCA9IHtcclxuICAgICAgY3VycmVudENpdHk6IG5lYXJlc3RDaXR5LFxyXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogZXJyb3IsXHJcbiAgICAgIGNhblJlbnQ6ICEhbmVhcmVzdENpdHksIC8vIENhbiByZW50IGlmIHdlIGhhdmUgYW55IGNpdHkgKGV2ZW4gZmFsbGJhY2spXHJcbiAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpLFxyXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zYXZlTG9jYXRpb25Ub1N0b3JhZ2Uoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBmaW5kTmVhcmVzdFN1cHBvcnRlZENpdHkoXHJcbiAgICBjb29yZGluYXRlczogTG9jYXRpb25Db29yZGluYXRlc1xyXG4gICk6IGFueSB8IG51bGwge1xyXG4gICAgbGV0IG5lYXJlc3RDaXR5ID0gbnVsbDtcclxuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xyXG5cclxuICAgIGZvciAoY29uc3QgY2l0eSBvZiBFVVJPUEVBTl9DSVRJRVMpIHtcclxuICAgICAgY29uc3QgeyBib3VuZHMgfSA9IGNpdHk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBpbnNpZGUgY2l0eSBib3VuZHMgZmlyc3RcclxuICAgICAgaWYgKFxyXG4gICAgICAgIGNvb3JkaW5hdGVzLmxhdCA+PSBib3VuZHMuc291dGggJiZcclxuICAgICAgICBjb29yZGluYXRlcy5sYXQgPD0gYm91bmRzLm5vcnRoICYmXHJcbiAgICAgICAgY29vcmRpbmF0ZXMubG5nID49IGJvdW5kcy53ZXN0ICYmXHJcbiAgICAgICAgY29vcmRpbmF0ZXMubG5nIDw9IGJvdW5kcy5lYXN0XHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiBjaXR5OyAvLyBJbnNpZGUgY2l0eSwgcmV0dXJuIGltbWVkaWF0ZWx5XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSB0byBjaXR5IGNlbnRlclxyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoXHJcbiAgICAgICAgY29vcmRpbmF0ZXMubGF0LFxyXG4gICAgICAgIGNvb3JkaW5hdGVzLmxuZyxcclxuICAgICAgICBjaXR5LmNvb3JkaW5hdGVzLmxhdCxcclxuICAgICAgICBjaXR5LmNvb3JkaW5hdGVzLmxuZ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcclxuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgIG5lYXJlc3RDaXR5ID0gY2l0eTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE9ubHkgcmV0dXJuIGNpdHkgaWYgd2l0aGluIHJlYXNvbmFibGUgZGlzdGFuY2UgKDIwMGttKVxyXG4gICAgcmV0dXJuIG1pbkRpc3RhbmNlIDw9IDIwMCA/IG5lYXJlc3RDaXR5IDogbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEZhbGxiYWNrIG1ldGhvZCBmb3IgZGlzdGFuY2VzID49IDIwMGttc1xyXG4gIHByaXZhdGUgZ2V0SW50ZWxsaWdlbnRGYWxsYmFja0NpdHkoXHJcbiAgICBjb29yZGluYXRlczogTG9jYXRpb25Db29yZGluYXRlc1xyXG4gICk6IGFueSB8IG51bGwge1xyXG4gICAgY29uc3QgbGF0ID0gY29vcmRpbmF0ZXMubGF0O1xyXG4gICAgY29uc3QgbG5nID0gY29vcmRpbmF0ZXMubG5nO1xyXG5cclxuICAgIC8vIEV1cm9wZWFuIHJlZ2lvbnMgLSBwcm92aWRlIHNlbnNpYmxlIGRlZmF1bHRzIGJhc2VkIG9uIGdlb2dyYXBoeVxyXG4gICAgaWYgKGxhdCA+PSAzNSAmJiBsYXQgPD0gNDcgJiYgbG5nID49IDYgJiYgbG5nIDw9IDIwKSB7XHJcbiAgICAgIC8vIENlbnRyYWwvU291dGhlcm4gRXVyb3BlIChJdGFseSwgcGFydHMgb2YgR2VybWFueSwgQXVzdHJpYSwgZXRjLilcclxuICAgICAgaWYgKGxhdCA+PSA0MSAmJiBsbmcgPj0gOCAmJiBsbmcgPD0gMTkpIHtcclxuICAgICAgICByZXR1cm4gRVVST1BFQU5fQ0lUSUVTLmZpbmQoKGMpID0+IGMuaWQgPT09IFwicm9tZVwiKTsgLy8gSXRhbHkgYXJlYVxyXG4gICAgICB9IGVsc2UgaWYgKGxhdCA+PSA0NSAmJiBsbmcgPj0gNiAmJiBsbmcgPD0gMTUpIHtcclxuICAgICAgICByZXR1cm4gRVVST1BFQU5fQ0lUSUVTLmZpbmQoKGMpID0+IGMuaWQgPT09IFwibWlsYW5cIik7IC8vIE5vcnRoZXJuIEl0YWx5L0FscHNcclxuICAgICAgfSBlbHNlIGlmIChsYXQgPj0gNTAgJiYgbG5nID49IDEwICYmIGxuZyA8PSAxNSkge1xyXG4gICAgICAgIHJldHVybiBFVVJPUEVBTl9DSVRJRVMuZmluZCgoYykgPT4gYy5pZCA9PT0gXCJiZXJsaW5cIik7IC8vIEdlcm1hbnkgYXJlYVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGxhdCA+PSA0MyAmJiBsYXQgPD0gNTEgJiYgbG5nID49IC01ICYmIGxuZyA8PSA4KSB7XHJcbiAgICAgIC8vIFdlc3Rlcm4gRXVyb3BlIChGcmFuY2UsIFNwYWluLCBVSylcclxuICAgICAgaWYgKGxhdCA8PSA0Nikge1xyXG4gICAgICAgIHJldHVybiBFVVJPUEVBTl9DSVRJRVMuZmluZCgoYykgPT4gYy5pZCA9PT0gXCJtYWRyaWRcIik7IC8vIFNwYWluIGFyZWFcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gRVVST1BFQU5fQ0lUSUVTLmZpbmQoKGMpID0+IGMuaWQgPT09IFwicGFyaXNcIik7IC8vIEZyYW5jZSBhcmVhXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZhdWx0IGZhbGxiYWNrIC0gUm9tZSAoY2VudHJhbCBFdXJvcGUpXHJcbiAgICByZXR1cm4gRVVST1BFQU5fQ0lUSUVTLmZpbmQoKGMpID0+IGMuaWQgPT09IFwicm9tZVwiKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IGxvY2F0aW9uIHN0YXRlXHJcbiAgICovXHJcblxyXG4gIGFzeW5jIGdldEN1cnJlbnRMb2NhdGlvblN0YXRlKCk6IFByb21pc2U8TG9jYXRpb25TdGF0ZVJlc3VsdD4ge1xyXG4gICAgLy8gVHJ5IGNhY2hlIGZpcnN0XHJcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmxvYWRMb2NhdGlvbkZyb21TdG9yYWdlKCk7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgY2FjaGVkIGxvY2F0aW9uIHN0YXRlXCIpO1xyXG4gICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBmcmVzaCBsb2NhdGlvblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbigpO1xyXG4gICAgICBsZXQgbmVhcmVzdENpdHkgPSB0aGlzLmZpbmROZWFyZXN0U3VwcG9ydGVkQ2l0eShjb29yZGluYXRlcyk7XHJcbiAgICAgIGxldCBtZXRob2Q6IFwiZ3BzXCIgfCBcIm1hbnVhbFwiIHwgXCJjYWNoZWRcIiA9IFwiZ3BzXCI7XHJcbiAgICAgIGxldCBlcnJvcjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAvLyBJZiBubyBjaXR5IGZvdW5kIHdpdGhpbiAyMDBrbSwgdXNlIGludGVsbGlnZW50IGZhbGxiYWNrXHJcbiAgICAgIGlmICghbmVhcmVzdENpdHkpIHtcclxuICAgICAgICBuZWFyZXN0Q2l0eSA9IHRoaXMuZ2V0SW50ZWxsaWdlbnRGYWxsYmFja0NpdHkoY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgIG1ldGhvZCA9IFwibWFudWFsXCI7IC8vIE1hcmsgYXMgbWFudWFsIHNpbmNlIGl0J3MgYSBmYWxsYmFja1xyXG4gICAgICAgIGVycm9yID0gYFlvdSdyZSBvdXRzaWRlIG91ciBzZXJ2aWNlIGFyZWEuIFdlJ3ZlIHNlbGVjdGVkICR7bmVhcmVzdENpdHk/Lm5hbWV9IGFzIHRoZSBuZWFyZXN0IHN1cHBvcnRlZCBjaXR5LmA7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYPCfk40gVXNlciBsb2NhdGlvbiBvdXRzaWRlIDIwMGttIHNlcnZpY2UgYXJlYS4gRmFsbGJhY2s6ICR7bmVhcmVzdENpdHk/Lm5hbWV9YFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnNhdmVMb2NhdGlvblN0YXRlKGNvb3JkaW5hdGVzLCBuZWFyZXN0Q2l0eSwgbWV0aG9kLCBlcnJvcik7XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY3VycmVudENpdHk6IG51bGwsXHJcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBjYW5SZW50OiBmYWxzZSxcclxuICAgICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKSxcclxuICAgICAgICBtZXRob2Q6IFwiZ3BzXCIsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB1c2VyIGlzIGluIGEgc3VwcG9ydGVkIGNpdHlcclxuICAgKi9cclxuICBjaGVja0NpdHlTdXBwb3J0KGxvY2F0aW9uOiBMb2NhdGlvbkNvb3JkaW5hdGVzKTogQ2l0eVN1cHBvcnQge1xyXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBpcyB3aXRoaW4gYW55IHN1cHBvcnRlZCBjaXR5IGJvdW5kc1xyXG4gICAgZm9yIChjb25zdCBjaXR5IG9mIEVVUk9QRUFOX0NJVElFUykge1xyXG4gICAgICBjb25zdCB7IGJvdW5kcyB9ID0gY2l0eTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBsb2NhdGlvbi5sYXQgPj0gYm91bmRzLnNvdXRoICYmXHJcbiAgICAgICAgbG9jYXRpb24ubGF0IDw9IGJvdW5kcy5ub3J0aCAmJlxyXG4gICAgICAgIGxvY2F0aW9uLmxuZyA+PSBib3VuZHMud2VzdCAmJlxyXG4gICAgICAgIGxvY2F0aW9uLmxuZyA8PSBib3VuZHMuZWFzdFxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaW5DaXR5OiB0cnVlLFxyXG4gICAgICAgICAgY2l0eU5hbWU6IGNpdHkuaWQsXHJcbiAgICAgICAgICBkaXN0YW5jZTogMCxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXNlciBpcyBub3QgaW4gYSBzdXBwb3J0ZWQgY2l0eSwgZmluZCBuZWFyZXN0IG9uZVxyXG4gICAgY29uc3QgZGlzdGFuY2VzID0gRVVST1BFQU5fQ0lUSUVTLm1hcCgoY2l0eSkgPT4gKHtcclxuICAgICAgY2l0eTogY2l0eS5pZCxcclxuICAgICAgbmFtZTogY2l0eS5uYW1lLFxyXG4gICAgICBkaXN0YW5jZTogdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcclxuICAgICAgICBsb2NhdGlvbi5sYXQsXHJcbiAgICAgICAgbG9jYXRpb24ubG5nLFxyXG4gICAgICAgIGNpdHkuY29vcmRpbmF0ZXMubGF0LFxyXG4gICAgICAgIGNpdHkuY29vcmRpbmF0ZXMubG5nXHJcbiAgICAgICksXHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgbmVhcmVzdCA9IGRpc3RhbmNlcy5yZWR1Y2UoKG1pbiwgY3VycikgPT5cclxuICAgICAgY3Vyci5kaXN0YW5jZSA8IG1pbi5kaXN0YW5jZSA/IGN1cnIgOiBtaW5cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaW5DaXR5OiBmYWxzZSxcclxuICAgICAgZGlzdGFuY2U6IG5lYXJlc3QuZGlzdGFuY2UsXHJcbiAgICAgIG5lYXJlc3RDaXR5OiBuZWFyZXN0Lm5hbWUsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PSBERVZFTE9QTUVOVC9URVNUSU5HIE1FVEhPRFMgPT09PT09PT09PT09PVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgbWFudWFsIGxvY2F0aW9uIGZvciB0ZXN0aW5nXHJcbiAgICovXHJcbiAgYXN5bmMgc2V0VGVzdExvY2F0aW9uKGNpdHlJZDogc3RyaW5nKTogUHJvbWlzZTxMb2NhdGlvblN0YXRlUmVzdWx0PiB7XHJcbiAgICBjb25zdCBjaXR5ID0gRVVST1BFQU5fQ0lUSUVTLmZpbmQoKGMpID0+IGMuaWQgPT09IGNpdHlJZCk7XHJcblxyXG4gICAgaWYgKCFjaXR5KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2l0eSAke2NpdHlJZH0gbm90IGZvdW5kYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhdGU6IExvY2F0aW9uU3RhdGVSZXN1bHQgPSB7XHJcbiAgICAgIGN1cnJlbnRDaXR5OiBjaXR5LFxyXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogbnVsbCxcclxuICAgICAgY2FuUmVudDogdHJ1ZSxcclxuICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXHJcbiAgICAgIG1ldGhvZDogXCJtYW51YWxcIixcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zYXZlTG9jYXRpb25Ub1N0b3JhZ2Uoc3RhdGUpO1xyXG4gICAgY29uc29sZS5sb2coYPCfp6ogVGVzdCBsb2NhdGlvbiBzZXQ6ICR7Y2l0eS5uYW1lfWApO1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgbG9jYXRpb24gY2FjaGVcclxuICAgKi9cclxuICBjbGVhckxvY2F0aW9uQ2FjaGUoKTogdm9pZCB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLmxvZyhcIkxvY2F0aW9uIGNhY2hlIGNsZWFyZWRcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2xlYXIgbG9jYXRpb246XCIsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGxvY2F0aW9uIHBlcm1pc3Npb24gKGZvciBjb21wYXRpYmlsaXR5KVxyXG4gICAqL1xyXG4gIGFzeW5jIGNoZWNrTG9jYXRpb25QZXJtaXNzaW9uKCk6IFByb21pc2U8XCJncmFudGVkXCIgfCBcImRlbmllZFwiIHwgXCJwcm9tcHRcIj4ge1xyXG4gICAgaWYgKCFuYXZpZ2F0b3IucGVybWlzc2lvbnMpIHtcclxuICAgICAgcmV0dXJuIFwicHJvbXB0XCI7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGVybWlzc2lvbiA9IGF3YWl0IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7XHJcbiAgICAgICAgbmFtZTogXCJnZW9sb2NhdGlvblwiIGFzIFBlcm1pc3Npb25OYW1lLFxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHBlcm1pc3Npb24uc3RhdGUgYXMgXCJncmFudGVkXCIgfCBcImRlbmllZFwiIHwgXCJwcm9tcHRcIjtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBjaGVjayBsb2NhdGlvbiBwZXJtaXNzaW9uOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBcInByb21wdFwiO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PSBORUFSQlkgVkVISUNMRVMgTUVUSE9EUyA9PT09PT09PT09PT09XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBuZWFyYnkgdmVoaWNsZXMgd2l0aGluIHNwZWNpZmllZCByYWRpdXNcclxuICAgKi9cclxuICBhc3luYyBnZXROZWFyYnlWZWhpY2xlcyhcclxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbkNvb3JkaW5hdGVzLFxyXG4gICAgcmFkaXVzS206IG51bWJlciA9IDIsXHJcbiAgICB2ZWhpY2xlVHlwZT86IFZlaGljbGVUeXBlLFxyXG4gICAgb25seUF2YWlsYWJsZTogYm9vbGVhbiA9IHRydWVcclxuICApOiBQcm9taXNlPE5lYXJieVZlaGljbGVbXT4ge1xyXG4gICAgLy8gU2ltdWxhdGUgQVBJIGRlbGF5XHJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcclxuXHJcbiAgICBjb25zdCBuZWFyYnlWZWhpY2xlczogTmVhcmJ5VmVoaWNsZVtdID0gW107XHJcblxyXG4gICAgdGhpcy52ZWhpY2xlTG9jYXRpb25zLmZvckVhY2goKHZlaGljbGUpID0+IHtcclxuICAgICAgLy8gRmlsdGVyIGJ5IGF2YWlsYWJpbGl0eSBpZiByZXF1ZXN0ZWRcclxuICAgICAgaWYgKG9ubHlBdmFpbGFibGUgJiYgIXZlaGljbGUuaXNBdmFpbGFibGUpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEZpbHRlciBieSB2ZWhpY2xlIHR5cGUgaWYgc3BlY2lmaWVkXHJcbiAgICAgIGlmICh2ZWhpY2xlVHlwZSAmJiB2ZWhpY2xlLnZlaGljbGVUeXBlICE9PSB2ZWhpY2xlVHlwZSkgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKFxyXG4gICAgICAgIGxvY2F0aW9uLmxhdCxcclxuICAgICAgICBsb2NhdGlvbi5sbmcsXHJcbiAgICAgICAgdmVoaWNsZS5jb29yZGluYXRlcy5sYXQsXHJcbiAgICAgICAgdmVoaWNsZS5jb29yZGluYXRlcy5sbmdcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChkaXN0YW5jZSA8PSByYWRpdXNLbSkge1xyXG4gICAgICAgIG5lYXJieVZlaGljbGVzLnB1c2goe1xyXG4gICAgICAgICAgdmVoaWNsZUlkOiB2ZWhpY2xlLnZlaGljbGVJZCxcclxuICAgICAgICAgIHZlaGljbGVUeXBlOiB2ZWhpY2xlLnZlaGljbGVUeXBlLFxyXG4gICAgICAgICAgbG9jYXRpb246IHtcclxuICAgICAgICAgICAgbGF0OiB2ZWhpY2xlLmNvb3JkaW5hdGVzLmxhdCxcclxuICAgICAgICAgICAgbG5nOiB2ZWhpY2xlLmNvb3JkaW5hdGVzLmxuZyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkaXN0YW5jZSxcclxuICAgICAgICAgIGJhdHRlcnlMZXZlbDogdmVoaWNsZS5iYXR0ZXJ5TGV2ZWwsXHJcbiAgICAgICAgICBlc3RpbWF0ZWRSYW5nZTogdmVoaWNsZS5lc3RpbWF0ZWRSYW5nZSxcclxuICAgICAgICAgIGlzQXZhaWxhYmxlOiB2ZWhpY2xlLmlzQXZhaWxhYmxlLFxyXG4gICAgICAgICAgbGFzdFVwZGF0ZTogdmVoaWNsZS5sYXN0VXBkYXRlLFxyXG4gICAgICAgICAgY2l0eUlkOiB2ZWhpY2xlLmNpdHlJZCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU29ydCBieSBkaXN0YW5jZVxyXG4gICAgcmV0dXJuIG5lYXJieVZlaGljbGVzLnNvcnQoKGEsIGIpID0+IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlKTtcclxuICB9XHJcblxyXG4gIC8vIEdldCB2ZWhpY2xlcyBuZWFyIHVzZXIgbG9jYXRpb25cclxuICBnZXRWZWhpY2xlc05lYXJMb2NhdGlvbihcclxuICAgIHVzZXJMYXQ6IG51bWJlcixcclxuICAgIHVzZXJMbmc6IG51bWJlcixcclxuICAgIHJhZGl1c0ttOiBudW1iZXIgPSAyLFxyXG4gICAgdmVoaWNsZVR5cGU/OiBWZWhpY2xlVHlwZVxyXG4gICk6IChWZWhpY2xlTG9jYXRpb24gJiB7IGRpc3RhbmNlOiBudW1iZXIgfSlbXSB7XHJcbiAgICBjb25zdCBuZWFyYnlWZWhpY2xlczogKFZlaGljbGVMb2NhdGlvbiAmIHsgZGlzdGFuY2U6IG51bWJlciB9KVtdID0gW107XHJcblxyXG4gICAgdGhpcy52ZWhpY2xlTG9jYXRpb25zLmZvckVhY2goKHZlaGljbGUpID0+IHtcclxuICAgICAgaWYgKCF2ZWhpY2xlLmlzQXZhaWxhYmxlKSByZXR1cm47XHJcbiAgICAgIGlmICh2ZWhpY2xlVHlwZSAmJiB2ZWhpY2xlLnZlaGljbGVUeXBlICE9PSB2ZWhpY2xlVHlwZSkgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKFxyXG4gICAgICAgIHVzZXJMYXQsXHJcbiAgICAgICAgdXNlckxuZyxcclxuICAgICAgICB2ZWhpY2xlLmNvb3JkaW5hdGVzLmxhdCxcclxuICAgICAgICB2ZWhpY2xlLmNvb3JkaW5hdGVzLmxuZ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGRpc3RhbmNlIDw9IHJhZGl1c0ttKSB7XHJcbiAgICAgICAgbmVhcmJ5VmVoaWNsZXMucHVzaCh7XHJcbiAgICAgICAgICAuLi52ZWhpY2xlLFxyXG4gICAgICAgICAgZGlzdGFuY2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZWFyYnlWZWhpY2xlcy5zb3J0KChhLCBiKSA9PiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZSk7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgdmVoaWNsZXMgaW4gc3BlY2lmaWMgY2l0eVxyXG4gIGdldFZlaGljbGVzSW5DaXR5KFxyXG4gICAgY2l0eUlkOiBzdHJpbmcsXHJcbiAgICB2ZWhpY2xlVHlwZT86IFZlaGljbGVUeXBlXHJcbiAgKTogVmVoaWNsZUxvY2F0aW9uW10ge1xyXG4gICAgY29uc3QgY2l0eVZlaGljbGVzOiBWZWhpY2xlTG9jYXRpb25bXSA9IFtdO1xyXG5cclxuICAgIHRoaXMudmVoaWNsZUxvY2F0aW9ucy5mb3JFYWNoKCh2ZWhpY2xlKSA9PiB7XHJcbiAgICAgIGlmICh2ZWhpY2xlLmNpdHlJZCAhPT0gY2l0eUlkKSByZXR1cm47XHJcbiAgICAgIGlmICghdmVoaWNsZS5pc0F2YWlsYWJsZSkgcmV0dXJuO1xyXG4gICAgICBpZiAodmVoaWNsZVR5cGUgJiYgdmVoaWNsZS52ZWhpY2xlVHlwZSAhPT0gdmVoaWNsZVR5cGUpIHJldHVybjtcclxuXHJcbiAgICAgIGNpdHlWZWhpY2xlcy5wdXNoKHZlaGljbGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNpdHlWZWhpY2xlcztcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT0gVVRJTElUWSBNRVRIT0RTID09PT09PT09PT09PT1cclxuXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVEaXN0YW5jZShcclxuICAgIGxhdDE6IG51bWJlcixcclxuICAgIGxuZzE6IG51bWJlcixcclxuICAgIGxhdDI6IG51bWJlcixcclxuICAgIGxuZzI6IG51bWJlclxyXG4gICk6IG51bWJlciB7XHJcbiAgICBjb25zdCBSID0gNjM3MTsgLy8gRWFydGgncyByYWRpdXMgaW4ga2lsb21ldGVyc1xyXG4gICAgY29uc3QgZExhdCA9IHRoaXMudG9SYWRpYW5zKGxhdDIgLSBsYXQxKTtcclxuICAgIGNvbnN0IGRMbmcgPSB0aGlzLnRvUmFkaWFucyhsbmcyIC0gbG5nMSk7XHJcblxyXG4gICAgY29uc3QgYSA9XHJcbiAgICAgIE1hdGguc2luKGRMYXQgLyAyKSAqIE1hdGguc2luKGRMYXQgLyAyKSArXHJcbiAgICAgIE1hdGguY29zKHRoaXMudG9SYWRpYW5zKGxhdDEpKSAqXHJcbiAgICAgICAgTWF0aC5jb3ModGhpcy50b1JhZGlhbnMobGF0MikpICpcclxuICAgICAgICBNYXRoLnNpbihkTG5nIC8gMikgKlxyXG4gICAgICAgIE1hdGguc2luKGRMbmcgLyAyKTtcclxuXHJcbiAgICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcclxuICAgIHJldHVybiBSICogYztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdG9SYWRpYW5zKGRlZ3JlZXM6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT0gVkVISUNMRSBGTEVFVCBNRVRIT0RTIChleGlzdGluZykgPT09PT09PT09PT09PVxyXG5cclxuICBpbml0aWFsaXplVmVoaWNsZUZsZWV0KCk6IHZvaWQge1xyXG4gICAgRVVST1BFQU5fQ0lUSUVTLmZvckVhY2goKGNpdHkpID0+IHtcclxuICAgICAgT2JqZWN0LmVudHJpZXMoY2l0eS52ZWhpY2xlTGltaXQpLmZvckVhY2goKFt2ZWhpY2xlVHlwZSwgbGltaXRdKSA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgbGltaXQgPiAwICYmXHJcbiAgICAgICAgICBjaXR5LmFsbG93ZWRWZWhpY2xlcy5pbmNsdWRlcyh2ZWhpY2xlVHlwZSBhcyBWZWhpY2xlVHlwZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZWhpY2xlSWQgPSB0aGlzLmdlbmVyYXRlVmVoaWNsZUlkKFxyXG4gICAgICAgICAgICAgIGNpdHkuaWQsXHJcbiAgICAgICAgICAgICAgdmVoaWNsZVR5cGUgYXMgVmVoaWNsZVR5cGUsXHJcbiAgICAgICAgICAgICAgaVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2VuZXJhdGVSYW5kb21Mb2NhdGlvbkluQ2l0eShjaXR5KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmVoaWNsZUxvY2F0aW9ucy5zZXQodmVoaWNsZUlkLCB7XHJcbiAgICAgICAgICAgICAgdmVoaWNsZUlkLFxyXG4gICAgICAgICAgICAgIHZlaGljbGVUeXBlOiB2ZWhpY2xlVHlwZSBhcyBWZWhpY2xlVHlwZSxcclxuICAgICAgICAgICAgICBjaXR5SWQ6IGNpdHkuaWQsXHJcbiAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGxvY2F0aW9uLFxyXG4gICAgICAgICAgICAgIGJhdHRlcnlMZXZlbDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNDApICsgNjAsIC8vIDYwLTEwMCVcclxuICAgICAgICAgICAgICBpc0F2YWlsYWJsZTogTWF0aC5yYW5kb20oKSA+IDAuMTUsIC8vIDg1JSBhdmFpbGFibGVcclxuICAgICAgICAgICAgICBsYXN0VXBkYXRlOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgIGVzdGltYXRlZFJhbmdlOiB0aGlzLmNhbGN1bGF0ZVJhbmdlKHZlaGljbGVUeXBlIGFzIFZlaGljbGVUeXBlKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZVZlaGljbGVJZChcclxuICAgIGNpdHlJZDogc3RyaW5nLFxyXG4gICAgdmVoaWNsZVR5cGU6IFZlaGljbGVUeXBlLFxyXG4gICAgaW5kZXg6IG51bWJlclxyXG4gICk6IHN0cmluZyB7XHJcbiAgICBjb25zdCB0eXBlQ29kZSA9IHtcclxuICAgICAgYmlrZTogXCJCS1wiLFxyXG4gICAgICBzY29vdGVyOiBcIlNDXCIsXHJcbiAgICAgIG1vbm9wYXR0aW5vOiBcIk1QXCIsXHJcbiAgICB9W3ZlaGljbGVUeXBlXTtcclxuXHJcbiAgICBjb25zdCBjaXR5Q29kZSA9IGNpdHlJZC5zdWJzdHJpbmcoMCwgMykudG9VcHBlckNhc2UoKTtcclxuICAgIHJldHVybiBgTU9PVkUtJHtjaXR5Q29kZX0tJHt0eXBlQ29kZX0tJHsoaW5kZXggKyAxKVxyXG4gICAgICAudG9TdHJpbmcoKVxyXG4gICAgICAucGFkU3RhcnQoMywgXCIwXCIpfWA7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdlbmVyYXRlUmFuZG9tTG9jYXRpb25JbkNpdHkoY2l0eTogQ2l0eUNvbmZpZyk6IHtcclxuICAgIGxhdDogbnVtYmVyO1xyXG4gICAgbG5nOiBudW1iZXI7XHJcbiAgfSB7XHJcbiAgICBjb25zdCBsYXRSYW5nZSA9IGNpdHkuYm91bmRzLm5vcnRoIC0gY2l0eS5ib3VuZHMuc291dGg7XHJcbiAgICBjb25zdCBsbmdSYW5nZSA9IGNpdHkuYm91bmRzLmVhc3QgLSBjaXR5LmJvdW5kcy53ZXN0O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxhdDogY2l0eS5ib3VuZHMuc291dGggKyBNYXRoLnJhbmRvbSgpICogbGF0UmFuZ2UsXHJcbiAgICAgIGxuZzogY2l0eS5ib3VuZHMud2VzdCArIE1hdGgucmFuZG9tKCkgKiBsbmdSYW5nZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNhbGN1bGF0ZVJhbmdlKHZlaGljbGVUeXBlOiBWZWhpY2xlVHlwZSk6IG51bWJlciB7XHJcbiAgICBjb25zdCByYW5nZXMgPSB7XHJcbiAgICAgIGJpa2U6IFsyNSwgNTBdLCAvLyAyNS01MGttXHJcbiAgICAgIHNjb290ZXI6IFszMCwgNjBdLCAvLyAzMC02MGttXHJcbiAgICAgIG1vbm9wYXR0aW5vOiBbMTUsIDM1XSwgLy8gMTUtMzVrbVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBbbWluLCBtYXhdID0gcmFuZ2VzW3ZlaGljbGVUeXBlXTtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xyXG4gIH1cclxuXHJcbiAgLy8gVmVoaWNsZSBtYW5hZ2VtZW50IG1ldGhvZHMgKGV4aXN0aW5nKVxyXG4gIHJlc2VydmVWZWhpY2xlKHZlaGljbGVJZDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCB2ZWhpY2xlID0gdGhpcy52ZWhpY2xlTG9jYXRpb25zLmdldCh2ZWhpY2xlSWQpO1xyXG4gICAgaWYgKHZlaGljbGUgJiYgdmVoaWNsZS5pc0F2YWlsYWJsZSkge1xyXG4gICAgICB2ZWhpY2xlLmlzQXZhaWxhYmxlID0gZmFsc2U7XHJcbiAgICAgIHZlaGljbGUubGFzdFVwZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmVsZWFzZVZlaGljbGUoXHJcbiAgICB2ZWhpY2xlSWQ6IHN0cmluZyxcclxuICAgIG5ld0xvY2F0aW9uPzogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfVxyXG4gICk6IHZvaWQge1xyXG4gICAgY29uc3QgdmVoaWNsZSA9IHRoaXMudmVoaWNsZUxvY2F0aW9ucy5nZXQodmVoaWNsZUlkKTtcclxuICAgIGlmICh2ZWhpY2xlKSB7XHJcbiAgICAgIHZlaGljbGUuaXNBdmFpbGFibGUgPSB0cnVlO1xyXG4gICAgICB2ZWhpY2xlLmxhc3RVcGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBpZiAobmV3TG9jYXRpb24pIHtcclxuICAgICAgICB2ZWhpY2xlLmNvb3JkaW5hdGVzID0gbmV3TG9jYXRpb247XHJcbiAgICAgIH1cclxuICAgICAgdmVoaWNsZS5iYXR0ZXJ5TGV2ZWwgPSBNYXRoLm1heChcclxuICAgICAgICAwLFxyXG4gICAgICAgIHZlaGljbGUuYmF0dGVyeUxldmVsIC0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRWZWhpY2xlKHZlaGljbGVJZDogc3RyaW5nKTogVmVoaWNsZUxvY2F0aW9uIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLnZlaGljbGVMb2NhdGlvbnMuZ2V0KHZlaGljbGVJZCk7XHJcbiAgfVxyXG5cclxuICBnZXRBbGxWZWhpY2xlcygpOiBWZWhpY2xlTG9jYXRpb25bXSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnZlaGljbGVMb2NhdGlvbnMudmFsdWVzKCkpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlVmVoaWNsZUxvY2F0aW9uKFxyXG4gICAgdmVoaWNsZUlkOiBzdHJpbmcsXHJcbiAgICBuZXdMb2NhdGlvbjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfVxyXG4gICk6IHZvaWQge1xyXG4gICAgY29uc3QgdmVoaWNsZSA9IHRoaXMudmVoaWNsZUxvY2F0aW9ucy5nZXQodmVoaWNsZUlkKTtcclxuICAgIGlmICh2ZWhpY2xlKSB7XHJcbiAgICAgIHZlaGljbGUuY29vcmRpbmF0ZXMgPSBuZXdMb2NhdGlvbjtcclxuICAgICAgdmVoaWNsZS5sYXN0VXBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT0gSEVMUEVSIEZVTkNUSU9OUyAoZXhpc3RpbmcpID09PT09PT09PT09PT1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREaXN0YW5jZShkaXN0YW5jZUttOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIGlmIChkaXN0YW5jZUttIDwgMC4xKSB7XHJcbiAgICByZXR1cm4gXCJWZXJ5IGNsb3NlXCI7XHJcbiAgfSBlbHNlIGlmIChkaXN0YW5jZUttIDwgMSkge1xyXG4gICAgcmV0dXJuIGAke01hdGgucm91bmQoZGlzdGFuY2VLbSAqIDEwMDApfW1gO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gYCR7ZGlzdGFuY2VLbS50b0ZpeGVkKDEpfWttYDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXR0ZXJ5Q29sb3IobGV2ZWw6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgaWYgKGxldmVsID4gNzApIHJldHVybiBcInRleHQtZ3JlZW4tNjAwXCI7XHJcbiAgaWYgKGxldmVsID4gMzApIHJldHVybiBcInRleHQteWVsbG93LTYwMFwiO1xyXG4gIHJldHVybiBcInRleHQtcmVkLTYwMFwiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVoaWNsZUVtb2ppKHR5cGU6IFZlaGljbGVUeXBlKTogc3RyaW5nIHtcclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgXCJiaWtlXCI6XHJcbiAgICAgIHJldHVybiBcIvCfmrJcIjtcclxuICAgIGNhc2UgXCJzY29vdGVyXCI6XHJcbiAgICAgIHJldHVybiBcIvCfm7RcIjtcclxuICAgIGNhc2UgXCJtb25vcGF0dGlub1wiOlxyXG4gICAgICByZXR1cm4gXCLwn5u1XCI7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gXCLwn5qyXCI7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgZGVmYXVsdCBmb3IgY29tcGF0aWJpbGl0eVxyXG5leHBvcnQgZGVmYXVsdCBWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW07XHJcbiJdLCJuYW1lcyI6WyJFVVJPUEVBTl9DSVRJRVMiLCJHRU9MT0NBVElPTl9PUFRJT05TIiwiZW5hYmxlSGlnaEFjY3VyYWN5IiwidGltZW91dCIsIm1heGltdW1BZ2UiLCJTVE9SQUdFX0tFWSIsIkNBQ0hFX0RVUkFUSU9OIiwiVmVoaWNsZUdlb2xvY2F0aW9uU3lzdGVtIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImluaXRpYWxpemVWZWhpY2xlRmxlZXQiLCJzYXZlTG9jYXRpb25Ub1N0b3JhZ2UiLCJzdGF0ZSIsIndpbmRvdyIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwibG9hZExvY2F0aW9uRnJvbVN0b3JhZ2UiLCJzdG9yZWQiLCJnZXRJdGVtIiwiZGF0YSIsInBhcnNlIiwibm93IiwiRGF0ZSIsImxhc3RVcGRhdGVkIiwicmVtb3ZlSXRlbSIsImdldEN1cnJlbnRMb2NhdGlvbiIsImNhY2hlZCIsImN1cnJlbnRDaXR5IiwibG9nIiwiY29vcmRpbmF0ZXMiLCJuYXZpZ2F0b3IiLCJnZW9sb2NhdGlvbiIsIkVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJnZXRDdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvbiIsImxhdCIsImNvb3JkcyIsImxhdGl0dWRlIiwibG5nIiwibG9uZ2l0dWRlIiwibmVhcmVzdENpdHkiLCJmaW5kTmVhcmVzdFN1cHBvcnRlZENpdHkiLCJzYXZlTG9jYXRpb25TdGF0ZSIsIm1lc3NhZ2UiLCJjb2RlIiwiUEVSTUlTU0lPTl9ERU5JRUQiLCJQT1NJVElPTl9VTkFWQUlMQUJMRSIsIlRJTUVPVVQiLCJtZXRob2QiLCJpc0xvYWRpbmciLCJjYW5SZW50IiwibWluRGlzdGFuY2UiLCJJbmZpbml0eSIsImNpdHkiLCJib3VuZHMiLCJzb3V0aCIsIm5vcnRoIiwid2VzdCIsImVhc3QiLCJkaXN0YW5jZSIsImNhbGN1bGF0ZURpc3RhbmNlIiwiZ2V0SW50ZWxsaWdlbnRGYWxsYmFja0NpdHkiLCJmaW5kIiwiYyIsImlkIiwiZ2V0Q3VycmVudExvY2F0aW9uU3RhdGUiLCJuYW1lIiwiY2hlY2tDaXR5U3VwcG9ydCIsImxvY2F0aW9uIiwiaW5DaXR5IiwiY2l0eU5hbWUiLCJkaXN0YW5jZXMiLCJtYXAiLCJuZWFyZXN0IiwicmVkdWNlIiwibWluIiwiY3VyciIsInNldFRlc3RMb2NhdGlvbiIsImNpdHlJZCIsImNsZWFyTG9jYXRpb25DYWNoZSIsImNoZWNrTG9jYXRpb25QZXJtaXNzaW9uIiwicGVybWlzc2lvbnMiLCJwZXJtaXNzaW9uIiwicXVlcnkiLCJnZXROZWFyYnlWZWhpY2xlcyIsInJhZGl1c0ttIiwidmVoaWNsZVR5cGUiLCJvbmx5QXZhaWxhYmxlIiwic2V0VGltZW91dCIsIm5lYXJieVZlaGljbGVzIiwidmVoaWNsZUxvY2F0aW9ucyIsImZvckVhY2giLCJ2ZWhpY2xlIiwiaXNBdmFpbGFibGUiLCJwdXNoIiwidmVoaWNsZUlkIiwiYmF0dGVyeUxldmVsIiwiZXN0aW1hdGVkUmFuZ2UiLCJsYXN0VXBkYXRlIiwic29ydCIsImEiLCJiIiwiZ2V0VmVoaWNsZXNOZWFyTG9jYXRpb24iLCJ1c2VyTGF0IiwidXNlckxuZyIsImdldFZlaGljbGVzSW5DaXR5IiwiY2l0eVZlaGljbGVzIiwibGF0MSIsImxuZzEiLCJsYXQyIiwibG5nMiIsIlIiLCJkTGF0IiwidG9SYWRpYW5zIiwiZExuZyIsIk1hdGgiLCJzaW4iLCJjb3MiLCJhdGFuMiIsInNxcnQiLCJkZWdyZWVzIiwiUEkiLCJPYmplY3QiLCJlbnRyaWVzIiwidmVoaWNsZUxpbWl0IiwibGltaXQiLCJhbGxvd2VkVmVoaWNsZXMiLCJpbmNsdWRlcyIsImkiLCJnZW5lcmF0ZVZlaGljbGVJZCIsImdlbmVyYXRlUmFuZG9tTG9jYXRpb25JbkNpdHkiLCJzZXQiLCJmbG9vciIsInJhbmRvbSIsImNhbGN1bGF0ZVJhbmdlIiwiaW5kZXgiLCJ0eXBlQ29kZSIsImJpa2UiLCJzY29vdGVyIiwibW9ub3BhdHRpbm8iLCJjaXR5Q29kZSIsInN1YnN0cmluZyIsInRvVXBwZXJDYXNlIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImxhdFJhbmdlIiwibG5nUmFuZ2UiLCJyYW5nZXMiLCJtYXgiLCJyZXNlcnZlVmVoaWNsZSIsImdldCIsInJlbGVhc2VWZWhpY2xlIiwibmV3TG9jYXRpb24iLCJnZXRWZWhpY2xlIiwiZ2V0QWxsVmVoaWNsZXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJ1cGRhdGVWZWhpY2xlTG9jYXRpb24iLCJjb25zdHJ1Y3RvciIsIk1hcCIsInNpemUiLCJmb3JtYXREaXN0YW5jZSIsImRpc3RhbmNlS20iLCJyb3VuZCIsInRvRml4ZWQiLCJnZXRCYXR0ZXJ5Q29sb3IiLCJsZXZlbCIsImdldFZlaGljbGVFbW9qaSIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/vehicleGeoLocation.ts\n"));

/***/ })

});