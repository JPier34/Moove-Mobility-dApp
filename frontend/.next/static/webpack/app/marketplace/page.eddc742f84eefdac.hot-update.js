"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/marketplace/page",{

/***/ "(app-pages-browser)/./hooks/useLocationAndCity.ts":
/*!*************************************!*\
  !*** ./hooks/useLocationAndCity.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLocationAndCity: function() { return /* binding */ useLocationAndCity; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_vehicleGeoLocation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/vehicleGeoLocation */ \"(app-pages-browser)/./utils/vehicleGeoLocation.ts\");\n// hooks/useLocationAndCity.ts - Fixed to match marketplace expectations\n\n\nfunction useLocationAndCity() {\n    const [locationState, setLocationState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        currentCity: null,\n        isLoading: true,\n        error: null,\n        canRent: false,\n        nearbyVehicles: [],\n        location: null,\n        showLocationModal: false,\n        locationMethod: \"none\"\n    });\n    const geoSystem = new _utils_vehicleGeoLocation__WEBPACK_IMPORTED_MODULE_1__.VehicleGeolocationSystem();\n    const refreshLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setLocationState((prev)=>({\n                ...prev,\n                isLoading: true,\n                error: null,\n                showLocationModal: false\n            }));\n        try {\n            // Use the new getCurrentLocationState method\n            const locationStateResult = await geoSystem.getCurrentLocationState();\n            // Get fresh coordinates for location field\n            let coordinates = null;\n            try {\n                const freshLocation = await geoSystem.getCurrentLocation();\n                coordinates = freshLocation;\n            } catch (coordError) {\n                var _locationStateResult_currentCity;\n                // If coordinates fail, try to use city coordinates as fallback\n                if ((_locationStateResult_currentCity = locationStateResult.currentCity) === null || _locationStateResult_currentCity === void 0 ? void 0 : _locationStateResult_currentCity.coordinates) {\n                    coordinates = locationStateResult.currentCity.coordinates;\n                }\n            }\n            // Determine location method based on the result\n            let locationMethod = \"none\";\n            if (locationStateResult.method === \"gps\") {\n                locationMethod = locationStateResult.error ? \"manual\" : \"gps\"; // Manual if fallback was used\n            } else if (locationStateResult.method === \"manual\") {\n                locationMethod = \"manual\";\n            }\n            setLocationState((prev)=>({\n                    ...prev,\n                    currentCity: locationStateResult.currentCity,\n                    isLoading: false,\n                    error: locationStateResult.error,\n                    canRent: locationStateResult.canRent,\n                    location: coordinates,\n                    locationMethod: locationMethod,\n                    showLocationModal: false\n                }));\n            // Development fallback\n            if ( true && !locationStateResult.canRent && locationStateResult.error) {\n                console.log(\"\\uD83C\\uDFD7️ Development mode: Auto-setting Rome as test location...\");\n                try {\n                    const testState = await geoSystem.setTestLocation(\"rome\");\n                    setLocationState((prev)=>{\n                        var _testState_currentCity;\n                        return {\n                            ...prev,\n                            currentCity: testState.currentCity,\n                            isLoading: false,\n                            error: \"Dev mode: Using \".concat((_testState_currentCity = testState.currentCity) === null || _testState_currentCity === void 0 ? void 0 : _testState_currentCity.name, \". Original error: \").concat(locationStateResult.error),\n                            canRent: testState.canRent,\n                            locationMethod: \"manual\",\n                            showLocationModal: false\n                        };\n                    });\n                } catch (testError) {\n                    console.error(\"Test location failed:\", testError);\n                }\n            }\n        } catch (error) {\n            setLocationState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    error: error.message || \"Location access failed\",\n                    canRent: false,\n                    showLocationModal: true,\n                    locationMethod: \"none\"\n                }));\n        }\n    }, []);\n    const setTestLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cityId)=>{\n        setLocationState((prev)=>({\n                ...prev,\n                isLoading: true,\n                error: null\n            }));\n        try {\n            var _testState_currentCity;\n            const testState = await geoSystem.setTestLocation(cityId);\n            // Get city coordinates\n            const cityCoordinates = ((_testState_currentCity = testState.currentCity) === null || _testState_currentCity === void 0 ? void 0 : _testState_currentCity.coordinates) || null;\n            setLocationState((prev)=>({\n                    ...prev,\n                    currentCity: testState.currentCity,\n                    isLoading: false,\n                    error: null,\n                    canRent: testState.canRent,\n                    location: cityCoordinates,\n                    locationMethod: \"manual\",\n                    showLocationModal: false\n                }));\n            console.log(\"\\uD83E\\uDDEA Test location set: \".concat(cityId));\n        } catch (error) {\n            setLocationState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    error: error.message,\n                    locationMethod: \"none\"\n                }));\n        }\n    }, []);\n    const clearLocation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        geoSystem.clearLocationCache();\n        setLocationState({\n            currentCity: null,\n            isLoading: false,\n            error: null,\n            canRent: false,\n            nearbyVehicles: [],\n            location: null,\n            showLocationModal: false,\n            locationMethod: \"none\"\n        });\n        console.log(\"\\uD83D\\uDDD1️ Location cleared\");\n    }, []);\n    // Initialize on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let mounted = true;\n        const initialize = async ()=>{\n            if (!mounted) return;\n            await refreshLocation();\n        };\n        initialize();\n        return ()=>{\n            mounted = false;\n        };\n    }, [\n        refreshLocation\n    ]);\n    // Return extended state with both location and coordinates (same value)\n    return {\n        ...locationState,\n        coordinates: locationState.location,\n        refreshLocation,\n        setTestLocation,\n        clearLocation\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUxvY2F0aW9uQW5kQ2l0eS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsd0VBQXdFO0FBRWY7QUFDYTtBQXlCL0QsU0FBU0k7SUFDZCxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHTiwrQ0FBUUEsQ0FBZ0I7UUFDaEVPLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsZ0JBQWdCLEVBQUU7UUFDbEJDLFVBQVU7UUFDVkMsbUJBQW1CO1FBQ25CQyxnQkFBZ0I7SUFDbEI7SUFFQSxNQUFNQyxZQUFZLElBQUlaLCtFQUF3QkE7SUFFOUMsTUFBTWEsa0JBQWtCZCxrREFBV0EsQ0FBQztRQUNsQ0ksaUJBQWlCLENBQUNXLE9BQVU7Z0JBQzFCLEdBQUdBLElBQUk7Z0JBQ1BULFdBQVc7Z0JBQ1hDLE9BQU87Z0JBQ1BJLG1CQUFtQjtZQUNyQjtRQUVBLElBQUk7WUFDRiw2Q0FBNkM7WUFDN0MsTUFBTUssc0JBQXNCLE1BQU1ILFVBQVVJLHVCQUF1QjtZQUVuRSwyQ0FBMkM7WUFDM0MsSUFBSUMsY0FBbUQ7WUFDdkQsSUFBSTtnQkFDRixNQUFNQyxnQkFBZ0IsTUFBTU4sVUFBVU8sa0JBQWtCO2dCQUN4REYsY0FBY0M7WUFDaEIsRUFBRSxPQUFPRSxZQUFZO29CQUVmTDtnQkFESiwrREFBK0Q7Z0JBQy9ELEtBQUlBLG1DQUFBQSxvQkFBb0JYLFdBQVcsY0FBL0JXLHVEQUFBQSxpQ0FBaUNFLFdBQVcsRUFBRTtvQkFDaERBLGNBQWNGLG9CQUFvQlgsV0FBVyxDQUFDYSxXQUFXO2dCQUMzRDtZQUNGO1lBRUEsZ0RBQWdEO1lBQ2hELElBQUlOLGlCQUE0QztZQUNoRCxJQUFJSSxvQkFBb0JNLE1BQU0sS0FBSyxPQUFPO2dCQUN4Q1YsaUJBQWlCSSxvQkFBb0JULEtBQUssR0FBRyxXQUFXLE9BQU8sOEJBQThCO1lBQy9GLE9BQU8sSUFBSVMsb0JBQW9CTSxNQUFNLEtBQUssVUFBVTtn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O1FBRUFzQjtRQUVBLE9BQU87WUFDTEQsVUFBVTtRQUNaO0lBQ0YsR0FBRztRQUFDckI7S0FBZ0I7SUFFcEIsd0VBQXdFO0lBQ3hFLE9BQU87UUFDTCxHQUFHWCxhQUFhO1FBQ2hCZSxhQUFhZixjQUFjTyxRQUFRO1FBQ25DSTtRQUNBYTtRQUNBTTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlTG9jYXRpb25BbmRDaXR5LnRzPzhiZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaG9va3MvdXNlTG9jYXRpb25BbmRDaXR5LnRzIC0gRml4ZWQgdG8gbWF0Y2ggbWFya2V0cGxhY2UgZXhwZWN0YXRpb25zXHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBWZWhpY2xlR2VvbG9jYXRpb25TeXN0ZW0gfSBmcm9tIFwiQC91dGlscy92ZWhpY2xlR2VvTG9jYXRpb25cIjtcclxuaW1wb3J0IHsgRVVST1BFQU5fQ0lUSUVTIH0gZnJvbSBcIkAvY29uZmlnL2NpdGllc1wiO1xyXG5cclxuLy8gSW50ZXJmYWNlIHRoYXQgbWF0Y2hlcyB3aGF0IHlvdXIgbWFya2V0cGxhY2UgZXhwZWN0c1xyXG5pbnRlcmZhY2UgTG9jYXRpb25TdGF0ZSB7XHJcbiAgY3VycmVudENpdHk6IGFueSB8IG51bGw7XHJcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xyXG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xyXG4gIGNhblJlbnQ6IGJvb2xlYW47XHJcbiAgbmVhcmJ5VmVoaWNsZXM6IGFueVtdOyAvLyBBZGRlZCBmb3IgY29tcGF0aWJpbGl0eVxyXG4gIGxvY2F0aW9uOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbDsgLy8gVGhpcyBpcyBjb29yZGluYXRlc1xyXG4gIHNob3dMb2NhdGlvbk1vZGFsOiBib29sZWFuO1xyXG4gIGxvY2F0aW9uTWV0aG9kOiBcImdwc1wiIHwgXCJtYW51YWxcIiB8IFwibm9uZVwiO1xyXG59XHJcblxyXG4vLyBFeHRlbmRlZCBpbnRlcmZhY2Ugd2l0aCBmdW5jdGlvbnNcclxuaW50ZXJmYWNlIEV4dGVuZGVkTG9jYXRpb25TdGF0ZSBleHRlbmRzIExvY2F0aW9uU3RhdGUge1xyXG4gIGNvb3JkaW5hdGVzOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbDsgLy8gQWxpYXMgZm9yIGxvY2F0aW9uXHJcbiAgcmVmcmVzaExvY2F0aW9uOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHNldFRlc3RMb2NhdGlvbjogKFxyXG4gICAgY2l0eUlkOiBcInJvbWVcIiB8IFwibWlsYW5cIiB8IFwicGFyaXNcIiB8IFwiYmVybGluXCIgfCBcIm1hZHJpZFwiXHJcbiAgKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGNsZWFyTG9jYXRpb246ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhdGlvbkFuZENpdHkoKTogRXh0ZW5kZWRMb2NhdGlvblN0YXRlIHtcclxuICBjb25zdCBbbG9jYXRpb25TdGF0ZSwgc2V0TG9jYXRpb25TdGF0ZV0gPSB1c2VTdGF0ZTxMb2NhdGlvblN0YXRlPih7XHJcbiAgICBjdXJyZW50Q2l0eTogbnVsbCxcclxuICAgIGlzTG9hZGluZzogdHJ1ZSxcclxuICAgIGVycm9yOiBudWxsLFxyXG4gICAgY2FuUmVudDogZmFsc2UsXHJcbiAgICBuZWFyYnlWZWhpY2xlczogW10sXHJcbiAgICBsb2NhdGlvbjogbnVsbCxcclxuICAgIHNob3dMb2NhdGlvbk1vZGFsOiBmYWxzZSxcclxuICAgIGxvY2F0aW9uTWV0aG9kOiBcIm5vbmVcIixcclxuICB9KTtcclxuXHJcbiAgY29uc3QgZ2VvU3lzdGVtID0gbmV3IFZlaGljbGVHZW9sb2NhdGlvblN5c3RlbSgpO1xyXG5cclxuICBjb25zdCByZWZyZXNoTG9jYXRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICBzZXRMb2NhdGlvblN0YXRlKChwcmV2KSA9PiAoe1xyXG4gICAgICAuLi5wcmV2LFxyXG4gICAgICBpc0xvYWRpbmc6IHRydWUsXHJcbiAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICBzaG93TG9jYXRpb25Nb2RhbDogZmFsc2UsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVXNlIHRoZSBuZXcgZ2V0Q3VycmVudExvY2F0aW9uU3RhdGUgbWV0aG9kXHJcbiAgICAgIGNvbnN0IGxvY2F0aW9uU3RhdGVSZXN1bHQgPSBhd2FpdCBnZW9TeXN0ZW0uZ2V0Q3VycmVudExvY2F0aW9uU3RhdGUoKTtcclxuXHJcbiAgICAgIC8vIEdldCBmcmVzaCBjb29yZGluYXRlcyBmb3IgbG9jYXRpb24gZmllbGRcclxuICAgICAgbGV0IGNvb3JkaW5hdGVzOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZnJlc2hMb2NhdGlvbiA9IGF3YWl0IGdlb1N5c3RlbS5nZXRDdXJyZW50TG9jYXRpb24oKTtcclxuICAgICAgICBjb29yZGluYXRlcyA9IGZyZXNoTG9jYXRpb247XHJcbiAgICAgIH0gY2F0Y2ggKGNvb3JkRXJyb3IpIHtcclxuICAgICAgICAvLyBJZiBjb29yZGluYXRlcyBmYWlsLCB0cnkgdG8gdXNlIGNpdHkgY29vcmRpbmF0ZXMgYXMgZmFsbGJhY2tcclxuICAgICAgICBpZiAobG9jYXRpb25TdGF0ZVJlc3VsdC5jdXJyZW50Q2l0eT8uY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gbG9jYXRpb25TdGF0ZVJlc3VsdC5jdXJyZW50Q2l0eS5jb29yZGluYXRlcztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsb2NhdGlvbiBtZXRob2QgYmFzZWQgb24gdGhlIHJlc3VsdFxyXG4gICAgICBsZXQgbG9jYXRpb25NZXRob2Q6IFwiZ3BzXCIgfCBcIm1hbnVhbFwiIHwgXCJub25lXCIgPSBcIm5vbmVcIjtcclxuICAgICAgaWYgKGxvY2F0aW9uU3RhdGVSZXN1bHQubWV0aG9kID09PSBcImdwc1wiKSB7XHJcbiAgICAgICAgbG9jYXRpb25NZXRob2QgPSBsb2NhdGlvblN0YXRlUmVzdWx0LmVycm9yID8gXCJtYW51YWxcIiA6IFwiZ3BzXCI7IC8vIE1hbnVhbCBpZiBmYWxsYmFjayB3YXMgdXNlZFxyXG4gICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uU3RhdGVSZXN1bHQubWV0aG9kID09PSBcIm1hbnVhbFwiKSB7XHJcbiAgICAgICAgbG9jYXRpb25NZXRob2QgPSBcIm1hbnVhbFwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRMb2NhdGlvblN0YXRlKChwcmV2KSA9PiAoe1xyXG4gICAgICAgIC4uLnByZXYsXHJcbiAgICAgICAgY3VycmVudENpdHk6IGxvY2F0aW9uU3RhdGVSZXN1bHQuY3VycmVudENpdHksXHJcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogbG9jYXRpb25TdGF0ZVJlc3VsdC5lcnJvcixcclxuICAgICAgICBjYW5SZW50OiBsb2NhdGlvblN0YXRlUmVzdWx0LmNhblJlbnQsXHJcbiAgICAgICAgbG9jYXRpb246IGNvb3JkaW5hdGVzLFxyXG4gICAgICAgIGxvY2F0aW9uTWV0aG9kOiBsb2NhdGlvbk1ldGhvZCxcclxuICAgICAgICBzaG93TG9jYXRpb25Nb2RhbDogZmFsc2UsXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIC8vIERldmVsb3BtZW50IGZhbGxiYWNrXHJcbiAgICAgIGlmIChcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiICYmXHJcbiAgICAgICAgIWxvY2F0aW9uU3RhdGVSZXN1bHQuY2FuUmVudCAmJlxyXG4gICAgICAgIGxvY2F0aW9uU3RhdGVSZXN1bHQuZXJyb3JcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcIvCfj5fvuI8gRGV2ZWxvcG1lbnQgbW9kZTogQXV0by1zZXR0aW5nIFJvbWUgYXMgdGVzdCBsb2NhdGlvbi4uLlwiXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHRlc3RTdGF0ZSA9IGF3YWl0IGdlb1N5c3RlbS5zZXRUZXN0TG9jYXRpb24oXCJyb21lXCIpO1xyXG4gICAgICAgICAgc2V0TG9jYXRpb25TdGF0ZSgocHJldikgPT4gKHtcclxuICAgICAgICAgICAgLi4ucHJldixcclxuICAgICAgICAgICAgY3VycmVudENpdHk6IHRlc3RTdGF0ZS5jdXJyZW50Q2l0eSxcclxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3I6IGBEZXYgbW9kZTogVXNpbmcgJHt0ZXN0U3RhdGUuY3VycmVudENpdHk/Lm5hbWV9LiBPcmlnaW5hbCBlcnJvcjogJHtsb2NhdGlvblN0YXRlUmVzdWx0LmVycm9yfWAsXHJcbiAgICAgICAgICAgIGNhblJlbnQ6IHRlc3RTdGF0ZS5jYW5SZW50LFxyXG4gICAgICAgICAgICBsb2NhdGlvbk1ldGhvZDogXCJtYW51YWxcIixcclxuICAgICAgICAgICAgc2hvd0xvY2F0aW9uTW9kYWw6IGZhbHNlLFxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKHRlc3RFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRlc3QgbG9jYXRpb24gZmFpbGVkOlwiLCB0ZXN0RXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBzZXRMb2NhdGlvblN0YXRlKChwcmV2KSA9PiAoe1xyXG4gICAgICAgIC4uLnByZXYsXHJcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCBcIkxvY2F0aW9uIGFjY2VzcyBmYWlsZWRcIixcclxuICAgICAgICBjYW5SZW50OiBmYWxzZSxcclxuICAgICAgICBzaG93TG9jYXRpb25Nb2RhbDogdHJ1ZSwgLy8gU2hvdyBtb2RhbCBvbiBlcnJvclxyXG4gICAgICAgIGxvY2F0aW9uTWV0aG9kOiBcIm5vbmVcIixcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3Qgc2V0VGVzdExvY2F0aW9uID0gdXNlQ2FsbGJhY2soXHJcbiAgICBhc3luYyAoXHJcbiAgICAgIGNpdHlJZDogXCJyb21lXCIgfCBcIm1pbGFuXCIgfCBcInBhcmlzXCIgfCBcImJlcmxpblwiIHwgXCJtYWRyaWRcIlxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIHNldExvY2F0aW9uU3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSkpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB0ZXN0U3RhdGUgPSBhd2FpdCBnZW9TeXN0ZW0uc2V0VGVzdExvY2F0aW9uKGNpdHlJZCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBjaXR5IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY29uc3QgY2l0eUNvb3JkaW5hdGVzID0gdGVzdFN0YXRlLmN1cnJlbnRDaXR5Py5jb29yZGluYXRlcyB8fCBudWxsO1xyXG5cclxuICAgICAgICBzZXRMb2NhdGlvblN0YXRlKChwcmV2KSA9PiAoe1xyXG4gICAgICAgICAgLi4ucHJldixcclxuICAgICAgICAgIGN1cnJlbnRDaXR5OiB0ZXN0U3RhdGUuY3VycmVudENpdHksXHJcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgICAgICBjYW5SZW50OiB0ZXN0U3RhdGUuY2FuUmVudCxcclxuICAgICAgICAgIGxvY2F0aW9uOiBjaXR5Q29vcmRpbmF0ZXMsXHJcbiAgICAgICAgICBsb2NhdGlvbk1ldGhvZDogXCJtYW51YWxcIixcclxuICAgICAgICAgIHNob3dMb2NhdGlvbk1vZGFsOiBmYWxzZSxcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn6eqIFRlc3QgbG9jYXRpb24gc2V0OiAke2NpdHlJZH1gKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgIHNldExvY2F0aW9uU3RhdGUoKHByZXYpID0+ICh7XHJcbiAgICAgICAgICAuLi5wcmV2LFxyXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgICAgbG9jYXRpb25NZXRob2Q6IFwibm9uZVwiLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFtdXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgY2xlYXJMb2NhdGlvbiA9IHVzZUNhbGxiYWNrKCgpOiB2b2lkID0+IHtcclxuICAgIGdlb1N5c3RlbS5jbGVhckxvY2F0aW9uQ2FjaGUoKTtcclxuICAgIHNldExvY2F0aW9uU3RhdGUoe1xyXG4gICAgICBjdXJyZW50Q2l0eTogbnVsbCxcclxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgIGNhblJlbnQ6IGZhbHNlLFxyXG4gICAgICBuZWFyYnlWZWhpY2xlczogW10sXHJcbiAgICAgIGxvY2F0aW9uOiBudWxsLFxyXG4gICAgICBzaG93TG9jYXRpb25Nb2RhbDogZmFsc2UsXHJcbiAgICAgIGxvY2F0aW9uTWV0aG9kOiBcIm5vbmVcIixcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coXCLwn5eR77iPIExvY2F0aW9uIGNsZWFyZWRcIik7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBJbml0aWFsaXplIG9uIG1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGxldCBtb3VudGVkID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsaXplID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICBpZiAoIW1vdW50ZWQpIHJldHVybjtcclxuICAgICAgYXdhaXQgcmVmcmVzaExvY2F0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGluaXRpYWxpemUoKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBtb3VudGVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gIH0sIFtyZWZyZXNoTG9jYXRpb25dKTtcclxuXHJcbiAgLy8gUmV0dXJuIGV4dGVuZGVkIHN0YXRlIHdpdGggYm90aCBsb2NhdGlvbiBhbmQgY29vcmRpbmF0ZXMgKHNhbWUgdmFsdWUpXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLmxvY2F0aW9uU3RhdGUsXHJcbiAgICBjb29yZGluYXRlczogbG9jYXRpb25TdGF0ZS5sb2NhdGlvbiwgLy8gQWxpYXMgZm9yIGNvbXBhdGliaWxpdHlcclxuICAgIHJlZnJlc2hMb2NhdGlvbixcclxuICAgIHNldFRlc3RMb2NhdGlvbixcclxuICAgIGNsZWFyTG9jYXRpb24sXHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIlZlaGljbGVHZW9sb2NhdGlvblN5c3RlbSIsInVzZUxvY2F0aW9uQW5kQ2l0eSIsImxvY2F0aW9uU3RhdGUiLCJzZXRMb2NhdGlvblN0YXRlIiwiY3VycmVudENpdHkiLCJpc0xvYWRpbmciLCJlcnJvciIsImNhblJlbnQiLCJuZWFyYnlWZWhpY2xlcyIsImxvY2F0aW9uIiwic2hvd0xvY2F0aW9uTW9kYWwiLCJsb2NhdGlvbk1ldGhvZCIsImdlb1N5c3RlbSIsInJlZnJlc2hMb2NhdGlvbiIsInByZXYiLCJsb2NhdGlvblN0YXRlUmVzdWx0IiwiZ2V0Q3VycmVudExvY2F0aW9uU3RhdGUiLCJjb29yZGluYXRlcyIsImZyZXNoTG9jYXRpb24iLCJnZXRDdXJyZW50TG9jYXRpb24iLCJjb29yZEVycm9yIiwibWV0aG9kIiwicHJvY2VzcyIsImNvbnNvbGUiLCJsb2ciLCJ0ZXN0U3RhdGUiLCJzZXRUZXN0TG9jYXRpb24iLCJuYW1lIiwidGVzdEVycm9yIiwibWVzc2FnZSIsImNpdHlJZCIsImNpdHlDb29yZGluYXRlcyIsImNsZWFyTG9jYXRpb24iLCJjbGVhckxvY2F0aW9uQ2FjaGUiLCJtb3VudGVkIiwiaW5pdGlhbGl6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useLocationAndCity.ts\n"));

/***/ })

});